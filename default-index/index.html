<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"penggehero.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-9256612801953386"
     crossorigin="anonymous"></script>

  <meta property="og:type" content="website">
<meta property="og:title" content="云泽的博客">
<meta property="og:url" content="https://penggehero.github.io/default-index/index.html">
<meta property="og:site_name" content="云泽的博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="penggewu">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://penggehero.github.io/default-index/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>云泽的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">云泽的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://penggehero.github.io/2025/09/05/agent%E6%80%9D%E7%BB%B4%E6%A8%A1%E5%BC%8F%E4%BB%8B%E7%BB%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="penggewu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="云泽的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/09/05/agent%E6%80%9D%E7%BB%B4%E6%A8%A1%E5%BC%8F%E4%BB%8B%E7%BB%8D/" class="post-title-link" itemprop="url">agent思维模式介绍</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-09-05 19:29:08" itemprop="dateCreated datePublished" datetime="2025-09-05T19:29:08+08:00">2025-09-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-09-08 12:00:40" itemprop="dateModified" datetime="2025-09-08T12:00:40+08:00">2025-09-08</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="agent思维模式介绍"><a href="#agent思维模式介绍" class="headerlink" title="agent思维模式介绍"></a>agent思维模式介绍</h1><p>智能体（AI）Agent 正在迅速发展，其核心在于其“思维模式”或认知架构，这决定了它们如何推理、规划和执行任务。</p>
<p>本文将详细介绍以下几种流行的AI Agent思维模式，并为您提供详细的解释、Mermaid流程图、基于LangChain和AutoGen等流行框架的Python代码示例，以及相关的参考文献链接。</p>
<h2 id="1-ReAct-Reasoning-and-Acting"><a href="#1-ReAct-Reasoning-and-Acting" class="headerlink" title="1. ReAct (Reasoning and Acting)"></a>1. ReAct (Reasoning and Acting)</h2><h3 id="模式介绍"><a href="#模式介绍" class="headerlink" title="模式介绍"></a>模式介绍</h3><p>ReAct模式是一种将推理（Reasoning）和行动（Acting）相结合的框架。在这个模式中，Agent不仅仅是生成文本，而是以一种交错的方式生成推理轨迹和任务相关的行动。 这种方式允许Agent在与外部工具（如搜索引擎、API）交互以获取额外信息的同时，还能进行动态的推理来创建、维护和调整其行动计划。ReAct的核心思想是通过一个“思考-行动-观察”的循环来解决问题。</p>
<p>ReAct 的工作流程是一个循环：<strong>思考 -&gt; 行动 -&gt; 观察</strong>。</p>
<ul>
<li><strong>思考 (Thought)</strong>: Agent根据当前任务和已有信息，生成一个关于下一步应该做什么的推理过程。</li>
<li><strong>行动 (Action)</strong>: 基于思考的结果，Agent决定并执行一个具体的行动，例如调用一个工具。</li>
<li><strong>观察 (Observation)</strong>: Agent接收来自行动的反馈结果。</li>
</ul>
<p>这个循环会一直重复，直到 Agent 认为已经收集到足够的信息来回答用户的问题。 这种模式增强了模型的透明度和可靠性，因为它允许我们追溯Agent的思考过程，并且通过与外部世界的交互来减少幻觉和错误。</p>
<p><strong>Mermaid 图:</strong></p>
<pre class="mermaid">graph TD
    A[用户问题] --> B{Agent: 思考};
    B --> C["Agent: 行动 (使用工具)"];
    C --> D[外部工具];
    D --> E{Agent: 观察};
    E --> B;
    E --> F[最终答案];</pre>

<h3 id="Python-代码案例-LangChain"><a href="#Python-代码案例-LangChain" class="headerlink" title="Python 代码案例 (LangChain):"></a><strong>Python 代码案例 (LangChain):</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> dotenv <span class="keyword">import</span> load_dotenv</span><br><span class="line"><span class="keyword">from</span> langchain <span class="keyword">import</span> hub</span><br><span class="line"><span class="keyword">from</span> langchain.agents <span class="keyword">import</span> AgentExecutor, create_react_agent</span><br><span class="line"><span class="keyword">from</span> langchain_community.tools <span class="keyword">import</span> DuckDuckGoSearchRun</span><br><span class="line"><span class="keyword">from</span> langchain_openai <span class="keyword">import</span> ChatOpenAI</span><br><span class="line"></span><br><span class="line">load_dotenv()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 创建一个自定义的工具类，继承自 DuckDuckGoSearchRun</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LoggingDuckDuckGoSearchRun</span>(<span class="title class_ inherited__">DuckDuckGoSearchRun</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    一个自定义的DuckDuckGoSearchRun版本，它会清晰地打印输入和输出。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_run</span>(<span class="params">self, query: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;重写_run方法以添加日志记录。&quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span> + <span class="string">&quot;=&quot;</span> * <span class="number">30</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;🔎 [DuckDuckGo] 正在搜索: <span class="subst">&#123;query&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;=&quot;</span> * <span class="number">30</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 调用父类的原始_run方法来执行实际的搜索</span></span><br><span class="line">        result = <span class="built_in">super</span>()._run(query)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span> + <span class="string">&quot;-&quot;</span> * <span class="number">30</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;📄 [DuckDuckGo] 收到结果:&quot;</span>)</span><br><span class="line">        <span class="comment"># 为了可读性，可以只打印结果的一部分</span></span><br><span class="line">        <span class="built_in">print</span>(result[:<span class="number">500</span>] + <span class="string">&quot;...&quot;</span> <span class="keyword">if</span> <span class="built_in">len</span>(result) &gt; <span class="number">500</span> <span class="keyword">else</span> result)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;-&quot;</span> * <span class="number">30</span> + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 在工具列表中使用我们自定义的工具</span></span><br><span class="line">tools = [LoggingDuckDuckGoSearchRun()]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从 LangChain Hub 获取 ReAct 提示模板</span></span><br><span class="line">prompt = hub.pull(<span class="string">&quot;hwchase17/react&quot;</span>)</span><br><span class="line"></span><br><span class="line">llm = ChatOpenAI(</span><br><span class="line">    model=<span class="string">&quot;gpt-4.1&quot;</span>,</span><br><span class="line">    temperature=<span class="number">0</span>,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 ReAct Agent</span></span><br><span class="line">agent = create_react_agent(llm, tools, prompt)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 Agent 执行器</span></span><br><span class="line"><span class="comment"># 让 AgentExecutor 自己的 verbose 输出保持开启，以便看到思考链</span></span><br><span class="line">agent_executor = AgentExecutor(agent=agent, tools=tools, verbose=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行 Agent</span></span><br><span class="line">response = agent_executor.invoke(</span><br><span class="line">    &#123;<span class="string">&quot;input&quot;</span>: <span class="string">&quot;2024年赢得ACM国际大学生程序设计竞赛（ICPC）的国家是哪个？这个国家的首都是哪里？&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span> + <span class="string">&quot;*&quot;</span> * <span class="number">50</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;最终响应:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(response)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;*&quot;</span> * <span class="number">50</span>)</span><br></pre></td></tr></table></figure>

<h3 id="输出"><a href="#输出" class="headerlink" title="输出:"></a><strong>输出:</strong></h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&gt; Entering new AgentExecutor chain...</span><br><span class="line">Thought: 我需要查找2024年ACM国际大学生程序设计竞赛（ICPC）的冠军国家，然后再查找该国家的首都。</span><br><span class="line">Action: duckduckgo_search</span><br><span class="line">Action Input: 2024年ACM国际大学生程序设计竞赛冠军国家</span><br><span class="line">==============================</span><br><span class="line">🔎 [DuckDuckGo] 正在搜索: 2024年ACM国际大学生程序设计竞赛冠军国家</span><br><span class="line">==============================</span><br><span class="line"></span><br><span class="line">------------------------------</span><br><span class="line">📄 [DuckDuckGo] 收到结果:</span><br><span class="line">2024 年9月15日至20日，第48届ICPC 国际大学生程序设计大赛 世界总决赛（ICPC World Finals 2024 ）在哈萨克斯坦首都阿斯塔纳举行。 来自全球111个国家，超过3000所学校的选手经过层层选拔，产生141支世界顶尖学生程序员队伍向总 冠军 席位发出激烈的角逐。 2024年10月25日 — 近日，第48届ICPC 国际大学生程序设计竞赛 世界总决赛（ICPCWorldFinals2024）在哈萨克斯坦首都阿斯塔纳成功举办。受 竞赛 组委会邀请，上海大学党委常委、副校长聂清率团出访 ... 2024年12月30日 — 本场的ICPC区域赛（香港站）为今年最后一个亚洲区域赛的站点，共有来自包括北京大学、北京航空航天大学、上海交通大学、哈尔滨工业大学、南京大学等115所院校的149支参赛队伍 ... 2024年11月3日 — 再創佳績！港科大（廣州）大一本科生在ICPC 國際大學生程序設計競賽 亞洲區域賽斬獲金獎 ... 11月3日，第49屆ICPC 國際大學生程序設計競賽 （International Collegiate Programming ... 20...</span><br><span class="line">------------------------------</span><br><span class="line"></span><br><span class="line">2024 年9月15日至20日，第48届ICPC 国际大学生程序设计大赛 世界总决赛（ICPC World Finals 2024 ）在哈萨克斯坦首都阿斯塔纳举行。 来自全球111个国家，超过3000所学校的选手经过层层选拔，产生141支世界顶尖学生程序员队伍向总 冠军 席位发出激烈的角逐。 2024年10月25日 — 近日，第48届ICPC 国际大学生程序设计竞赛 世界总决赛（ICPCWorldFinals2024）在哈萨克斯坦首都阿斯塔纳成功举办。受 竞赛 组委会邀请，上海大学党委常委、副校长聂清率团出访 ... 2024年12月30日 — 本场的ICPC区域赛（香港站）为今年最后一个亚洲区域赛的站点，共有来自包括北京大学、北京航空航天大学、上海交通大学、哈尔滨工业大学、南京大学等115所院校的149支参赛队伍 ... 2024年11月3日 — 再創佳績！港科大（廣州）大一本科生在ICPC 國際大學生程序設計競賽 亞洲區域賽斬獲金獎 ... 11月3日，第49屆ICPC 國際大學生程序設計競賽 （International Collegiate Programming ... 2024年10月12日 — 2024年 9月15日至20日，第48届 国际大学生程序设计竞赛 全球总决赛ICPC WF（ICPC World Finals）在哈萨克斯坦首都阿斯塔纳举行。信息科学技术学院2023级本科生王蔚澄、 ...Thought: 目前搜索结果主要提到2024年ICPC总决赛在哈萨克斯坦首都阿斯塔纳举行，但没有直接给出冠军国家的信息。我需要进一步查找2024年ICPC总决赛的冠军队伍或国家。</span><br><span class="line">Action: duckduckgo_search</span><br><span class="line">Action Input: 2024 ICPC World Finals winner</span><br><span class="line">==============================</span><br><span class="line">🔎 [DuckDuckGo] 正在搜索: 2024 ICPC World Finals winner</span><br><span class="line">==============================</span><br><span class="line"></span><br><span class="line">------------------------------</span><br><span class="line">📄 [DuckDuckGo] 收到结果:</span><br><span class="line">2024年9月19日 — 935. World Champion . Asia East Champion . <span class="variable">$16200</span>. Gold medal 2. Russia · Moscow Institute of Physics and Technology (Yolki-palki):. Denis Mustafin, Tikhon Evteev ... 2024年9月17日 2024年9月22日 — Here they are, the winners of The 2024 ICPC World Finals! Peking University Tsinghua University Moscow Institute of Physics and Technology Tokyo ... 2024年10月9日 — The 2024 World Champions: Peking University . 2024 Champions From among 141 teams of three, chosen from a field of 73,083 students wit...</span><br><span class="line">------------------------------</span><br><span class="line"></span><br><span class="line">2024年9月19日 — 935. World Champion . Asia East Champion . <span class="variable">$16200</span>. Gold medal 2. Russia · Moscow Institute of Physics and Technology (Yolki-palki):. Denis Mustafin, Tikhon Evteev ... 2024年9月17日 2024年9月22日 — Here they are, the winners of The 2024 ICPC World Finals! Peking University Tsinghua University Moscow Institute of Physics and Technology Tokyo ... 2024年10月9日 — The 2024 World Champions: Peking University . 2024 Champions From among 141 teams of three, chosen from a field of 73,083 students with 12,258 coaches and ... 2024年9月26日 — Team Absinthe<span class="string">&#x27;s silver medal win at the 2024 International Collegiate Programming Contest (ICPC) World Finals marks a historic achievement.Thought: 我已经查到2024年ICPC世界总决赛的冠军是北京大学。北京大学位于中国，因此冠军国家是中国。接下来需要确认中国的首都。</span></span><br><span class="line"><span class="string">Action: duckduckgo_search</span></span><br><span class="line"><span class="string">Action Input: 中国的首都</span></span><br><span class="line"><span class="string">==============================</span></span><br><span class="line"><span class="string">🔎 [DuckDuckGo] 正在搜索: 中国的首都</span></span><br><span class="line"><span class="string">==============================</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">------------------------------</span></span><br><span class="line"><span class="string">📄 [DuckDuckGo] 收到结果:</span></span><br><span class="line"><span class="string">北平 为中国的首都 已有七百多年的历史。 在政治上，北平位于华北老解放区内，人民力量雄厚，规模弘伟，文物集中，是世界上有名的历史的大都市之一，且自五四以来，这里就是新文化思想的摇篮。 [běi jīng shì] 中华人民共和国首都、直辖市 北京市（Beijing），简称“京”，古称燕京、北平，是中华人民共和国首都、直辖市、国家中心城市、超大城市， [185]国务院批复确定的中国政治中心、文化中心、国际交往中心、科技创新中心， 中国历史文化名城和古都之一，世界一线城市。 [142] [188]截至2023年10月，北京市下辖16个区，总面积16410.54平方千米。 [193] [195]2023年末，北京市常住人口2185.8万人。 北京市地处中国北部、华北平原北部，东与天津市毗连，其余均与河北省相邻，中心位于东经116°20′、北纬39°56′，北京市地势西北高、东南低。西部、北部和东北部三面环山，东南部是一片缓缓向渤海倾斜的平原。境内流经的主要河流有：永定河、潮白河、北运河、拒马河等，北京市的气候为暖温带半湿润半干旱季风气候，夏季高温多雨，冬季寒冷干燥，春、秋短促。 北京市是中国...</span></span><br><span class="line"><span class="string">------------------------------</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">北平 为中国的首都 已有七百多年的历史。 在政治上，北平位于华北老解放区内，人民力量雄厚，规模弘伟，文物集中，是世界上有名的历史的大都市之一，且自五四以来，这里就是新文化思想的摇篮。 [běi jīng shì] 中华人民共和国首都、直辖市 北京市（Beijing），简称“京”，古称燕京、北平，是中华人民共和国首都、直辖市、国家中心城市、超大城市， [185]国务院批复确定的中国政治中心、文化中心、国际交往中心、科技创新中心， 中国历史文化名城和古都之一，世界一线城市。 [142] [188]截至2023年10月，北京市下辖16个区，总面积16410.54平方千米。 [193] [195]2023年末，北京市常住人口2185.8万人。 北京市地处中国北部、华北平原北部，东与天津市毗连，其余均与河北省相邻，中心位于东经116°20′、北纬39°56′，北京市地势西北高、东南低。西部、北部和东北部三面环山，东南部是一片缓缓向渤海倾斜的平原。境内流经的主要河流有：永定河、潮白河、北运河、拒马河等，北京市的气候为暖温带半湿润半干旱季风气候，夏季高温多雨，冬季寒冷干燥，春、秋短促。 北京市是中国共产党中央委员会、中华人民共和国中央人民政府和中华人民共和国全国人民代表大会常务委员会所在地。 [142]北京市成功举办夏奥会与冬奥会，成为全世界第一个“双奥之城”。 [127]北京市是中华民族的发祥地之一， [194]世界著名古都和现代化国际城市， 荟萃了自元、明、清以来的中华优秀传统文化成果，拥有众多名胜古迹和人文景观，是全球拥有世界文化遗产数量最多的城市。 2023年， 北京全年实现地区生产总值43760.7亿元，按不变价格计算，比上年增长5.2%。第一产业实现增加值105.5亿元，下降4.6%；第二产业实现增加值6525.6亿元，增长0.4%；第三产业实现增加值37129.6亿元，增长6.1%。 See full list on baike.baidu.com 建置沿革 早在西周初年，周武王即封召公于北京及附近地区，称燕，都城在今北京市房山区的琉璃河镇，遗址尚存。又封黄帝之后人于蓟，在今北京市西南。后燕国灭蓟国，迁都于蓟，统称为燕都或燕京。秦置广阳郡、蓟县（今北京市西城区广安门一带），共治蓟，同时设渔阳郡，渔阳郡治今怀柔区梨园庄东南，上谷郡治今河北省怀来县。西汉广阳郡先后改为燕国、广阳国。王莽时期广阳国改为广有郡，上谷郡改名朔调郡，渔阳郡改名通路郡，蓟县改名伐戎县。东汉恢复旧称。东汉建武十三年（37年），广阳郡并入上谷郡。永元八年（96年），复置广阳郡。渔阳郡东汉期间徙治潞。三国魏广阳郡改为燕国，渔阳郡并人。北魏燕国改为燕郡，复置渔阳郡，上谷郡徙治居庸（今延庆区东）。北齐于燕郡置东北道行台，废上谷郡。北周东北道行台改为幽州大都督府。隋开皇三年（583年），废渔阳郡。大业三年（607年），幽州改为涿郡。唐武德元年（618年），涿郡改为幽州总管府，后先后改为幽州大总管府、范阳郡、幽州大都督府、幽州都督府。建中二年（781年），析蓟县西境置幽都县，与蓟县共治幽州城。 [103]五代初期，军阀刘仁恭在此建立地方政权，称燕王，后被后唐消灭。北宋初年，赵光义在高梁河（今北京市西城区）与辽战斗，北宋大败，对燕云十六州从此望眼欲穿。辽会同元年（938年），升幽州为南京，又称燕京，置幽都府，治南京城；蓟县改名蓟北县，与幽都县共同附郭南京。开泰元年（1012年），幽都府更名析津府，蓟北县更名析津县，幽都县更名宛平县。析津府辖6州、直辖11县，州辖13县，共24县。今辖区除延庆县外都在其内，延庆另属儒州。宋宣和四年（1122年），析津府改名燕山府，治燕京，辖12县。金贞元元年（1153年），海陵王迁都燕京，改名中都，析津府改名永安府，治中都城。翌年，永安府改名大兴府，下辖大兴、宛平、安次、漷阴、武清、香河、昌平、良乡、永清、宝坻10县，今通州、顺义直属中都路，大兴、宛平2县共治中都城。元世祖至元元年（1264年），改称中都路大兴府。至元九年（1272年），中都大兴府正式改名为大都路（突厥语：Khanbalik，意为“汗城”，音译为汗八里、甘巴力克），也就是元大都。元大都成为全中国的交通中心，北到岭北行省，东到奴儿干都司（治所黑龙江下游），西到西藏地方，南到海南，都在此交流。从这一时期起，北京成为 中国的首都 。二十一年，置大都路总管府，领左、右警巡2院，辖大兴、宛平、良乡、永清、宝坻、昌平6县和涿、霸、蓟、东安、固安、通、漷、顺、檀、龙庆10州，州领16县，大兴、宛平2县共治大都城。明洪武元年（1368年），置北平承宣布政使司，改大都路为北平府，同年十月应军事需要划归山东行省。洪武九年（1376年），改为北平承宣布政使司驻地。永乐元年（1403年），燕王朱棣经靖难之变后夺得皇位后，以北平为北京，以“顺应天意”之意改北平府为顺天府，称为“行在”（天子行銮驻跸的所在，就称“行在”）且常驻于此；永乐十八年（1420年）十一月初四，明太宗朱棣颁布《迁都诏》，改北平为北京，昭告天下迁都北京 ，十九年，改北京为京师，不称“行在”。洪熙初年，仍称“行在”。正统六年（1441年），罢称“行在”，定为京师，京师顺天府领5州、22县，延庆为京师直隶州。明清时设置顺天府管辖首都地区，地位与北京市类似，但管辖面积不同。清兵入关后即进驻北京，也称北京为京师顺天府，属直隶省。清康熙二十七年（1688年），置四路同知，分辖所属州县。乾隆期间，顺天府共辖24州县，延庆县属宣化府。清咸丰十年（1860年），英法联军打进北京并签订《北京条约》。清光绪二十六年（1900年），八国联军再次打进北京，大量文物被侵略军和坏民劫掠。清光绪二十七年（1901年），清政府在京与十一个国家签署了《辛丑条约》。光绪三十一年（1905年），北京内外城设46区，内城26区，外城20区；三十四年，内城合并为13区，外城合并为10区。宣统二年（1910年）九月，再并内城为10区：中一区，中二区，内左一区至内左四区，内右一区至内右四区；外城10区为：外左一区至外左五区，外右一区至外右五区。民国元年（1912年）1月1日，中华民国定都南京，同年3月迁都北京。民国伊始，北京市的地方体制仍依清制，称顺天府。民国三年（1914年），改顺天府为京兆地方，范围规格与顺天府大致相同，直辖于中央政府北洋政府。这一时期，北京新建了有轨电车系统，和一批现代的文化教育机构，如北京大学、北京师范大学、燕京大学、辅仁大学、北京协和医学院等。民国十七年（1928年）六月，北伐战争后，首都迁回南京，撤销原京兆地方，北京市改名为北平特别市，后改为北平市，隶属于南京国民政府行政院。民国十九年（1930年）6月，北平降格为河北省省辖市，同年12月复升为院辖市。民国二十六年（1937年）七七事变后，抗日战争全面爆发。北平被日本占领，伪中华民国临时政府在此成立，且将北平改名为北京。中国共产党领导人民建立晋察冀抗日根据地，进行民族革命战争。 民国三十四年（1945年）8月21日，入侵北京的日本军队宣布投降，第十一战区孙连仲部接收北京市，并重新更名为北平。北平市所辖范围较之前顺天府、京兆地方及北京市为小，大致包括今西城区、东城区全境，朝阳区大部、海淀区南半部、石景山区南部和丰台区北半部。1949年1月，在原国民党时期20个区的基础上临时划定32个区，4月将32个区合并为26个区，6月接管任务完成后调整为20个区。1949年1月31日，傅作义与中国共产党达成和平协议，率领25万国民党军队投向共产党，中国人民解放军进入北平市，北京和平解放。1949年9月27日中国人民政治协商会议第一届全体会议通过《关于中华人民共和国国都、纪年、国歌、国旗的决议》，北平更名为北京。1949年10月1日，中华人民共和国中央人民政府在北京宣告成立。 See full list on baike.baidu.com 区划沿革 1952年，北京市由华北行政委员会领导。同年7月，将河北省宛平县全部及房山、良乡2县部分地区划归北京市。1956年3月9日，撤销昌平县，将昌平县所属行政区域（高丽营镇除外）划归北京市，并命名为昌平区。将河北省通县所属的金盏、长店、北皋、孙河、崔各庄、上新堡、前苇沟等7个乡归北京市。1958年3月，河北省通县专区所属通县、顺义、大兴、良乡、房山等5县及通州市划入北京市。其后撤销西单区、西四区两区，合并设立西城区；撤销东单区、东四区二区，合并设立东城区；撤销前门区，并入崇文区、宣武区二区；东郊区改名为朝阳区；撤销石景山区，分别划归丰台区、海淀区和门头沟区；京西矿区改名为门头沟区；撤销通县和通州市，合并设立通州区；撤销良乡区、房山区二区，合并设立周口店区；撤销大兴县，改为大兴区；撤销南苑区，划归朝阳区、丰台区和大兴区；撤销顺义县，改为顺义区。10月，河北省所属怀柔、密云、平谷、延庆4县划入北京市。1960年1月7日，撤销昌平区，恢复昌平县；撤销顺义区，恢复顺义县；撤销通州区，恢复通县；撤销大兴区，恢复大兴县；撤销周口店区，恢复房山县。至1960年底，北京市下辖东城、西城、宣武、崇文、海淀、朝阳、丰台、门头沟等8区和昌平、延庆、怀柔、密云、顺义、平谷、通县、大兴、房山等9县。1967年8月7日，撤销石景山办事处，设立石景山区。1980年10月20日，设立燕山区。1986年11月11日，撤销房山县、燕山区，设立房山区。以原房山县和燕山区的行政区域为房山区的行政区域 。1997年4月29日，经国务院（国函[1997]30号）批准，同意撤销通县，设立通州区，以原通县的行政区域为通州区的行政区。1998年3月3日，经国务院（国函[1998]17号）批准撤销顺义县，设立北京市顺义区，以原顺义县的行政区域为顺义区的行政区域。1999年9月16日，北京市撤销昌平县，设立昌平区。2001年3月2日，北京市撤销大兴县，设立大兴区。2002年2月7日，北京市撤销怀柔、平谷两县，设立北京市怀柔区、平谷区。2010年7月1日，北京市撤销原东城区、崇文区，设立新的北京市东城区；撤销北京市原西城区、宣武区，设立新的北京市西城区。2015年11月17日，北京市撤销密云、延庆两县，设立北京市密云区、延庆区。至此，北京市告别县治时代。 区划详情 截至2023年，北京市共辖16个市辖区，分别是东城区、西城区、朝阳区、丰台区、石景山区、海淀区、顺义区、通州区、大兴区、房山区、门头沟区、昌平区、平谷区、密云区、怀柔区、延庆区。北京市人民政府驻通州区运河东大街57号。 See full list on baike.baidu.com 位置境域 北京市位于华北平原的西北端，东经115°20′至117°30′，北纬39°28′至41°05′之间，地处海河流域中部。总面积16410平方千米。位于华北平原北部，毗邻渤海湾，上靠辽东半岛，下临山东半岛。北京市与天津市相邻，并与天津市一起被河北省环绕。 地形地貌 北京市地处华北平原西北隅，地势西北高、东南低。地形的特点是山地多、平原少，北部为中低山区，东南部是缓斜的平原，其中山区面积约占61%，平原面积约占39%。全市平均海拔43.5米。北京市平原的海拔高度在20～60米，山地一般海拔1000～1500米。主要山脉有太行山和燕山山脉。 北京市西部为西山属太行山脉；北部和东北部为军都山属燕山山脉。最高的山峰为京西门头沟区的东灵山，海拔2303米。最低点三垡位于通州区，海拔7米。两山在南口关沟相交，形成一个向东南展开的半圆形大山弯，人们称之为“北京弯”，它所围绕的小平原即为北京小平原。诚如古人所言：“幽州之地，左环沧海，右拥太行，北枕居庸，南襟河济，诚天府之国”。 气候 北京市的气候为暖温带半湿润半干旱季风气候，夏季高温多雨，冬季寒冷干燥，春、秋短促。全年无霜期180～200天，西部山区较短。2007年平均降雨量483.9毫米，为华北地区降雨最多的地区之一。降水季节分配很不均匀，全年降水的80%集中在夏季6、7、8三个月，7、8月有大雨。北京市太阳辐射量全年平均为112～136千卡/厘米。两个高值区分别分布在延庆盆地及密云县西北部至怀柔东部一带，年辐射量均在135千卡/厘米以上；低值区位于房山区的霞云岭附近，年辐射量为112千卡/厘米。北京市年平均日照时数在2000～2800小时之间。最大值在延庆区和古北口，为2800小时以上，最小值分布在霞云岭，日照为2063小时。夏季正当雨季，日照时数减少，月日照在230小时左右；秋季日照时数虽没有春季多，但比夏季要多，月日照230～245小时；冬季是一年中日照时数最少季节，月日照不足200小时，一般在170～190小时。 See full list on baike.baidu.com 水资源 北京市天然河道自西向东贯穿五大水系：拒马河水系、永定河水系、北运河水系、潮白河水系和蓟运河水系。多由西北部山地发源，向东南蜿蜒流经平原地区，最后分别在海河汇入渤海（蓟运河除外）。北京市有水库85座，其中大型水库有密云水库、官厅水库、怀柔水库、海子水库。北京市地下水多年平均补给量约为29.21亿立方米，平均年可开采量约24~25亿立方米。一次性天然水资源年平均总量为55.21亿立方米。2013年北京市总用水量35.3亿立方米，比2012年增长1.4%。其中，生活用水14.5亿立方米，增长4.3%；工业用水5.6亿立方米，下降3.4%；农业用水12亿立方米，下降3.2%。 矿产资源 北京市已发现的矿种共67种，矿床、矿点产地476处，列入国家储量表的矿种44种，其中：能源矿产2种；黑色金属矿产4种，有色金属、贵金属及分散元素矿产11种；冶金辅助原料非金属矿产7种；化工原料非金属矿产5种；建材及其他非金属矿产15种。共有产地300处，其中黑色金属产地49处，有色金属产地35处，冶金辅助原料非金属产地43处，化工原料非金属产地68处，建材及其他非金属产地75处，煤炭产地30处。 植物资源 北京地带性植被类型是暖温带落叶阔叶林并间有温性针叶林的分布。大部分平原地区已成为农田和城镇，只在河岸两旁局部洼地发育着以芦苇、香蒲、慈菇等为主的洼生植被，但多数洼地已被开辟为鱼塘，在搁荒地及田埂、路旁多杂草；湖泊，水塘中发育着沉水和浮叶的水生植被。海拔800米以下的低山带表性的植被类型是栓皮栎林、栎林、油松林和侧柏林。海拔800米以上的中山，森林覆盖率增大，其下部以辽东栎林为主，海拔1000米至1800~2000米，桦树增多，在森林群落破坏严重的地段，为二色胡枝子、榛属、绣线菊属占优势的灌丛。海拔1800~1900米以上的山顶生长着山地杂类草草甸。全市森林覆盖率达到44.8%，森林蓄积量达到3164万立方米，城市绿化覆盖率达到49.3%，人均公园绿地面积16.63平方米，森林资源资产价值达到9070亿元，林地绿地生态系统年碳汇能力达880万吨。 See full list on baike.baidu.com 人口数量 •第七次全国人口普查常住人口2020年11月1日零时，北京市常住人口为2189.3万人，与2010年（第六次全国人口普查数据，下同）的1961.2万人相比，十年增加228.1万人，平均每年增加22.8万人，年平均增长1.1%。比2000年到2010年的年平均增长率3.8%下降2.7个百分点。常住人口中，外省市来京人口为841.8万人，占常住人口的38.5%。与2010年相比，增加137.3万人，增长19.5%，年平均增长1.8%，在常住人口中的比重上升2.6个百分点。户别人口北京市常住人口中，共有家庭户8230792户，集体户907136户，家庭户人口为19014338人，集体户人口为2878757人。平均每个家庭户的人口为2.31人，与2010年第六次全国人口普查的2.45人相比，减少0.14人。城乡人口北京市常住人口中，从城乡构成看，城镇人口1912.8万人，乡村人口271.5万人；城镇人口占全市常住人口的比重为87.6%。常住人口性别构成北京市常住人口中，男性人口为11195390人，占51.1%；女性人口为10697705人，占48.9%。常住人口性别比（以女性为100，男性对女性的比例）为104.7，与2010年第六次全国人口普查相比下降2.1。常住人口年龄构成北京市常住人口中，0~14岁人口为2591507人，占11.9%；15~59岁人口为15002998人，占68.5%；60岁及以上人口为4298590人，占19.6%，其中65岁及以上人口为2912060人，占13.3%。与2010年第六次全国人口普查相比，0~14岁人口的比重上升3.3个百分点，15~59岁人口的比重下降10.4个百分点，60岁及以上人口的比重上升7.1个百分点，65岁及以上人口的比重上升4.6个百分点。截至2022年末，北京市常住人口中，0-14岁常住人口264万人，占全市常住人口的比重为12.1%；15-59岁常住人口1455.2万人，占66.6%；60岁及以上常住人口465.1万人，占21.3%。 •2022年末2022年末，北京市常住人口2184.3万人，比上年末减少4.3万人。其中，城镇人口1912.8万人，占常住人口的比重为87.6%；常住外来人口825.1万人，占常住人口的比重为37.8%。常住人口出生率为5.67‰，死亡率为5.72‰，自然增长率为-0.05‰。全年城镇新增就业26万人。全年城镇调查失业率均值为4.7%，运行在年度调控目标内。 •2023年末 民族构成 北京市常住人口中，汉族人口为20845166人，占95.2%；各少数民族人口为1047929人，占4.8%。与2010年第六次全国人口普查相比，汉族人口增加2034012人，增长10.8%，年平均增长1%；各少数民族人口增加246715人，增长30.8%，年平均增长2.7%。2010年第六次人口普查数据显示，北京市少数民族人口80.1万人，占全市常住人口的4.1%。其中千人以上的少数民族21个，满族、回族、蒙古族、朝鲜族、土家族、壮族、苗族7个民族人口超过万人。少数民族人口最多的区是朝阳区(14万人)和海淀区(13.5万人)，少数民族人口比例最高的区是怀柔区(8.5%)和密云区(7.5%)。 老龄事业 北京市户籍居民平均期望寿命2021年9月6日，北京市老龄协会正式发布了《北京市老龄事业发展报告（2020）》。2020年，北京市户籍居民平均期望寿命为82.43岁，北京市百岁老年人已达1438人。2016~2020年，80岁及以上户籍老年人口逐年增加，从59.5万上升到63.3万，增加3.8万人。2016~2020年，百岁老年人逐年增加，由751人上升到1438人，增加687人；其中，女性百岁老年人总量高于男性，且逐年增长。2020年，北京市户籍居民平均期望寿命为82.43岁。 See full list on baike.baidu.com 综述 2023年， 北京市实现地区生产总值43760.7亿元，按不变价格计算，比上年增长5.2%。其中，第一产业增加值105.5亿元，下降4.6%；第二产业增加值6525.6亿元，增长0.4%；第三产业增加值37129.6亿元，增长6.1%。三次产业构成为0.2︰14.9︰84.8。按常住人口计算，全市人均地区生产总值为20.0万元。2023年，北京市居民消费价格总水平比上年上涨0.4%。工业生产者出厂价格下降0.8%，工业生产者购进价格下降1.3%。农产品生产者价格下降0.3%。12月份，新建商品住宅销售价格环比指数为100.0、同比指数为101.7；二手住宅销售价格环比指数为98.8、同比指数为97.8。2023年，北京市完成一般公共预算收入6181.1亿元，比上年增长8.2%。其中，税收收入5357.1亿元，增长10.1%。全市一般公共预算支出7971.6亿元，比上年增长6.7%。全年累计新增减税降费及退税缓费971.7亿元。2023年，北京市实现数字经济增加值18766.7亿元，按现价计算，比上年增长8.5%，占地区生产总值的比重为42.9%，比上年提高1.3个百分点。其中，数字经济核心产业增加值11061.5亿元，增长10.8%，占地区生产总值的比重为25.3%，提高1.3个百分点。全年实现高技术产业增加值11875.4亿元，按现价计算，增长7.1%，占地区生产总值的比重为27.1%，提高0.4个百分点。全年新设科技型企业12.3万家，增长15.9%，占全市新设企业的41.4%。 第一产业 2023年，全市实现农林牧渔业总产值252.5亿元，按可比价格计算，比上年下降4.6%。其中，实现农业（种植业）产值135.6亿元，增长5.1%，粮食播种面积134.2万亩、产量47.8万吨，分别增长16.6%和5.3%；蔬菜及食用菌播种面积79.5万亩，与上年基本持平，产量207.5万吨，增长4.3%；受2022年新一轮百万亩造林绿化工程收官、基数较高影响，林业实现产值65.9亿元，下降20.6%。全市休闲农业和乡村旅游接待游客2210.1万人次，比上年增长23.6%，实现收入36.2亿元，增长12.7%。2022年，北京市实现农林牧渔业总产值268.2亿元，按可比价格计算，比上年下降2.0%。其中，农业（种植业）产值129.8亿元，增长2.3%；林业产值86.5亿元，增长1.4%。全年粮食作物播种面积7.7万公顷，增长26.0%，粮食总产量45.4万吨，增长20.1%；蔬菜及食用菌产量198.9万吨，增长20.1%；年末生猪存栏量36.8万头，下降37.7%，生猪出栏量32.2万头，增长4.3%。设施农业播种面积48.7万亩、实现产值59.8亿元，分别增长4.3%和3.3%。农业观光园1027个，实现总收入18.4亿元。实际经营的乡村旅游接待单位（农户）7105户，实现总收入13.7亿元。 第二产业 •工业2023年，北京市实现工业增加值5008.5亿元，按不变价格计算，比上年增长0.3%。其中，规模以上工业增加值增长0.4%。在规模以上工业中，电力、热力生产和供应业增长7.9%，五大装备制造业增长10.6%，汽车制造业增长5.2%，计算机、通信和其他电子设备制造业下降0.9%，医药制造业下降21.7%（剔除新冠疫苗生产因素下降4.3%）。规模以上工业实现销售产值23113.6亿元，增长2.9%。其中,内销产值21342.7亿元，增长3.4%；出口交货值1770.9亿元，下降2.5%。高端或新兴领域产品生产中，风力发电机组、液晶显示模组、新能源汽车、医疗仪器设备及器械产量分别增长68.8%、39.2%、35.6%和26.7%。2023年，北京市规模以上工业企业实现营业收入27807.9亿元，比上年增长3.6%；实现利润总额1692.3亿元，下降12.9%。规模以上工业企业营业收入利润率为6.09%，比上年下降1.15个百分点。•建筑业 See full list on baike.baidu.com 教育事业 北京市是全国教育最发达的地区之一，是全国高等院校的中心，聚集了全国数量最多的重点大学。2022年，北京市研究生教育招生14.6万人，在学研究生43.5万人，毕业生11.4万人。普通高等学校招收本专科学生16.6万人，在校生60.3万人，毕业生15.4万人。全市成人本专科招生3.0万人，在校生7.8万人，毕业生3.9万人。2022年，北京市普通高中招生7.5万人，在校生19.9万人，毕业生5.0万人。普通初中招生12.1万人，在校生35.6万人，毕业生10.4万人。普通小学招生19.0万人，在校生108.4万人，毕业生13.3万人。幼儿园入园幼儿17.9万人，在园幼儿57.4万人。各类中等职业教育（不含技工学校）招生2.0万人，在校生5.5万人，毕业生1.3万人。特殊教育招生1110人，在校生7722人，毕业生1666人。2022年，北京市共有民办高校15所，在校生5.4万人。民办中等教育学校124所，在校学生2.6万人。民办小学41所，在校学生3.8万人。民办幼儿园1037所，在园幼儿24.5万人。2023年，北京市研究生教育招生15.2万人，在学研究生45.5万人，毕业生12.1万人。普通高等学校招收本专科学生17.6万人，在校生61.8万人，毕业生15.4万人。全市成人本专科招生3.0万人，在校生7.6万人，毕业生3.0万人。各类中等职业教育(不含技工学校)招生2.1万人，在校生5.9万人，毕业生1.6万人。普通高中招生8.0万人，在校生21.7万人，毕业生5.9万人。普通初中招生13.5万人，在校生37.1万人，毕业生11.0万人。普通小学招生23.5万人，在校生116.2万人，毕业生14.6万人。特殊教育招生1296人，在校生7825人，毕业生1788人。幼儿园入园幼儿16.4万人，在园幼儿51.5万人。全年共有民办高校15所，在校生5.7万人。民办中等教育学校(不包括技工学校)125所，在校学生2.9万人。民办小学38所，在校学生3.8万人。民办幼儿园1045所，在园幼儿21.3万人。 科学技术 北京市是全国最大的科学技术研究基地，有中国科学院等科学研究机构和号称中国硅谷的北京市中关村科技园区，每年获国家奖励的成果占全国的三分之一。1998年来，每年都成功举办以高新技术产业为主题的大型国际活动——北京高新技术产业国际周。2017年12月，北京习近平新时代中国特色社会主义思想研究中心（院）成立。2022年11月17日，被国家知识产权局办公室确定为开展数据知识产权工作的试点地方，试点工作期限为2022年11月至2023年12月。2022年，北京市专利授权量20.3万件，比上年增长2.0%。其中，发明专利授权量8.8万件，增长11.3%。年末拥有有效发明专利47.8万件，增长18.0%。PCT国际专利申请量11463件，增长10.7%。每万人口高价值发明专利拥有量为112.0件，比上年增加17.8件。全年共认定登记技术合同95061项，增长1.6%；技术合同成交额7947.5亿元，增长13.4%。 [167]2022年，北京首次跻身全球国际科技创新中心前三，综合得分80.39。截至2023年末，在京全国重点实验室77家，占全国的28.1%。国家科技成果转化引导基金累计设立4支子基金，基金总规模64.4亿元。年末全市共有国家级科技企业孵化器71家、国家备案众创空间145家。全年新认定国家高新技术企业1.08万家，累计有效国家高新技术企业2.83万家。截至年末共认定市级“专精特新”企业7180家，其中，国家级专精特新“小巨人”企业795家。年末共有独角兽企业114家，市场总估值5215亿美元。全年发明专利授权量10.8万件，比上年增长22.4%。年末拥有有效发明专利57.4万件，增长20.2%。PCT国际专利申请量11438件。每万人口高价值发明专利拥有量136.95件，增加24.97件。全年共认定登记技术合同106552项，增长12.1%。技术合同成交额8536.9亿元，增长7.4%；北京流向津冀技术合同6758项，增长14.9%，成交额748.7亿元，增长1.1倍。超大规模智能模型“悟道3.0”在语言、视觉多模态上取得突破，涌现出新一代量子计算云平台“夸父”、新一代256核区块链专用加速芯片、首个精通3D任务的具身通才智能体“狮子座”、“朱雀二号”全球首款成功入轨飞行液氧甲烷火箭等多项重大创新成果。 医疗卫生 2023年末，北京市共有医疗卫生机构12518个，比上年末增加307个。其中，医院765个。医疗卫生机构共有床位13.9万张，增加0.5万张。其中，医院床位13.1万张。卫生技术人员34.3万人。其中，执业（助理）医师13.4万人，注册护士15.3万人。医疗机构总诊疗人次为29088.1万人次。 See full list on baike.baidu.com 铁路 •铁路线路北京市是中国铁路网的中心之一，国内线路主要有京九铁路、京沪铁路、京广铁路、京哈铁路、京包铁路、京原铁路、京通铁路、京承铁路和京沪高铁、京广高铁、京哈高铁、京津城际铁路等在国际铁路运输方面，经内蒙古自治区满洲里市去往俄罗斯各城市、经内蒙古自治区二连浩特市去往蒙古国都城乌兰巴托和朝鲜都城平壤以及去往越南都城河内的列车均从北京市发车。•主要车站 航空 北京市境内共有两座大型机场，分别为北京首都国际机场和北京大兴国际机场。北京首都国际机场是全球规模最大的机场之一，是中国国际航空股份有限公司（Air China）的主要运营中心，位于北京市顺义区（行政属朝阳区），距北京市中心20千米。旅客吞吐量在2012年达到8192.9万人次，仅次于美国哈兹菲尔德~杰克逊亚特兰大国际机场，位居全球第二。首都机场和北京市区间由北京市首都机场高速公路、首都机场第二高速公路和北京地铁首都机场线连接。北京大兴国际机场位于北京市大兴区和河北省廊坊市广阳区的交界处，于2019年9月25日正式通航。2021年，北京大兴国际机场共完成旅客量吞吐量25051012人次，货邮吞吐量185942.7吨。北京市还建有5座机场：北京南苑机场（已关闭）、 北京良乡机场、北京西郊机场、北京沙河机场、 北京八达岭机场。 市内交通 •市内公路北京市老城区（二环路以内）的城市道路是棋盘式的格局，横平竖直。东西方向的道路有长安街（复兴门至建国门）、平安大街（东四十条豁口至车公庄）、广安大街（广安门至广渠门）。南北方向的道路有中轴线，从玉蜓桥到雍和宫的东线和开阳桥到积水潭桥的西线。东线路过方庄、红桥、崇文门、东单、东四、北新桥和雍和宫；西线路过菜市口、宣武门、西单、西四、新街口。因为天安门广场和紫禁城的原因，北京市的中轴线分为北中轴和南中轴。北中轴从地安门向北，经鼓楼、北辰路，达国家奥林匹克体育中心；南中轴从前门向南经天桥、永定门，达三营门。南中轴和104国道重合。2023年末，北京市公路里程22433.2公里，比上年末增加70.4公里。其中，高速公路里程1211.1公里，增加14.8公里。年末城市道路里程6256公里，比上年末增加47公里。2023年末，北京市公共汽电车运营线路1285条，比上年末减少6条；运营线路长度29738.5公里，减少435.4公里；运营车辆23385辆，减少80辆；全年客运总量20.9亿人次，增长20.9%。年末轨道交通运营线路27条，与上年末持平；运营线路长度836公里，增加38.7公里；运营车辆7512辆，增加238辆；全年客运总量34.5亿人次，增长52.6%。 •出租汽车2013年，北京市出租车日均运送190万人次，占总出行量的6.6%，里程利用率约68%。 2013年6月10日起调整北京市出租汽车价格标准，新的出租汽车价格为：3千米以内13元，基本单价每千米2.3元。燃油附加费每运次1元。低速行驶和等候费每5分钟早晚高峰期间加收2千米租价（不含空驶费），其他时段加收1千米租价（不含空驶费）。预约叫车服务费为提前4小时以上预约每次6元，4小时以内预约每次5元。单程载客行驶超过15千米部分收取空驶费，基本单价加收50%的费用。 •汽车牌照京A（1996年前）；京B（出租车）；京C（1996年）；京E（1997年）；京F（2002年）；京G（郊区户籍车）；京H（2003年）；京J（2005年）；京K（2006年）；京L（2007年）；京M（2008年）；京N（2008年）；京O（公安）；京P（2008年）；京Y（郊区户籍车）；京V（中央直属部队）；京Q（2012年）。•轨道交通 See full list on baike.baidu.com 名称由来 北京市是一座有着三千多年历史的古都，在不同的朝代有着不同的称谓，大致算起来有二十多个别称。燕都，据史书记载，公元前1045年，周武王灭商以后，在燕封召公。 [106]燕都因古时为燕国都城而得名。战国七雄中有燕国，据说是因临近燕山而得国名，其国都称为“燕都”。幽州，远古时代的九州之一。幽州之名，最早见于《尚书·舜典》：“燕曰幽州。”两汉、魏、晋、唐代都曾设置过幽州，所治均在北京市一带。京城，京城泛指国都，北京成为国都后，也多将其称为京城。南京，辽太宗会同元年（938年），将原来的幽州升为幽都府，建号南京，又称燕京，作为辽的陪都。当时辽的首都在上京。大都，元代以金的离宫今北海公园为中心重建新城，忽必烈至元九年（1272年）改称大都，俗称元大都。北平，明代洪武元年（1368年），朱元璋灭掉元朝后，为了记载平定北方的功绩，将元大都改称北平。北京，明永乐元年（1403年），朱棣取得皇位后，将他做燕王时的封地北平府改为顺天府，建北京城，并准备迁都城于此，这是正式命名为北京的开始，今已有600余年的历史。京师，永乐十八年（1420年）迁都北京，改称京师，直至清代。京兆，民国废顺天府，置京兆地方，直隶中央，其范围包括北京市大部分地区，民国十七年（1928年）废京兆地方，改北京为北平。 北京方言 北京地方语言音质清晰，节奏明快，声调高扬，儿化音的使用成为最显著的特征。北京地区早期以中原雅音为准，明清之际，伴随大量移民不断入京，逐渐形成了以河北口音为主，兼受东北语言影响的北京话。北京话京腔京韵，具有鲜明的地方特色。为便于交流，清中期开始，确立以北京官话为国语正音，历民国至1949年后，最终形成以北京语音为标准音，以北方话为基础方言，全国通用的普通话，成为各族人民最重要的语言交流工具。 非遗及特产 •综述北京是中国四大古都之一，有很多地方特色的民风习俗：北京小吃、京剧、京韵大鼓、相声、舞台剧、铁板快书、景泰蓝、牙雕、毛猴、漆雕、赛蝈蝈和蝈蝈笼、吹糖人、捏面人等等。•京剧京剧是中国国粹。京剧的源头还要追溯到几种古老的地方戏剧，清乾隆五十五年（1790年），安徽的四大地方戏班——三庆班、四喜班、春台班、和春班——先后进京献艺。 [191]徽班常与来自湖北的汉调艺人合作演出，于是，一种以徽调“二黄”和汉调“西皮”为主，兼收昆曲、秦腔、梆子等地方戏精华的新剧种诞生了，这就是京剧。•非遗项目•老字号•地方特产 See full list on baike.baidu.com 问题： 中国的 首都 是哪里？ 快速回答： 中国的 首都 是北京。 位于该国北部， 北京 是现代中国的政治、文化和历史中心。 为什么选择北京作为首都？ 作为首都的悠久历史： 北京有一个 历史 已有 3000 多年的历史，曾作为元朝、明朝、清朝等几个主要朝代的首都。 根据《中华人民共和国宪法》， 北京 是中华人民共和国首都。 北京 是中国共产党中央委员会、中华人民共和国中央人民政府所在地，也是全国政治、经济和科学文化的中心，也是国内国际交往的中心之一，是中国历史文化名城和古都之一。 Nov 17, 2024 · 毛主席对哈尔滨的偏爱也是显而易见的，后来哈尔滨被批准为“特别市”， 可以说，只差临门一脚，它就能成为新中国 首都 的所在地。 北平 为中国的首都 已有七百多年的历史。 在政治上，北平位于华北老解放区内，人民力量雄厚，规模弘伟，文物集中，是世界上有名的历史的大都市之一，且自五四以来，这里就是新文化思想的摇篮。 问题： 中国的 首都 是哪里？ 快速回答： 中国的 首都 是北京。 位于该国北部， 北京 是现代中国的政治、文化和历史中心。 为什么选择北京作为首都？ 作为首都的悠久历史： 北京有一个 历史 已有 3000 多年的历史，曾作为元朝、明朝、清朝等几个主要朝代的首都。 很显然，这是一个只有“白痴”才会问的问题，因为所有中国人都知道， 中国的首都 是——“北京”。 可我们也知道，在中国几千年的历史长河中，并非每一个朝代都是定都在北京的，比如我国历史上第一个封建王朝‘秦朝’，其 首都 是咸阳；北宋的首都是汴梁 ... 北平 为中国的首都 已有七百多年的历史。 在政治上，北平位于华北老解放区内，人民力量雄厚，规模弘伟，文物集中，是世界上有名的历史的大都市之一，且自五四以来，这里就是新文化思想的摇篮。Thought: 我已经查到2024年ACM国际大学生程序设计竞赛（ICPC）世界总决赛的冠军是北京大学，代表国家是中国。中国的首都是北京。</span></span><br><span class="line"><span class="string">Final Answer: 2024年赢得ACM国际大学生程序设计竞赛（ICPC）的国家是中国，这个国家的首都是北京。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&gt; Finished chain.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">**************************************************</span></span><br><span class="line"><span class="string">最终响应:</span></span><br><span class="line"><span class="string">&#123;&#x27;</span>input<span class="string">&#x27;: &#x27;</span>2024年赢得ACM国际大学生程序设计竞赛（ICPC）的国家是哪个？这个国家的首都是哪里？<span class="string">&#x27;, &#x27;</span>output<span class="string">&#x27;: &#x27;</span>2024年赢得ACM国际大学生程序设计竞赛（ICPC）的国家是中国，这个国家的首都是北京。<span class="string">&#x27;&#125;</span></span><br><span class="line"><span class="string">**************************************************</span></span><br></pre></td></tr></table></figure>

<h3 id="代码整体流程："><a href="#代码整体流程：" class="headerlink" title="代码整体流程："></a>代码整体流程：</h3><pre class="mermaid">sequenceDiagram
    participant User as 用户
    participant AgentExecutor as Agent执行器
    participant LLM as GPT-4.1 (核心)
    participant SearchTool as DuckDuckGo搜索 (Tool)

    User->>+AgentExecutor: 提问: "2024年ICPC冠军国家及首都？"

    %% === ReAct 循环 1: 初步探索 ===
    AgentExecutor->>+LLM: 输入: 问题 + 工具描述
    LLM-->>-AgentExecutor: **思考 1**: "我需要先找冠军国家，再找首都。"
    
    AgentExecutor->>+SearchTool: **行动 1**: 搜索 "2024年...冠军国家"
    activate SearchTool
    SearchTool-->>-AgentExecutor: **观察 1**: 返回关于比赛地点(哈萨克斯坦)的信息，无冠军。
    deactivate SearchTool

    %% === ReAct 循环 2: 修正策略 ===
    AgentExecutor->>+LLM: 输入: 问题 + 历史(思考1, 行动1, 观察1)
    LLM-->>-AgentExecutor: **思考 2**: "结果不明确。我需要用更精确的英文关键词查找冠军队伍。"
    
    AgentExecutor->>+SearchTool: **行动 2**: 搜索 "2024 ICPC World Finals winner"
    activate SearchTool
    SearchTool-->>-AgentExecutor: **观察 2**: 返回 "The 2024 World Champions: Peking University" (成功找到队伍)
    deactivate SearchTool

    %% === ReAct 循环 3: 进一步推理并解决第二部分问题 ===
    AgentExecutor->>+LLM: 输入: 问题 + 历史(思考1...观察2)
    LLM-->>-AgentExecutor: **思考 3**: "冠军是北京大学，属于中国。现在需要找中国的首都。"
    
    AgentExecutor->>+SearchTool: **行动 3**: 搜索 "中国的首都"
    activate SearchTool
    SearchTool-->>-AgentExecutor: **观察 3**: 返回北京是中华人民共和国的首都。
    deactivate SearchTool
    
    %% === ReAct 循环 4: 整合并得出最终答案 ===
    AgentExecutor->>+LLM: 输入: 问题 + 历史(思考1...观察3)
    LLM-->>-AgentExecutor: **思考 4**: "信息已完整：冠军国家是中国，首都是北京。可以回答了。"
    
    Note right of LLM: 生成最终答案
    LLM-->>AgentExecutor: **最终答案**: "2024年...的国家是中国，...首都是北京。"

    AgentExecutor-->>-User: 返回最终答案</pre>



<p>这张图清晰地揭示了 ReAct Agent 的“思考过程”：</p>
<ol>
<li><strong>初始规划</strong>: <strong>Agent</strong> 接收到<strong>用户</strong>的复合问题后，内部的 <strong>LLM</strong> 首先进行<strong>思考1</strong>，将任务分解为两个子任务：先找冠军国家，再找首都。</li>
<li><strong>第一次循环 (试探与反馈)</strong>:<ul>
<li><strong>Agent</strong> 根据<strong>思考1</strong>执行<strong>行动1</strong>，调用<strong>搜索工具</strong>。</li>
<li>工具返回的<strong>观察1</strong>并不理想，没有直接答案。这个反馈至关重要。</li>
</ul>
</li>
<li><strong>第二次循环 (根据反馈调整)</strong>:<ul>
<li><strong>Agent</strong> 将包括失败的<strong>观察1</strong>在内的所有历史信息传回给 <strong>LLM</strong>。</li>
<li><strong>LLM</strong> 进行<strong>思考2</strong>，分析失败原因并决定改变策略——使用更精确的英文关键词。</li>
<li>新的<strong>行动2</strong>带来了成功的<strong>观察2</strong>，找到了关键信息“北京大学”。</li>
</ul>
</li>
<li><strong>第三次循环 (解决子任务)</strong>:<ul>
<li><strong>LLM</strong> 进行<strong>思考3</strong>，它首先进行了一步<strong>推理</strong>（北京大学 -&gt; 中国），然后确定了下一个行动目标（找中国的首都）。</li>
<li><strong>行动3</strong>和<strong>观察3</strong>顺利解决了第二个子问题。</li>
</ul>
</li>
<li><strong>第四次循环 (总结与输出)</strong>:<ul>
<li><strong>LLM</strong> 进行<strong>思考4</strong>，确认所有必需信息都已集齐。</li>
<li>它不再生成新的行动，而是生成<strong>最终答案 (Final Answer)</strong>。</li>
<li><strong>Agent</strong> 将这个最终答案返回给<strong>用户</strong>。</li>
</ul>
</li>
</ol>
<p>这个流程完美地诠释了 <strong>ReAct</strong> 的核心思想：它不是一次性规划，而是一个<strong>动态、迭代</strong>的过程。每一步的观察都会成为下一步思考的依据，使得 Agent 能够处理不确定性，并从失败的尝试中学习和调整。</p>
<h3 id="hwchase17-react-介绍"><a href="#hwchase17-react-介绍" class="headerlink" title="hwchase17&#x2F;react 介绍"></a>hwchase17&#x2F;react 介绍</h3><p>“hwchase17” 是 LangChain 的创始人 Harrison Chase 的用户名，这个模板是他创建并分享到 LangChain Hub 上的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从 LangChain Hub 获取 ReAct 提示模板</span></span><br><span class="line">prompt = hub.pull(<span class="string">&quot;hwchase17/react&quot;</span>)</span><br></pre></td></tr></table></figure>

<p> 这行代码用于从 LangChain Hub 拉取一个著名且官方内置的 ReAct agent 提示词模版（prompt template），其名称为”hwchase17&#x2F;react”。这个模版为构建 ReAct 类型智能体（ReAct即Reason + Act，推理与行动协同）提供了标准的提示上下文。</p>
<ul>
<li><strong>“hwchase17&#x2F;react”</strong> 是被 LangChain 官方维护、广泛使用的一个 ReAct Agent 提示词模版。</li>
<li>其核心思想来自论文《ReAct: Synergizing Reasoning and Acting in Language Models》（<a target="_blank" rel="noopener" href="https://arxiv.org/abs/2210.03629%EF%BC%89%E3%80%82%E9%80%9A%E8%BF%87%E5%BA%8F%E5%88%97%E5%8C%96%E5%9C%B0%E8%AE%A9%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B%E2%80%9C%E6%80%9D%E8%80%83%EF%BC%88Reason%EF%BC%89%E2%86%92%E9%87%87%E5%8F%96%E8%A1%8C%E5%8A%A8%EF%BC%88Act%EF%BC%89%E2%86%92%E8%A7%82%E5%AF%9F%E7%BB%93%E6%9E%9C%E2%86%92%E7%BB%A7%E7%BB%AD%E6%80%9D%E8%80%83/%E8%A1%8C%E5%8A%A8%E2%80%9D%EF%BC%8C%E6%9C%89%E6%95%88%E6%8F%90%E5%8D%87">https://arxiv.org/abs/2210.03629）。通过序列化地让语言模型“思考（Reason）→采取行动（Act）→观察结果→继续思考/行动”，有效提升</a> LLM 在复杂多步骤推理和工具调用场景下的表现。</li>
</ul>
<p>prompt的内容结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Answer the following questions as best you can. You have access to the following tools:</span><br><span class="line"></span><br><span class="line">&#123;tools&#125;</span><br><span class="line"></span><br><span class="line">Use the following format:</span><br><span class="line"></span><br><span class="line">Question: the input question you must answer</span><br><span class="line">Thought: you should always think about what to do</span><br><span class="line">Action: the action to take, should be one of [&#123;tool_names&#125;]</span><br><span class="line">Action Input: the input to the action</span><br><span class="line">Observation: the result of the action</span><br><span class="line">... (this Thought/Action/Action Input/Observation can repeat N times)</span><br><span class="line">Thought: I now know the final answer</span><br><span class="line">Final Answer: the final answer to the original input question</span><br><span class="line"></span><br><span class="line">Begin!</span><br><span class="line"></span><br><span class="line">Question: &#123;input&#125;</span><br><span class="line">Thought:&#123;agent_scratchpad&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>其中，<code>&#123;tools&#125;</code>、<code>&#123;tool_names&#125;</code>、<code>&#123;input&#125;</code>、<code>&#123;agent_scratchpad&#125;</code> 都是在 Agent 执行阶段动态填充的变量。</li>
</ul>
<p>下面是中文翻译：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">请尽可能完整地回答以下问题。您可以使用以下工具：</span><br><span class="line"></span><br><span class="line">&#123;tools&#125;</span><br><span class="line"></span><br><span class="line">使用以下格式：</span><br><span class="line"></span><br><span class="line">问题：您必须回答的输入问题</span><br><span class="line">想法：您应该始终思考要做什么</span><br><span class="line">行动：要采取的行动，应为 [&#123;tool_names&#125;] 之一</span><br><span class="line">行动输入：行动的输入</span><br><span class="line">观察：行动的结果</span><br><span class="line">……（此想法/行动/行动输入/观察可以重复 N 次）</span><br><span class="line">想法：我现在知道最终答案了</span><br><span class="line">最终答案：原始输入问题的最终答案</span><br><span class="line"></span><br><span class="line">开始！</span><br><span class="line"></span><br><span class="line">问题：&#123;input&#125;</span><br><span class="line">想法：&#123;agent_scratchpad&#125;</span><br></pre></td></tr></table></figure>

<p><strong>工作方式：</strong></p>
<ul>
<li>Agent（智能体）每次会按照上述格式作答：先思考（Thought），然后决定是否使用某个工具（Action），填写输入（Action Input），拿到结果（Observation），再继续下一轮，直到得出最终答案（Final Answer）。</li>
<li>这种格式促使 LLM 把推理过程和行动显性化，使其对“何时用工具、如何使用”有明确指导。</li>
<li>若使用带聊天历史的提示，可切换为”hwchase17&#x2F;react-chat”等。</li>
</ul>
<p><strong>引用文献:</strong></p>
<ul>
<li><strong>原始论文:</strong> “ReAct: Synergizing Reasoning and Acting in Language Models” by Shunyu Yao, et al. (<a target="_blank" rel="noopener" href="https://arxiv.org/abs/2210.03629">https://arxiv.org/abs/2210.03629</a>)</li>
</ul>
<h2 id="2-Plan-and-Execute"><a href="#2-Plan-and-Execute" class="headerlink" title="2. Plan-and-Execute"></a><strong>2. Plan-and-Execute</strong></h2><h3 id="模式介绍-1"><a href="#模式介绍-1" class="headerlink" title="模式介绍:"></a><strong>模式介绍:</strong></h3><p>Plan-and-Execute 模式将复杂的任务分解为两个核心阶段：规划（Planning）和执行（Execution）。与ReAct模式的交错式推理和行动不同，该模式首先由一个“规划器”（Planner）LLM为整个任务制定一个详细的、分步骤的计划。然后，一个或多个“执行器”（Executor）Agent负责逐一完成计划中的每个子任务。</p>
<ol>
<li><strong>规划器 (Planner):</strong> 首先，一个通常由强大 LLM 驱动的规划器会接收用户请求，并将其分解成一个详细的、多步骤的计划。 这个计划明确了需要执行的一系列子任务。</li>
<li><strong>执行器 (Executor):</strong> 然后，一个或多个执行器（可以是另一个 Agent 或特定的工具）会按照计划逐一执行这些子任务。 执行阶段可以使用更小、更专注的模型，从而降低成本和延迟。</li>
</ol>
<p>这种模式的优势在于它能够进行更长远的规划，并且在执行过程中更加高效和稳定。</p>
<p><strong>Mermaid 图:</strong></p>
<pre class="mermaid">graph TD
    A[用户复杂问题] --> B["规划器 (LLM)"];
    B --> C{生成多步计划};
    C --> D[计划步骤 1];
    D --> E[执行器];
    E --> F[计划步骤 2];
    F --> G[执行器];
    G --> H[...];
    H --> I[整合结果并生成最终答案];</pre>

<h3 id="Python-代码案例-LangChain-1"><a href="#Python-代码案例-LangChain-1" class="headerlink" title="Python 代码案例 (LangChain):"></a><strong>Python 代码案例 (LangChain):</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> dotenv <span class="keyword">import</span> load_dotenv</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> langchain_openai <span class="keyword">import</span> ChatOpenAI</span><br><span class="line"><span class="keyword">from</span> langchain.chains <span class="keyword">import</span> LLMMathChain</span><br><span class="line"><span class="keyword">from</span> langchain.tools <span class="keyword">import</span> Tool</span><br><span class="line"><span class="keyword">from</span> langchain_experimental.plan_and_execute <span class="keyword">import</span> PlanAndExecute, load_agent_executor, load_chat_planner</span><br><span class="line"><span class="keyword">from</span> langchain_community.tools <span class="keyword">import</span> DuckDuckGoSearchRun</span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 配置区 ---</span></span><br><span class="line">load_dotenv()</span><br><span class="line"></span><br><span class="line">QUESTION = <span class="string">&quot;求中国北京、上海、广州、深圳的人口总和&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 主程序 ---</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># 1. 定义语言模型</span></span><br><span class="line">    planner_llm = ChatOpenAI(model=<span class="string">&quot;gpt-4.1&quot;</span>, temperature=<span class="number">0</span>)</span><br><span class="line">    executor_llm = ChatOpenAI(model=<span class="string">&quot;gpt-4.1&quot;</span>, temperature=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2. 定义执行器要使用的工具 (搜索 + 计算器)</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">LoggingDuckDuckGoSearchRun</span>(<span class="title class_ inherited__">DuckDuckGoSearchRun</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        一个自定义的DuckDuckGoSearchRun版本，它会清晰地打印输入和输出。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">_run</span>(<span class="params">self, query: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">            <span class="string">&quot;&quot;&quot;重写_run方法以添加日志记录。&quot;&quot;&quot;</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span> + <span class="string">&quot;=&quot;</span> * <span class="number">30</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;🔎 [DuckDuckGo] 正在搜索: <span class="subst">&#123;query&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;=&quot;</span> * <span class="number">30</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 调用父类的原始_run方法来执行实际的搜索</span></span><br><span class="line">            result = <span class="built_in">super</span>()._run(query)</span><br><span class="line"></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span> + <span class="string">&quot;-&quot;</span> * <span class="number">30</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;📄 [DuckDuckGo] 收到结果:&quot;</span>)</span><br><span class="line">            <span class="comment"># 为了可读性，可以只打印结果的一部分</span></span><br><span class="line">            <span class="built_in">print</span>(result[:<span class="number">500</span>] + <span class="string">&quot;...&quot;</span> <span class="keyword">if</span> <span class="built_in">len</span>(result) &gt; <span class="number">500</span> <span class="keyword">else</span> result)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;-&quot;</span> * <span class="number">30</span> + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    search = LoggingDuckDuckGoSearchRun()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建一个由 LLM 驱动的数学计算链</span></span><br><span class="line">    llm_math_chain = LLMMathChain.from_llm(llm=executor_llm, verbose=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    tools = [</span><br><span class="line">        Tool(</span><br><span class="line">            name=<span class="string">&quot;Search&quot;</span>,</span><br><span class="line">            func=search.run,</span><br><span class="line">            description=<span class="string">&quot;当你需要回答关于时事、事实和数据的问题时非常有用。用于查找信息。&quot;</span>,</span><br><span class="line">        ),</span><br><span class="line">        Tool(</span><br><span class="line">            name=<span class="string">&quot;Calculator&quot;</span>,</span><br><span class="line">            func=llm_math_chain.run,</span><br><span class="line">            description=<span class="string">&quot;当你需要进行数学计算或回答关于数学的问题时非常有用。输入应该是一个完整的数学表达式。&quot;</span>,</span><br><span class="line">        )</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3. 创建计划器 (Planner) 和执行器 (Executor)</span></span><br><span class="line">    planner = load_chat_planner(planner_llm)</span><br><span class="line">    <span class="comment"># 将包含两个工具的列表传递给执行器</span></span><br><span class="line">    executor = load_agent_executor(executor_llm, tools, verbose=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 4. 组装 Plan-and-Execute 智能体</span></span><br><span class="line">    agent = PlanAndExecute(planner=planner, executor=executor, verbose=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># --- 打印输入 ---</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;--- 用户输入 ---&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;问题: <span class="subst">&#123;QUESTION&#125;</span>\n&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;--- Agent 开始执行 (详细过程如下) ---&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 5. 运行智能体</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        result = agent.invoke(&#123;<span class="string">&quot;input&quot;</span>: QUESTION&#125;)</span><br><span class="line">        final_answer = result.get(<span class="string">&#x27;output&#x27;</span>, <span class="string">&#x27;未能获取最终答案。&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># --- 打印最终输出 ---</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;\n--- Agent 执行完毕 ---&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;\n[问题]: <span class="subst">&#123;QUESTION&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;[最终答案]: <span class="subst">&#123;final_answer&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;\n--- 发生错误 ---&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;在 Agent 执行过程中出现错误: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="输出："><a href="#输出：" class="headerlink" title="输出："></a><strong>输出：</strong></h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line">--- 用户输入 ---</span><br><span class="line">问题: 求中国北京、上海、广州、深圳的人口总和</span><br><span class="line"></span><br><span class="line">--- Agent 开始执行 (详细过程如下) ---</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt; Entering new PlanAndExecute chain...</span><br><span class="line">steps=[Step(value=<span class="string">&#x27;查找中国北京、上海、广州、深圳四个城市的最新人口数据（以2023年或最近官方公布数据为准）。&#x27;</span>), Step(value=<span class="string">&#x27;将四个城市的人口数据相加，计算总和。&#x27;</span>), Step(value=<span class="string">&#x27;给出四个城市人口总和的答案。&#x27;</span>), Step(value=<span class="string">&quot;Given the above steps taken, please respond to the user&#x27;s original question.&quot;</span>)]</span><br><span class="line"></span><br><span class="line">&gt; Entering new AgentExecutor chain...</span><br><span class="line">Action:</span><br><span class="line">```</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;action&quot;</span>: <span class="string">&quot;Search&quot;</span>,</span><br><span class="line">  <span class="string">&quot;action_input&quot;</span>: <span class="string">&quot;中国北京、上海、广州、深圳2023年或最近官方公布人口数据&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">```</span><br><span class="line">==============================</span><br><span class="line">🔎 [DuckDuckGo] 正在搜索: 中国北京、上海、广州、深圳2023年或最近官方公布人口数据</span><br><span class="line">==============================</span><br><span class="line"></span><br><span class="line">------------------------------</span><br><span class="line">📄 [DuckDuckGo] 收到结果:</span><br><span class="line">Apr 29, 2024 · 此前， 北京 、 上海 、 广州 陆续披露了 20 23 年底常住人口 数据 ，三者分别增长1.5万人、11.56万人、9.29万人。 常住人口数“重回正轨” Mar 9, 2024 · 开一个系列，记录每个城市的 常住人口 变化， 数据 的主要来源是各省、城市的 人口 相关报告、统计公报、政府官网和统计年鉴以及一些相关 数据 的推算。 Apr 29, 2024 · 根据四座一线城市公布的 20 23 年 常住人口数据， 上海 、 北京 、 广州 、 深圳 20 23 年常住人口分别为2487.45万人、2185.8万人、1882.7万人、1779.01万人，增量分别为11.56万人、1.5万人、9.29万人、12.83万人。 Mar 26, 2024 · 目前有17个重点城市公布了 20 23 年 人口 数据 ，合肥增量暂时位居第一，且是目前唯一一个增量超过20万的城市，杭州、成都、 上海 位居前四，增量都在10万以上。 Apr 29, 2024 · 公报显示， 20 23 年末，深圳市常住人口为1779.01万人，创历史新高；比上年末增加12.83万人...</span><br><span class="line">------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Observation: Apr 29, 2024 · 此前， 北京 、 上海 、 广州 陆续披露了 20 23 年底常住人口 数据 ，三者分别增长1.5万人、11.56万人、9.29万人。 常住人口数“重回正轨” Mar 9, 2024 · 开一个系列，记录每个城市的 常住人口 变化， 数据 的主要来源是各省、城市的 人口 相关报告、统计公报、政府官网和统计年鉴以及一些相关 数据 的推算。 Apr 29, 2024 · 根据四座一线城市公布的 20 23 年 常住人口数据， 上海 、 北京 、 广州 、 深圳 20 23 年常住人口分别为2487.45万人、2185.8万人、1882.7万人、1779.01万人，增量分别为11.56万人、1.5万人、9.29万人、12.83万人。 Mar 26, 2024 · 目前有17个重点城市公布了 20 23 年 人口 数据 ，合肥增量暂时位居第一，且是目前唯一一个增量超过20万的城市，杭州、成都、 上海 位居前四，增量都在10万以上。 Apr 29, 2024 · 公报显示， 20 23 年末，深圳市常住人口为1779.01万人，创历史新高；比上年末增加12.83万人，同比增长0.73%，增量位居北上广深之首。</span><br><span class="line">Thought:Action:</span><br><span class="line">```</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;action&quot;</span>: <span class="string">&quot;Final Answer&quot;</span>,</span><br><span class="line">  <span class="string">&quot;action_input&quot;</span>: <span class="string">&quot;根据2023年或最近官方公布的数据，四个城市的常住人口如下：\n\n- 北京：2185.8万人\n- 上海：2487.45万人\n- 广州：1882.7万人\n- 深圳：1779.01万人\n\n数据来源于各城市2023年末官方统计公报。&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">&gt; Finished chain.</span><br><span class="line">*****</span><br><span class="line"></span><br><span class="line">Step: 查找中国北京、上海、广州、深圳四个城市的最新人口数据（以2023年或最近官方公布数据为准）。</span><br><span class="line"></span><br><span class="line">Response: 根据2023年或最近官方公布的数据，四个城市的常住人口如下：</span><br><span class="line"></span><br><span class="line">- 北京：2185.8万人</span><br><span class="line">- 上海：2487.45万人</span><br><span class="line">- 广州：1882.7万人</span><br><span class="line">- 深圳：1779.01万人</span><br><span class="line"></span><br><span class="line">数据来源于各城市2023年末官方统计公报。</span><br><span class="line"></span><br><span class="line">&gt; Entering new AgentExecutor chain...</span><br><span class="line">Action:</span><br><span class="line">```</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;action&quot;</span>: <span class="string">&quot;Calculator&quot;</span>,</span><br><span class="line">  <span class="string">&quot;action_input&quot;</span>: <span class="string">&quot;2185.8 + 2487.45 + 1882.7 + 1779.01&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">&gt; Entering new LLMMathChain chain...</span><br><span class="line">2185.8 + 2487.45 + 1882.7 + 1779.01```text</span><br><span class="line">2185.8 + 2487.45 + 1882.7 + 1779.01</span><br><span class="line">```</span><br><span class="line">...numexpr.evaluate(<span class="string">&quot;2185.8 + 2487.45 + 1882.7 + 1779.01&quot;</span>)...</span><br><span class="line">Answer: 8334.96</span><br><span class="line">&gt; Finished chain.</span><br><span class="line"></span><br><span class="line">Observation: Answer: 8334.96</span><br><span class="line">Thought:&#123;</span><br><span class="line">  <span class="string">&quot;action&quot;</span>: <span class="string">&quot;Final Answer&quot;</span>,</span><br><span class="line">  <span class="string">&quot;action_input&quot;</span>: <span class="string">&quot;北京、上海、广州、深圳四个城市的常住人口总和为8334.96万人。&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt; Finished chain.</span><br><span class="line">*****</span><br><span class="line"></span><br><span class="line">Step: 将四个城市的人口数据相加，计算总和。</span><br><span class="line"></span><br><span class="line">Response: &#123;</span><br><span class="line">  <span class="string">&quot;action&quot;</span>: <span class="string">&quot;Final Answer&quot;</span>,</span><br><span class="line">  <span class="string">&quot;action_input&quot;</span>: <span class="string">&quot;北京、上海、广州、深圳四个城市的常住人口总和为8334.96万人。&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt; Entering new AgentExecutor chain...</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;action&quot;</span>: <span class="string">&quot;Final Answer&quot;</span>,</span><br><span class="line">  <span class="string">&quot;action_input&quot;</span>: <span class="string">&quot;北京、上海、广州、深圳四个城市的常住人口总和为8334.96万人。&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt; Finished chain.</span><br><span class="line">*****</span><br><span class="line"></span><br><span class="line">Step: 给出四个城市人口总和的答案。</span><br><span class="line"></span><br><span class="line">Response: &#123;</span><br><span class="line">  <span class="string">&quot;action&quot;</span>: <span class="string">&quot;Final Answer&quot;</span>,</span><br><span class="line">  <span class="string">&quot;action_input&quot;</span>: <span class="string">&quot;北京、上海、广州、深圳四个城市的常住人口总和为8334.96万人。&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt; Entering new AgentExecutor chain...</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;action&quot;</span>: <span class="string">&quot;Final Answer&quot;</span>,</span><br><span class="line">  <span class="string">&quot;action_input&quot;</span>: <span class="string">&quot;根据2023年或最近官方公布的数据，北京、上海、广州、深圳四个城市的常住人口总和为8334.96万人。&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt; Finished chain.</span><br><span class="line">*****</span><br><span class="line"></span><br><span class="line">Step: Given the above steps taken, please respond to the user<span class="string">&#x27;s original question.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Response: &#123;</span></span><br><span class="line"><span class="string">  &quot;action&quot;: &quot;Final Answer&quot;,</span></span><br><span class="line"><span class="string">  &quot;action_input&quot;: &quot;根据2023年或最近官方公布的数据，北京、上海、广州、深圳四个城市的常住人口总和为8334.96万人。&quot;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&gt; Finished chain.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">--- Agent 执行完毕 ---</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[问题]: 求中国北京、上海、广州、深圳的人口总和</span></span><br><span class="line"><span class="string">[最终答案]: &#123;</span></span><br><span class="line"><span class="string">  &quot;action&quot;: &quot;Final Answer&quot;,</span></span><br><span class="line"><span class="string">  &quot;action_input&quot;: &quot;根据2023年或最近官方公布的数据，北京、上海、广州、深圳四个城市的常住人口总和为8334.96万人。&quot;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="代码整体流程：-1"><a href="#代码整体流程：-1" class="headerlink" title="代码整体流程："></a><strong>代码整体流程：</strong></h3><pre class="mermaid">sequenceDiagram
    participant User as 用户
    participant App as 主程序
    participant Controller as PlanAndExecute控制器
    participant Planner as 计划器 (GPT-4.1)
    participant Executor as 执行器 (Agent)
    participant SearchTool as 自定义搜索工具
    participant CalculatorTool as 计算器工具

    User->>App: 提问: "求中国京沪广深的人口总和"
    App->>Controller: agent.invoke({"input": QUESTION})

    rect rgb(230, 240, 255)
    note over Controller, Planner: --- 1. 计划阶段 ---
    Controller->>Planner: 请求为问题制定计划
    Planner-->>Controller: 返回计划 (Plan: 4个步骤)
    end

    rect rgb(255, 245, 230)
    note over Controller, CalculatorTool: --- 2. 执行阶段 (按步骤进行) ---
    
    %% Step 1: 查找人口数据
    Controller->>Executor: 执行步骤1: "查找四个城市的最新人口数据"
    note over Executor: 识别出需要查找信息
    Executor->>SearchTool: 调用 Search("中国北京、上海、广州、深圳...人口数据")
    note right of SearchTool: 自定义工具打印搜索日志
    SearchTool-->>Executor: 返回包含人口数据的文本 (Observation)
    note right of Executor: 从文本中成功提取出4个城市的人口数
    Executor-->>Controller: 返回步骤1的结果 (包含具体人口数的列表)

    %% Step 2: 计算总和
    Controller->>Executor: 执行步骤2: "将四个城市的人口数据相加"
    note left of Executor: 利用上一步提取的数据构建数学表达式
    Executor->>CalculatorTool: 调用 Calculator("2185.8 + 2487.45 + 1882.7 + 1779.01")
    note right of CalculatorTool: LLMMathChain 打印详细计算过程
    CalculatorTool-->>Executor: 返回计算结果 (Answer: 8334.96)
    Executor-->>Controller: 返回步骤2的结果: "总和为8334.96万人"
    
    %% Step 3 & 4: 总结并最终回答
    Controller->>Executor: 执行步骤3&4: "给出总和的答案"
    note over Executor: 已有全部信息, 无需再调用工具, 直接整合
    Executor-->>Controller: 返回最终格式化的回答

    end

    Controller-->>App: 返回最后一个步骤的最终结果
    App->>User: 打印格式化的最终答案</pre>

<p>这张图揭示了 Plan-and-Execute 模式的几个关键特点：</p>
<ol>
<li><strong>启动与计划</strong>：<ul>
<li>流程由 <strong>用户</strong> 发起，<strong>主程序</strong> 调用 PlanAndExecute <strong>控制器</strong>。</li>
<li><strong>控制器</strong> 首先将任务委托给 <strong>计划器</strong>。根据您的输出，<strong>计划器</strong> 制定了一个非常清晰的四步计划：1. 查找数据 -&gt; 2. 计算 -&gt; 3. 给出答案 -&gt; 4. 最终响应。</li>
</ul>
</li>
<li><strong>执行步骤 1: 查找数据</strong><ul>
<li><strong>控制器</strong> 将计划的<strong>第一步</strong>（“查找…人口数据”）交给 <strong>执行器</strong>。</li>
<li><strong>执行器</strong> 分析任务后，判断需要使用<strong>搜索工具</strong>。它构建了一个精确的搜索查询，并调用了您的自定义搜索工具。</li>
<li><strong>搜索工具</strong> 执行搜索并返回一大段文本（Observation）。</li>
<li><strong>执行器</strong> 接着发挥其强大的语言理解能力，从返回的非结构化文本中准确地<strong>提取</strong>出了四个城市的人口数字，并完成了第一步的任务。</li>
</ul>
</li>
<li><strong>执行步骤 2: 计算总和</strong><ul>
<li><strong>控制器</strong> 将计划的<strong>第二步</strong>（“将…数据相加”）以及上一步的上下文（提取出的数字）交给 <strong>执行器</strong>。</li>
<li><strong>执行器</strong> 分析任务后，判断出需要进行数学运算，于是选择了<strong>计算器工具</strong>。它将提取出的数字构建成一个数学表达式 “2185.8 + 2487.45 + …”。</li>
<li><strong>计算器工具</strong> (LLMMathChain) 接收到表达式，执行计算，并返回了精确的结果 8334.96。</li>
</ul>
</li>
<li><strong>执行步骤 3 &amp; 4: 总结</strong><ul>
<li>对于后续的总结步骤，<strong>执行器</strong> 已经拥有了所有必要的信息（城市列表、各自人口、总和），因此它<strong>不再需要调用任何工具</strong>。它只是将已有信息整合成通顺的、符合要求的最终答案。</li>
</ul>
</li>
<li><strong>最终输出</strong>：<ul>
<li><strong>控制器</strong> 收集了最后一个步骤的输出，并将其作为最终结果返回给 <strong>主程序</strong>，最终呈现给 <strong>用户</strong>。</li>
</ul>
</li>
</ol>
<p>这个案例完美地展示了 Plan-and-Execute 模式如何协调一个<strong>信息检索工具</strong>和一个<strong>逻辑计算工具</strong>，分步、清晰地解决一个需要多重能力才能完成的复杂问题。</p>
<p><strong>引用文献:</strong></p>
<ul>
<li><strong>相关论文:</strong> “Plan-and-Solve Prompting: Improving Zero-Shot Chain-of-Thought Reasoning in Large Language Models” by Lei Wang, et al. (<a target="_blank" rel="noopener" href="https://arxiv.org/abs/2305.04091">https://arxiv.org/abs/2305.04091</a>)</li>
</ul>
<h2 id="3-Chain-of-Though"><a href="#3-Chain-of-Though" class="headerlink" title="3. Chain-of-Though"></a>3. Chain-of-Though</h2><h3 id="模式介绍-2"><a href="#模式介绍-2" class="headerlink" title="模式介绍:"></a><strong>模式介绍:</strong></h3><p>思维链（Chain-of-Thought, CoT）是一种提示工程技术，旨在提升大型语言模型在处理需要多步推理的复杂任务时的表现。 传统上，直接向模型提问可能会得到一个看似正确但缺乏推理过程的答案。CoT 通过在提示中加入一系列中间推理步骤，引导模型模仿人类的思维过程，将复杂问题分解为更小、更易于管理的部分，从而逐步得出最终结论。这种方法不仅提高了答案的准确性，也使得模型的推理过程更加透明和可解释。<br>CoT 主要有两种形式：</p>
<ul>
<li>Zero-shot CoT: 在提问的最后简单地加上一句“让我们一步一步地思考”（Let’s think step by step），就能显著提升模型的推理能力。</li>
<li>Few-shot CoT: 在提示中提供一到两个包含问题、推理步骤和答案的完整示例，让模型在回答新问题时能够更好地模仿这种推理模式。</li>
</ul>
<p><strong>Mermaid 图:</strong></p>
<pre class="mermaid">graph TD
    A[用户问题] --> B{LLM 接收问题};
    B --> C["生成中间推理步骤 (思维链)"];
    C --> D["基于推理步骤生成最终答案"];
    D --> E[输出答案];</pre>

<h3 id="Python-代码案例-LangChain-2"><a href="#Python-代码案例-LangChain-2" class="headerlink" title="Python 代码案例 (LangChain):"></a><strong>Python 代码案例 (LangChain):</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> dotenv <span class="keyword">import</span> load_dotenv</span><br><span class="line"><span class="keyword">from</span> langchain_openai <span class="keyword">import</span> ChatOpenAI</span><br><span class="line"><span class="keyword">from</span> langchain_core.prompts <span class="keyword">import</span> PromptTemplate</span><br><span class="line"><span class="keyword">from</span> langchain_core.output_parsers <span class="keyword">import</span> StrOutputParser</span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 配置区 ---</span></span><br><span class="line">load_dotenv()</span><br><span class="line"></span><br><span class="line">llm = ChatOpenAI(model=<span class="string">&quot;gpt-4.1&quot;</span>, temperature=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">prompt = PromptTemplate(</span><br><span class="line">    input_variables=[<span class="string">&quot;question&quot;</span>],</span><br><span class="line">    template=<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    问题: &#123;question&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    回答: 让我们一步一步地思考。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用LCEL（LangChain Expression Language）构建链</span></span><br><span class="line"><span class="comment"># 管道符 | 将提示、模型和输出解析器连接起来</span></span><br><span class="line">chain = prompt | llm | StrOutputParser()</span><br><span class="line"></span><br><span class="line">question = <span class="string">&quot;如果一个篮子里有5个苹果，你拿走了2个，然后又放回了1个，篮子里现在有多少个苹果？&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用链</span></span><br><span class="line">response = chain.invoke(&#123;<span class="string">&quot;question&quot;</span>: question&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(response)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="输出：-1"><a href="#输出：-1" class="headerlink" title="输出："></a><strong>输出：</strong></h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">好的，我们来一步一步分析这个问题：</span><br><span class="line"></span><br><span class="line">1. 篮子里最开始有 5 个苹果。  </span><br><span class="line">2. 你拿走了 2 个苹果，篮子里还剩下 5-2=3 个苹果。</span><br><span class="line">3. 然后你又把 1 个苹果放回篮子里，篮子里就变成 3+1=4 个苹果。</span><br><span class="line"></span><br><span class="line">**所以，篮子里现在有 4 个苹果。**</span><br></pre></td></tr></table></figure>

<p><strong>代码整体流程：</strong></p>
<pre class="mermaid">sequenceDiagram
    participant Script as 用户脚本
    participant Chain as LangChain链
    participant LLM as OpenAI LLM

    Script->>Chain: invoke("苹果问题...")

    activate Chain
    Note over Chain: 1. 将问题注入Prompt<br/>形成："问题: ... 回答: 让我们一步一步地思考。"
    Chain->>LLM: 2. 发送包含CoT指令的完整Prompt
    deactivate Chain

    activate LLM
    Note over LLM: 3. 遵从指令，执行“思维链”<br/>- 初始状态: 5个苹果<br/>- 步骤1: 5 - 2 = 3<br/>- 步骤2: 3 + 1 = 4<br/>- 整合答案
    LLM-->>Chain: 4. 返回包含【完整推理过程和答案】的文本
    deactivate LLM

    activate Chain
    Chain-->>Script: 5. 将LLM生成的文本作为结果返回
    deactivate Chain

    Script->>Script: 6. 打印完整的推理过程和答案</pre>

<h3 id="代码整体流程：-2"><a href="#代码整体流程：-2" class="headerlink" title="代码整体流程："></a><strong>代码整体流程：</strong></h3><ol>
<li><strong>注入指令</strong>: LangChain链首先将你的问题和固定的思维链指令 “让我们一步一步地思考。” 组合成一个完整的Prompt。</li>
<li><strong>触发LLM</strong>: 这个包含了明确指令的Prompt被发送给OpenAI LLM。</li>
<li><strong>执行思维链</strong>: LLM识别到这个指令后，不会直接计算结果，而是模拟人类的思考方式，生成从初始状态到每一步计算，最后得出结论的完整文本。</li>
<li><strong>返回完整思考过程</strong>: LLM将整个“思考过程”的文本一次性返回。这就是为什么你的输出包含了所有步骤，而不仅仅是数字“4”。</li>
</ol>
<p><strong>引用文献:</strong></p>
<ul>
<li><strong>原始论文:</strong> “Chain-of-Thought Prompting Elicits Reasoning in Large Language Models” by Jason Wei, et al. (<a target="_blank" rel="noopener" href="https://arxiv.org/abs/2201.11903">https://arxiv.org/abs/2201.11903</a>)</li>
</ul>
<h2 id="4-Self-Ask"><a href="#4-Self-Ask" class="headerlink" title="4. Self-Ask"></a>4. Self-Ask</h2><h3 id="模式介绍-3"><a href="#模式介绍-3" class="headerlink" title="模式介绍:"></a><strong>模式介绍:</strong></h3><p>Self-Ask 是一种建立在思维链之上的推理模式，它通过引导模型自我提问和回答中间问题来解决更复杂的问题。当模型遇到一个直接无法回答的问题时，Self-Ask 模式会促使模型将问题分解为一系列后续问题，并利用外部工具（如搜索引擎）来寻找这些子问题的答案。这种方法明确地展示了模型的推理过程，并通过将复杂问题分解为可以独立验证的简单问题，提高了最终答案的可靠性。</p>
<pre class="mermaid">graph TD
    A[初始问题] --> B{LLM: 我需要知道什么才能回答这个问题?};
    B --> C["生成后续问题"];
    C --> D{"使用工具 (如搜索) 回答后续问题"};
    D --> E["获得中间答案"];
    E --> B;
    B -- 所有子问题都已回答 --> F["整合所有中间答案"];
    F --> G[生成最终答案];</pre>

<h3 id="Python代码案例-LangChain"><a href="#Python代码案例-LangChain" class="headerlink" title="Python代码案例 (LangChain):"></a><strong>Python代码案例 (LangChain):</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> dotenv <span class="keyword">import</span> load_dotenv</span><br><span class="line"><span class="keyword">from</span> langchain_openai <span class="keyword">import</span> ChatOpenAI</span><br><span class="line"><span class="keyword">from</span> langchain.agents <span class="keyword">import</span> initialize_agent, AgentType</span><br><span class="line"><span class="keyword">from</span> langchain.tools <span class="keyword">import</span> Tool</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Dict</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 1. 环境与模型设置 ---</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">setup_environment</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;加载环境变量并初始化LLM。&quot;&quot;&quot;</span></span><br><span class="line">    load_dotenv()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.getenv(<span class="string">&quot;OPENAI_API_KEY&quot;</span>):</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&quot;请在 .env 文件中设置 OPENAI_API_KEY&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 为了演示，我们可以使用任何支持的聊天模型</span></span><br><span class="line">    llm = ChatOpenAI(model=<span class="string">&quot;gpt-4.1&quot;</span>, temperature=<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> llm</span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 2. 核心部分: 创建一个模拟的搜索工具 ---</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MockSearchTool</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    一个模拟的搜索工具类。</span></span><br><span class="line"><span class="string">    它不进行任何真实的网络搜索，而是从一个预设的答案库中返回结果。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, answers: <span class="type">Dict</span>[<span class="built_in">str</span>, <span class="built_in">str</span>]</span>):</span><br><span class="line">        <span class="variable language_">self</span>.answers = answers</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self, query: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        模拟运行搜索。</span></span><br><span class="line"><span class="string">        接收一个查询，并从答案库中查找答案。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;\n--- [Mock Tool] 接收到查询: &#x27;<span class="subst">&#123;query&#125;</span>&#x27; ---&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 为了模拟真实情况，我们进行模糊匹配</span></span><br><span class="line">        <span class="keyword">for</span> key, value <span class="keyword">in</span> <span class="variable language_">self</span>.answers.items():</span><br><span class="line">            <span class="keyword">if</span> key <span class="keyword">in</span> query:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;--- [Mock Tool] 在知识库中找到答案: &#x27;<span class="subst">&#123;value&#125;</span>&#x27; ---\n&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span> value</span><br><span class="line"></span><br><span class="line">        default_answer = <span class="string">&quot;在模拟知识库中未找到相关信息。&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;--- [Mock Tool] 未找到答案，返回默认值: &#x27;<span class="subst">&#123;default_answer&#125;</span>&#x27; ---\n&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> default_answer</span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 3. 主执行逻辑 ---</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;构建并运行 Self-Ask 代理。&quot;&quot;&quot;</span></span><br><span class="line">    llm = setup_environment()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 1. 定义我们的模拟知识库</span></span><br><span class="line">    knowledge_base = &#123;</span><br><span class="line">        <span class="string">&quot;《沙丘》的作者&quot;</span>: <span class="string">&quot;弗兰克·赫伯特&quot;</span>,</span><br><span class="line">        <span class="string">&quot;弗兰克·赫伯特出生于&quot;</span>: <span class="string">&quot;1920年&quot;</span>,</span><br><span class="line">        <span class="string">&quot;美国第一位总统&quot;</span>: <span class="string">&quot;乔治·华盛顿&quot;</span>,</span><br><span class="line">        <span class="string">&quot;乔治·华盛顿的妻子&quot;</span>: <span class="string">&quot;玛莎·华盛顿&quot;</span>,</span><br><span class="line">        <span class="string">&quot;美国第十六位总统&quot;</span>: <span class="string">&quot;亚伯拉罕·林肯&quot;</span>,</span><br><span class="line">        <span class="string">&quot;亚伯拉罕·林肯的妻子&quot;</span>: <span class="string">&quot;玛丽·托德·林肯&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2. 实例化我们的模拟工具</span></span><br><span class="line">    mock_search = MockSearchTool(answers=knowledge_base)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3. 将模拟工具包装成 Agent 能调用的 Tool</span></span><br><span class="line">    <span class="comment">#    注意：func 指向的是 mock_search 实例的 .run 方法</span></span><br><span class="line">    search_tool = Tool(</span><br><span class="line">        name=<span class="string">&quot;Intermediate Answer&quot;</span>,</span><br><span class="line">        func=mock_search.run,</span><br><span class="line">        description=<span class="string">&quot;用于当你需要回答关于事实、日期、人物等问题时。输入应该是一个搜索查询。&quot;</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    tools = [search_tool]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 4. 使用 initialize_agent 构建代理</span></span><br><span class="line">    agent_executor = initialize_agent(</span><br><span class="line">        tools,</span><br><span class="line">        llm,</span><br><span class="line">        agent=AgentType.SELF_ASK_WITH_SEARCH,</span><br><span class="line">        verbose=<span class="literal">True</span>, <span class="comment"># verbose=True 可以让我们清晰地看到 Agent 的思考过程</span></span><br><span class="line">        handle_parsing_errors=<span class="literal">True</span>,</span><br><span class="line">        max_iterations=<span class="number">5</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 5. 定义问题并启动代理</span></span><br><span class="line">    question = <span class="string">&quot;谁是《沙丘》的作者？他的出生年份是多少？&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;🚀 开始执行 Self-Ask 代理 (使用 Mock 工具)...&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;❓ 用户问题: <span class="subst">&#123;question&#125;</span>\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">    response = agent_executor.invoke(&#123;<span class="string">&quot;input&quot;</span>: question&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span> + <span class="string">&quot;=&quot;</span> * <span class="number">20</span> + <span class="string">&quot; ✅ 最终答案 &quot;</span> + <span class="string">&quot;=&quot;</span> * <span class="number">20</span>)</span><br><span class="line">    <span class="built_in">print</span>(response[<span class="string">&quot;output&quot;</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;=&quot;</span> * <span class="number">55</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<h3 id="输出：-2"><a href="#输出：-2" class="headerlink" title="输出："></a><strong>输出：</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">🚀 开始执行 Self-Ask 代理 (使用 Mock 工具)...</span><br><span class="line">❓ 用户问题: 谁是《沙丘》的作者？他的出生年份是多少？</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt; Entering new AgentExecutor chain...</span><br><span class="line">Yes, follow up questions are needed.</span><br><span class="line"></span><br><span class="line">Follow up: 《沙丘》的作者是谁？</span><br><span class="line">--- [Mock Tool] 接收到查询: &#x27;《沙丘》的作者是谁？&#x27; ---</span><br><span class="line">--- [Mock Tool] 在知识库中找到答案: &#x27;弗兰克·赫伯特&#x27; ---</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Intermediate answer: 弗兰克·赫伯特</span><br><span class="line">Follow up: 弗兰克·赫伯特出生于哪一年？</span><br><span class="line">--- [Mock Tool] 接收到查询: &#x27;弗兰克·赫伯特出生于哪一年？&#x27; ---</span><br><span class="line">--- [Mock Tool] 在知识库中找到答案: &#x27;1920年&#x27; ---</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Intermediate answer: 1920年</span><br><span class="line">So the final answer is: 弗兰克·赫伯特，1920年</span><br><span class="line"></span><br><span class="line">&gt; Finished chain.</span><br><span class="line"></span><br><span class="line">==================== ✅ 最终答案 ====================</span><br><span class="line">弗兰克·赫伯特，1920年</span><br><span class="line">=======================================================</span><br></pre></td></tr></table></figure>

<h3 id="代码整体流程：-3"><a href="#代码整体流程：-3" class="headerlink" title="代码整体流程："></a><strong>代码整体流程：</strong></h3><pre class="mermaid">sequenceDiagram
    participant User as "用户"
    participant PythonScript as "Python 脚本 (main)"
    participant AgentExecutor as "Self-Ask Agent"
    participant LLM as "LLM (gpt-4.1)"
    participant MockSearchTool as "模拟搜索工具"

    %% --- 1. 初始化阶段 ---
    PythonScript->>PythonScript: 设置环境, 初始化LLM
    PythonScript->>MockSearchTool: 创建实例 (传入知识库)
    PythonScript->>AgentExecutor: 初始化代理 (传入LLM和工具)
    
    %% --- 2. 任务执行阶段 ---
    User->>PythonScript: 运行脚本
    PythonScript->>AgentExecutor: invoke(input="谁是《沙丘》的作者？...")
    activate AgentExecutor

    %% --- 循环 1: 寻找作者 ---
    AgentExecutor->>LLM: [初始问题] 我需要知道什么才能回答？
    activate LLM
    LLM-->>AgentExecutor: Thought: 需要跟进问题。<br>Follow up: 《沙丘》的作者是谁？
    deactivate LLM

    Note over AgentExecutor: 解析出动作：调用工具
    AgentExecutor->>MockSearchTool: run(query="《沙丘》的作者是谁？")
    activate MockSearchTool
    Note right of MockSearchTool: 在知识库中查找 "《沙丘》的作者"
    MockSearchTool-->>AgentExecutor: return "弗兰克·赫伯特"
    deactivate MockSearchTool

    %% --- 循环 2: 寻找出生年份 ---
    AgentExecutor->>LLM: [上下文]<br>问题: ...<br>中间答案: 弗兰克·赫伯特<br>下一步是什么？
    activate LLM
    LLM-->>AgentExecutor: Thought: 还需要一个信息。<br>Follow up: 弗兰克·赫伯特出生于哪一年？
    deactivate LLM

    Note over AgentExecutor: 解析出新动作：再次调用工具
    AgentExecutor->>MockSearchTool: run(query="弗兰克·赫伯特出生于哪一年？")
    activate MockSearchTool
    Note right of MockSearchTool: 在知识库中查找 "弗兰克·赫伯特出生于"
    MockSearchTool-->>AgentExecutor: return "1920年"
    deactivate MockSearchTool

    %% --- 3. 最终整合阶段 ---
    AgentExecutor->>LLM: [完整上下文]<br>问题: ...<br>中间答案1: 弗兰克·赫伯特<br>中间答案2: 1920年<br>现在可以回答了吗？
    activate LLM
    LLM-->>AgentExecutor: So the final answer is: 弗兰克·赫伯特，1920年
    deactivate LLM

    Note over AgentExecutor: 解析出最终答案，结束循环
    AgentExecutor-->>PythonScript: return {"output": "弗兰克·赫伯特，1920年"}
    deactivate AgentExecutor

    PythonScript->>User: 打印最终答案到控制台</pre>



<p><strong>引用文献</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.google.com/url?sa=E&q=https://arxiv.org/abs/2210.03350">Press, O., Zhang, M., Min, S., Schmidt, L., Smith, N. A., &amp; Lewis, M. (2022). Measuring and Narrowing the Compositionality Gap in Language Models.</a></li>
</ul>
<h2 id="5-Reflexion-反思"><a href="#5-Reflexion-反思" class="headerlink" title="5. Reflexion (反思)"></a>5. Reflexion (反思)</h2><h3 id="模式介绍-4"><a href="#模式介绍-4" class="headerlink" title="模式介绍:"></a><strong>模式介绍:</strong></h3><p>Reflexion是一种通过语言反馈来强化智能体的框架。它使智能体能够对其过去的行动和结果进行“反思”，从中吸取教训，并将这些反思存储在记忆中，以便在未来的尝试中做出更好的决策。这个过程通常包括三个主要部分：一个执行任务的“行动者”（Actor），一个评估行动者输出的“评估者”（Evaluator），以及一个根据评估结果生成反思文本的“反思者”（Self-Reflection）。通过这种自我批判和改进的循环，智能体可以从错误中学习，而无需进行昂贵的模型权重更新</p>
<p><strong>Mermaid流程图:</strong></p>
<pre class="mermaid">graph TD
    A[开始任务] --> B(行动者: 尝试解决任务);
    B --> C{评估者: 评估输出的质量};
    C -- 失败 --> D(反思者: 生成关于失败原因的语言反馈);
    D --> E[将反思存入记忆];
    E --> B;
    C -- 成功 --> F[任务完成];</pre>



<h3 id="Python代码案例-Langgraph"><a href="#Python代码案例-Langgraph" class="headerlink" title="Python代码案例 (Langgraph):"></a><strong>Python代码案例 (Langgraph):</strong></h3><hr>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> random  <span class="comment"># 跳表需要随机数</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span>, <span class="type">Dict</span>, <span class="type">Any</span></span><br><span class="line"><span class="keyword">from</span> dotenv <span class="keyword">import</span> load_dotenv</span><br><span class="line"><span class="keyword">from</span> langchain_openai <span class="keyword">import</span> ChatOpenAI</span><br><span class="line"><span class="keyword">from</span> langchain_core.messages <span class="keyword">import</span> BaseMessage, HumanMessage</span><br><span class="line"><span class="keyword">from</span> typing_extensions <span class="keyword">import</span> TypedDict, Annotated</span><br><span class="line"><span class="keyword">from</span> langgraph.graph <span class="keyword">import</span> StateGraph, END</span><br><span class="line"><span class="keyword">from</span> langgraph.graph.message <span class="keyword">import</span> add_messages</span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 1. 环境设置 (不变) ---</span></span><br><span class="line">load_dotenv()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 2. 定义图的状态 (State) (不变) ---</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GraphState</span>(<span class="title class_ inherited__">TypedDict</span>):</span><br><span class="line">    messages: Annotated[<span class="type">List</span>[BaseMessage], add_messages]</span><br><span class="line">    generation: <span class="built_in">str</span></span><br><span class="line">    attempts: <span class="built_in">int</span></span><br><span class="line">    task: <span class="built_in">str</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 3. 定义图的节点 (Nodes) (不变) ---</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generation_node</span>(<span class="params">state: GraphState</span>) -&gt; <span class="type">Dict</span>[<span class="built_in">str</span>, <span class="type">Any</span>]:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;行动者节点：根据当前状态中的消息历史，生成代码。&quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;\n<span class="subst">&#123;<span class="string">&#x27;=&#x27;</span> * <span class="number">20</span>&#125;</span> 尝试次数: <span class="subst">&#123;state[<span class="string">&#x27;attempts&#x27;</span>] + <span class="number">1</span>&#125;</span> <span class="subst">&#123;<span class="string">&#x27;=&#x27;</span> * <span class="number">20</span>&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;🧠 [Actor] 正在生成解决方案...&quot;</span>)</span><br><span class="line"></span><br><span class="line">    llm = ChatOpenAI(model=<span class="string">&quot;model-router&quot;</span>, temperature=<span class="number">0.3</span>)</span><br><span class="line">    response = llm.invoke(state[<span class="string">&quot;messages&quot;</span>])</span><br><span class="line"></span><br><span class="line">    code_match = re.search(<span class="string">r&quot;```python\n(.*?)```&quot;</span>, response.content, re.DOTALL)</span><br><span class="line">    generation = code_match.group(<span class="number">1</span>).strip() <span class="keyword">if</span> code_match <span class="keyword">else</span> response.content.strip()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;📄 [Actor] 生成的代码:\n<span class="subst">&#123;generation&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;messages&quot;</span>: [response], <span class="string">&quot;generation&quot;</span>: generation, <span class="string">&quot;attempts&quot;</span>: state[<span class="string">&quot;attempts&quot;</span>] + <span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">reflection_node</span>(<span class="params">state: GraphState</span>) -&gt; <span class="type">Dict</span>[<span class="built_in">str</span>, <span class="type">List</span>[BaseMessage]]:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;反思者节点：分析错误并生成改进建议。&quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;🤔 [Reflector] 正在反思错误...&quot;</span>)</span><br><span class="line"></span><br><span class="line">    previous_code = state[<span class="string">&quot;generation&quot;</span>]</span><br><span class="line">    error_message = state[<span class="string">&quot;messages&quot;</span>][-<span class="number">1</span>].content</span><br><span class="line"></span><br><span class="line">    reflection_prompt = [HumanMessage(content=<span class="string">f&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        你是一位顶尖的算法和数据结构工程师。你之前生成的代码未能通过测试。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        **这是你上一次尝试的代码：**</span></span><br><span class="line"><span class="string">        ```python</span></span><br><span class="line"><span class="string">        <span class="subst">&#123;previous_code&#125;</span></span></span><br><span class="line"><span class="string">```</span></span><br><span class="line"><span class="string">        **这是评估系统返回的错误信息：**</span></span><br><span class="line"><span class="string">        <span class="subst">&#123;error_message&#125;</span></span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">        请深刻反思。**不要完全抛弃你之前的代码，而是在它的基础上进行修正。**</span></span><br><span class="line"><span class="string">        分析错误的核心原因，特别是在**指针操作、搜索路径更新（update 数组）和概率性层级确定**方面的逻辑。</span></span><br><span class="line"><span class="string">        你的目标是生成一个能够通过所有测试的、完整且正确的 Python 代码块。&quot;&quot;&quot;</span>)]</span><br><span class="line">    </span><br><span class="line">    reflector_llm = ChatOpenAI(model=<span class="string">&quot;model-router&quot;</span>, temperature=<span class="number">0</span>)</span><br><span class="line">    reflection = reflector_llm.invoke(reflection_prompt)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;💡 [Reflector] 反思与建议:\n<span class="subst">&#123;reflection.content&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;messages&quot;</span>: [reflection]&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># **核心修改**: 一个全新的、用于测试跳表实现的评估节点</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check_code_node</span>(<span class="params">state: GraphState</span>) -&gt; <span class="type">Dict</span>[<span class="built_in">str</span>, <span class="type">List</span>[BaseMessage]]:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    评估者节点：为跳表 (Skip List) 实现运行严格的单元测试。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;⚙️ [Evaluator] 正在评估代码...&quot;</span>)</span><br><span class="line"></span><br><span class="line">    full_code_to_execute = <span class="string">f&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"># AI 生成的代码将在这里</span></span><br><span class="line"><span class="string"><span class="subst">&#123;state[<span class="string">&quot;generation&quot;</span>]&#125;</span></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># --- 我们的测试代码在这里开始 ---</span></span><br><span class="line"><span class="string"># 确保 random 库被导入，因为 AI 的代码可能依赖它</span></span><br><span class="line"><span class="string">import random</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># --- 测试 1: 初始化和基本结构 ---</span></span><br><span class="line"><span class="string">print(&quot;🧪 [Evaluator] 运行测试 1: 初始化和基本结构&quot;)</span></span><br><span class="line"><span class="string">sl = SkipList()</span></span><br><span class="line"><span class="string">assert sl.head is not None, &quot;测试失败: 跳表应有一个头节点。&quot;</span></span><br><span class="line"><span class="string">assert sl.level == 0, &quot;测试失败: 空跳表的层级应为 0。&quot;</span></span><br><span class="line"><span class="string">print(&quot;✅ [Evaluator] 测试 1 通过！&quot;)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># --- 测试 2: 插入和搜索 (成功路径) ---</span></span><br><span class="line"><span class="string">print(&quot;🧪 [Evaluator] 运行测试 2: 插入和搜索 (成功路径)&quot;)</span></span><br><span class="line"><span class="string">keys_to_insert = [3, 6, 7, 9, 12, 19, 17, 26, 21, 25]</span></span><br><span class="line"><span class="string">for key in keys_to_insert:</span></span><br><span class="line"><span class="string">    sl.insert(key)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">for key in keys_to_insert:</span></span><br><span class="line"><span class="string">    assert sl.search(key) is True, f&quot;测试失败: 插入后的键 &#123;&#123;key&#125;&#125; 未被找到。&quot;</span></span><br><span class="line"><span class="string">print(&quot;✅ [Evaluator] 测试 2 通过！&quot;)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># --- 测试 3: 搜索 (失败路径) ---</span></span><br><span class="line"><span class="string">print(&quot;🧪 [Evaluator] 运行测试 3: 搜索 (失败路径)&quot;)</span></span><br><span class="line"><span class="string">keys_not_exist = [4, 8, 18, 30]</span></span><br><span class="line"><span class="string">for key in keys_not_exist:</span></span><br><span class="line"><span class="string">    assert sl.search(key) is False, f&quot;测试失败: 不存在的键 &#123;&#123;key&#125;&#125; 被错误地找到了。&quot;</span></span><br><span class="line"><span class="string">print(&quot;✅ [Evaluator] 测试 3 通过！&quot;)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># --- 测试 4: 删除操作 ---</span></span><br><span class="line"><span class="string">print(&quot;🧪 [Evaluator] 运行测试 4: 删除操作&quot;)</span></span><br><span class="line"><span class="string">keys_to_delete = [3, 9, 19]</span></span><br><span class="line"><span class="string">keys_should_remain = [6, 7, 12, 17, 26, 21, 25]</span></span><br><span class="line"><span class="string">for key in keys_to_delete:</span></span><br><span class="line"><span class="string">    sl.delete(key)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">for key in keys_to_delete:</span></span><br><span class="line"><span class="string">    assert sl.search(key) is False, f&quot;测试失败: 被删除的键 &#123;&#123;key&#125;&#125; 仍然可以被找到。&quot;</span></span><br><span class="line"><span class="string">for key in keys_should_remain:</span></span><br><span class="line"><span class="string">    assert sl.search(key) is True, f&quot;测试失败: 删除操作影响了不相关的键 &#123;&#123;key&#125;&#125;。&quot;</span></span><br><span class="line"><span class="string">print(&quot;✅ [Evaluator] 测试 4 通过！&quot;)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># --- 测试 5: 有序性验证 ---</span></span><br><span class="line"><span class="string">print(&quot;🧪 [Evaluator] 运行测试 5: 有序性验证&quot;)</span></span><br><span class="line"><span class="string">current = sl.head.forward[0]</span></span><br><span class="line"><span class="string">sorted_list = []</span></span><br><span class="line"><span class="string">while current:</span></span><br><span class="line"><span class="string">    sorted_list.append(current.key)</span></span><br><span class="line"><span class="string">    current = current.forward[0]</span></span><br><span class="line"><span class="string">assert sorted_list == sorted(keys_should_remain), &quot;测试失败: 底层链表不满足有序性。&quot;</span></span><br><span class="line"><span class="string">print(&quot;✅ [Evaluator] 测试 5 通过！&quot;)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">exec</span>(full_code_to_execute, &#123;<span class="string">&quot;random&quot;</span>: random&#125;)</span><br><span class="line">    </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;🎉 [Evaluator] 所有测试通过！跳表实现正确且健壮！&quot;</span>)</span><br><span class="line">        message = HumanMessage(</span><br><span class="line">            content=<span class="string">&quot;[评估结果]: 所有测试用例均已通过。代码正确实现了搜索、插入和删除，并保持了有序性。&quot;</span>,</span><br><span class="line">            name=<span class="string">&quot;evaluator&quot;</span></span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;❌ [Evaluator] 测试失败: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">        message = HumanMessage(</span><br><span class="line">            content=<span class="string">f&quot;[评估结果]: 代码评估失败，错误信息: <span class="subst">&#123;e&#125;</span>&quot;</span>,</span><br><span class="line">            name=<span class="string">&quot;evaluator&quot;</span></span><br><span class="line">        )</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;messages&quot;</span>: [message]&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 4. 定义图的边 (Edges) (不变) ---</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">should_continue</span>(<span class="params">state: GraphState</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    last_message = state[<span class="string">&quot;messages&quot;</span>][-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(last_message, HumanMessage) <span class="keyword">and</span> last_message.name == <span class="string">&quot;evaluator&quot;</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;所有测试用例均已通过&quot;</span> <span class="keyword">in</span> last_message.content:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;end&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> state[<span class="string">&quot;attempts&quot;</span>] &gt;= <span class="number">5</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;--- 达到最大尝试次数，结束流程 ---&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;end&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;reflect&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 5. 构建并运行图 ---</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    workflow = StateGraph(GraphState)</span><br><span class="line">    <span class="comment"># ... (图的构建与之前完全相同)</span></span><br><span class="line">    workflow.add_node(<span class="string">&quot;generate&quot;</span>, generation_node)</span><br><span class="line">    workflow.add_node(<span class="string">&quot;check_code&quot;</span>, check_code_node)</span><br><span class="line">    workflow.add_node(<span class="string">&quot;reflect&quot;</span>, reflection_node)</span><br><span class="line">    workflow.set_entry_point(<span class="string">&quot;generate&quot;</span>)</span><br><span class="line">    workflow.add_edge(<span class="string">&quot;generate&quot;</span>, <span class="string">&quot;check_code&quot;</span>)</span><br><span class="line">    workflow.add_edge(<span class="string">&quot;reflect&quot;</span>, <span class="string">&quot;generate&quot;</span>)</span><br><span class="line">    workflow.add_conditional_edges(</span><br><span class="line">        <span class="string">&quot;check_code&quot;</span>, should_continue, &#123;<span class="string">&quot;reflect&quot;</span>: <span class="string">&quot;reflect&quot;</span>, <span class="string">&quot;end&quot;</span>: END&#125;</span><br><span class="line">    )</span><br><span class="line">    app = workflow.<span class="built_in">compile</span>()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># **核心修改**: 一个全新的、冷门且复杂的任务</span></span><br><span class="line">    task = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    请使用Python实现一个**跳表 (Skip List)**。</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    你需要实现两个类：`Node` 和 `SkipList`。</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    1.  `Node` 类:</span></span><br><span class="line"><span class="string">        -   应包含 `key` (int) 属性。</span></span><br><span class="line"><span class="string">        -   应包含一个 `forward` 属性，它是一个列表，用于存放指向各层级下一个节点的引用。</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    2.  `SkipList` 类:</span></span><br><span class="line"><span class="string">        -   应有一个 `max_level` (最大层数) 和 `p` (概率因子) 作为初始化参数。</span></span><br><span class="line"><span class="string">        -   应有一个 `head` 节点，它是一个哨兵节点，不存储实际的键。</span></span><br><span class="line"><span class="string">        -   应有一个 `level` 属性，记录当前跳表的最高层级。</span></span><br><span class="line"><span class="string">        -   需要实现以下方法：</span></span><br><span class="line"><span class="string">            a. `random_level()`: 概率性地为新节点生成一个层级。层级为 1 的概率是 1，为 2 的概率是 p，为 3 的概率是 p*p，以此类推，但不超过 `max_level`。</span></span><br><span class="line"><span class="string">            b. `search(key)`: 查找一个键是否存在。如果存在返回 `True`，否则返回 `False`。</span></span><br><span class="line"><span class="string">            c. `insert(key)`: 插入一个键。**核心难点**：你必须从最高层开始查找，并记录下每层中需要被更新的**前驱节点** (通常保存在一个 `update` 数组中)，然后在插入新节点时，使用这个数组来正确地连接指针。</span></span><br><span class="line"><span class="string">            d. `delete(key)`: 删除一个键。与插入类似，需要先找到待删除节点的所有前驱节点。</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    请确保你的实现是健壮的，并且能正确处理指针的连接与断开。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    initial_input = &#123;</span><br><span class="line">        <span class="string">&quot;messages&quot;</span>: [HumanMessage(content=task)], <span class="string">&quot;attempts&quot;</span>: <span class="number">0</span>, <span class="string">&quot;task&quot;</span>: task, <span class="string">&quot;generation&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;🚀 开始执行 Reflexion 流程，挑战冷门数据结构：跳表...&quot;</span>)</span><br><span class="line">    app.invoke(initial_input)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n🏁 流程结束。&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="输出：-3"><a href="#输出：-3" class="headerlink" title="输出："></a><strong>输出：</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br></pre></td><td class="code"><pre><span class="line">🚀 开始执行 Reflexion 流程，挑战冷门数据结构：跳表...</span><br><span class="line"></span><br><span class="line">==================== 尝试次数: 1 ====================</span><br><span class="line">🧠 [Actor] 正在生成解决方案...</span><br><span class="line">📄 [Actor] 生成的代码:</span><br><span class="line">import random</span><br><span class="line"></span><br><span class="line">class Node:</span><br><span class="line">    def __init__(self, key, level):</span><br><span class="line">        self.key = key</span><br><span class="line">        # forward 是一个列表，长度为 level，存放每一层的下一个节点引用</span><br><span class="line">        self.forward = [None] * level</span><br><span class="line"></span><br><span class="line">class SkipList:</span><br><span class="line">    def __init__(self, max_level, p):</span><br><span class="line">        self.max_level = max_level  # 最大层数</span><br><span class="line">        self.p = p                  # 概率因子</span><br><span class="line">        self.level = 1              # 当前跳表的最高层级，初始为1</span><br><span class="line">        self.head = Node(None, max_level)  # 哨兵节点，key为None，层数为max_level</span><br><span class="line"></span><br><span class="line">    def random_level(self):</span><br><span class="line">        lvl = 1</span><br><span class="line">        # 以概率p决定是否提升层级，最多不超过max_level</span><br><span class="line">        while random.random() &lt; self.p and lvl &lt; self.max_level:</span><br><span class="line">            lvl += 1</span><br><span class="line">        return lvl</span><br><span class="line">    </span><br><span class="line">    def search(self, key):</span><br><span class="line">        current = self.head</span><br><span class="line">        # 从最高层开始往下查找</span><br><span class="line">        for i in reversed(range(self.level)):</span><br><span class="line">            # 在当前层不断向前移动，直到下一个节点的key大于等于目标key</span><br><span class="line">            while current.forward[i] and current.forward[i].key &lt; key:</span><br><span class="line">                current = current.forward[i]</span><br><span class="line">        # 到了最底层，检查下一个节点是否是目标key</span><br><span class="line">        current = current.forward[0]</span><br><span class="line">        if current and current.key == key:</span><br><span class="line">            return True</span><br><span class="line">        return False</span><br><span class="line">    </span><br><span class="line">    def insert(self, key):</span><br><span class="line">        update = [None] * self.max_level  # 记录每层需要更新的前驱节点</span><br><span class="line">        current = self.head</span><br><span class="line">    </span><br><span class="line">        # 从最高层开始查找插入位置，记录每层的前驱节点</span><br><span class="line">        for i in reversed(range(self.level)):</span><br><span class="line">            while current.forward[i] and current.forward[i].key &lt; key:</span><br><span class="line">                current = current.forward[i]</span><br><span class="line">            update[i] = current</span><br><span class="line">    </span><br><span class="line">        # 到最底层的下一个节点</span><br><span class="line">        current = current.forward[0]</span><br><span class="line">    </span><br><span class="line">        # 如果key已存在，直接返回（跳表不允许重复键）</span><br><span class="line">        if current and current.key == key:</span><br><span class="line">            return</span><br><span class="line">    </span><br><span class="line">        # 生成新节点的层级</span><br><span class="line">        lvl = self.random_level()</span><br><span class="line">    </span><br><span class="line">        # 如果新节点层级比当前跳表层级高，需要更新update数组的高层指向head</span><br><span class="line">        if lvl &gt; self.level:</span><br><span class="line">            for i in range(self.level, lvl):</span><br><span class="line">                update[i] = self.head</span><br><span class="line">            self.level = lvl</span><br><span class="line">    </span><br><span class="line">        # 创建新节点</span><br><span class="line">        new_node = Node(key, lvl)</span><br><span class="line">    </span><br><span class="line">        # 插入新节点，调整每层的forward指针</span><br><span class="line">        for i in range(lvl):</span><br><span class="line">            new_node.forward[i] = update[i].forward[i]</span><br><span class="line">            update[i].forward[i] = new_node</span><br><span class="line">    </span><br><span class="line">    def delete(self, key):</span><br><span class="line">        update = [None] * self.max_level</span><br><span class="line">        current = self.head</span><br><span class="line">    </span><br><span class="line">        # 找到所有层级中待删除节点的前驱节点</span><br><span class="line">        for i in reversed(range(self.level)):</span><br><span class="line">            while current.forward[i] and current.forward[i].key &lt; key:</span><br><span class="line">                current = current.forward[i]</span><br><span class="line">            update[i] = current</span><br><span class="line">    </span><br><span class="line">        current = current.forward[0]</span><br><span class="line">    </span><br><span class="line">        # 如果找到目标节点，调整指针删除它</span><br><span class="line">        if current and current.key == key:</span><br><span class="line">            for i in range(self.level):</span><br><span class="line">                if update[i].forward[i] != current:</span><br><span class="line">                    break</span><br><span class="line">                update[i].forward[i] = current.forward[i]</span><br><span class="line">    </span><br><span class="line">            # 删除后可能需要降低跳表的层级</span><br><span class="line">            while self.level &gt; 1 and self.head.forward[self.level - 1] is None:</span><br><span class="line">                self.level -= 1</span><br><span class="line">    </span><br><span class="line">    # 方便调试，打印跳表</span><br><span class="line">    def display(self):</span><br><span class="line">        print(&quot;SkipList:&quot;)</span><br><span class="line">        for i in reversed(range(self.level)):</span><br><span class="line">            current = self.head.forward[i]</span><br><span class="line">            line = f&quot;Level &#123;i+1&#125;: &quot;</span><br><span class="line">            while current:</span><br><span class="line">                line += str(current.key) + &quot; -&gt; &quot;</span><br><span class="line">                current = current.forward[i]</span><br><span class="line">            line += &quot;None&quot;</span><br><span class="line">            print(line)</span><br><span class="line">⚙️ [Evaluator] 正在评估代码...</span><br><span class="line">🧪 [Evaluator] 运行测试 1: 初始化和基本结构</span><br><span class="line">❌ [Evaluator] 测试失败: SkipList.__init__() missing 2 required positional arguments: &#x27;max_level&#x27; and &#x27;p&#x27;</span><br><span class="line">🤔 [Reflector] 正在反思错误...</span><br><span class="line">💡 [Reflector] 反思与建议:</span><br><span class="line">根据错误信息：</span><br><span class="line"></span><br><span class="line">```</span><br><span class="line">SkipList.__init__() missing 2 required positional arguments: &#x27;max_level&#x27; and &#x27;p&#x27;</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">可以看出，评测系统在实例化 `SkipList` 时没有传入 `max_level` 和 `p` 参数，导致初始化失败。</span><br><span class="line"></span><br><span class="line">这说明：</span><br><span class="line"></span><br><span class="line">- 评测系统期望 `SkipList` 的构造函数是无参的，或者有默认参数。</span><br><span class="line">- 也可能是评测系统会先实例化 `SkipList()`，然后调用其他方法。</span><br><span class="line"></span><br><span class="line">因此，我们需要修改 `SkipList` 的构造函数，给 `max_level` 和 `p` 设置默认值，或者改成无参构造函数，并在类内部定义默认的 `max_level` 和 `p`。</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">除此之外，针对跳表的核心逻辑：</span><br><span class="line"></span><br><span class="line">- `random_level` 函数的概率和最大层数控制是正确的。</span><br><span class="line">- `search`、`insert`、`delete` 中的 `update` 数组维护和指针操作逻辑也基本正确。</span><br><span class="line">- 但需要注意 `update` 数组的长度和索引范围，确保不会越界。</span><br><span class="line">- 另外，`delete` 中的层级调整逻辑也需要确认。</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">**总结修改点：**</span><br><span class="line"></span><br><span class="line">1. 给 `SkipList.__init__` 添加默认参数，或者无参构造函数，避免初始化失败。</span><br><span class="line">2. 确保 `update` 数组长度为 `max_level`，且在循环中索引正确。</span><br><span class="line">3. 确认 `delete` 中层级调整逻辑正确。</span><br><span class="line">4. 代码风格和注释保持清晰。</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">下面是基于你之前代码的修正版本，添加了默认参数，修正了细节，保证能通过测试：</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">import random</span><br><span class="line"></span><br><span class="line">class Node:</span><br><span class="line">    def __init__(self, key, level):</span><br><span class="line">        self.key = key</span><br><span class="line">        # forward 是一个列表，长度为 level，存放每一层的下一个节点引用</span><br><span class="line">        self.forward = [None] * level</span><br><span class="line"></span><br><span class="line">class SkipList:</span><br><span class="line">    def __init__(self, max_level=16, p=0.5):</span><br><span class="line">        self.max_level = max_level  # 最大层数</span><br><span class="line">        self.p = p                  # 概率因子</span><br><span class="line">        self.level = 1              # 当前跳表的最高层级，初始为1</span><br><span class="line">        self.head = Node(None, max_level)  # 哨兵节点，key为None，层数为max_level</span><br><span class="line"></span><br><span class="line">    def random_level(self):</span><br><span class="line">        lvl = 1</span><br><span class="line">        # 以概率p决定是否提升层级，最多不超过max_level</span><br><span class="line">        while random.random() &lt; self.p and lvl &lt; self.max_level:</span><br><span class="line">            lvl += 1</span><br><span class="line">        return lvl</span><br><span class="line"></span><br><span class="line">    def search(self, key):</span><br><span class="line">        current = self.head</span><br><span class="line">        # 从最高层开始往下查找</span><br><span class="line">        for i in reversed(range(self.level)):</span><br><span class="line">            # 在当前层不断向前移动，直到下一个节点的key大于等于目标key</span><br><span class="line">            while current.forward[i] and current.forward[i].key &lt; key:</span><br><span class="line">                current = current.forward[i]</span><br><span class="line">        # 到了最底层，检查下一个节点是否是目标key</span><br><span class="line">        current = current.forward[0]</span><br><span class="line">        if current and current.key == key:</span><br><span class="line">            return True</span><br><span class="line">        return False</span><br><span class="line"></span><br><span class="line">    def insert(self, key):</span><br><span class="line">        update = [None] * self.max_level  # 记录每层需要更新的前驱节点</span><br><span class="line">        current = self.head</span><br><span class="line"></span><br><span class="line">        # 从最高层开始查找插入位置，记录每层的前驱节点</span><br><span class="line">        for i in reversed(range(self.level)):</span><br><span class="line">            while current.forward[i] and current.forward[i].key &lt; key:</span><br><span class="line">                current = current.forward[i]</span><br><span class="line">            update[i] = current</span><br><span class="line"></span><br><span class="line">        # 到最底层的下一个节点</span><br><span class="line">        current = current.forward[0]</span><br><span class="line"></span><br><span class="line">        # 如果key已存在，直接返回（跳表不允许重复键）</span><br><span class="line">        if current and current.key == key:</span><br><span class="line">            return</span><br><span class="line"></span><br><span class="line">        # 生成新节点的层级</span><br><span class="line">        lvl = self.random_level()</span><br><span class="line"></span><br><span class="line">        # 如果新节点层级比当前跳表层级高，需要更新update数组的高层指向head</span><br><span class="line">        if lvl &gt; self.level:</span><br><span class="line">            for i in range(self.level, lvl):</span><br><span class="line">                update[i] = self.head</span><br><span class="line">            self.level = lvl</span><br><span class="line"></span><br><span class="line">        # 创建新节点</span><br><span class="line">        new_node = Node(key, lvl)</span><br><span class="line"></span><br><span class="line">        # 插入新节点，调整每层的forward指针</span><br><span class="line">        for i in range(lvl):</span><br><span class="line">            new_node.forward[i] = update[i].forward[i]</span><br><span class="line">            update[i].forward[i] = new_node</span><br><span class="line"></span><br><span class="line">    def delete(self, key):</span><br><span class="line">        update = [None] * self.max_level</span><br><span class="line">        current = self.head</span><br><span class="line"></span><br><span class="line">        # 找到所有层级中待删除节点的前驱节点</span><br><span class="line">        for i in reversed(range(self.level)):</span><br><span class="line">            while current.forward[i] and current.forward[i].key &lt; key:</span><br><span class="line">                current = current.forward[i]</span><br><span class="line">            update[i] = current</span><br><span class="line"></span><br><span class="line">        current = current.forward[0]</span><br><span class="line"></span><br><span class="line">        # 如果找到目标节点，调整指针删除它</span><br><span class="line">        if current and current.key == key:</span><br><span class="line">            for i in range(self.level):</span><br><span class="line">                if update[i].forward[i] != current:</span><br><span class="line">                    break</span><br><span class="line">                update[i].forward[i] = current.forward[i]</span><br><span class="line"></span><br><span class="line">            # 删除后可能需要降低跳表的层级</span><br><span class="line">            while self.level &gt; 1 and self.head.forward[self.level - 1] is None:</span><br><span class="line">                self.level -= 1</span><br><span class="line"></span><br><span class="line">    # 方便调试，打印跳表</span><br><span class="line">    def display(self):</span><br><span class="line">        print(&quot;SkipList:&quot;)</span><br><span class="line">        for i in reversed(range(self.level)):</span><br><span class="line">            current = self.head.forward[i]</span><br><span class="line">            line = f&quot;Level &#123;i+1&#125;: &quot;</span><br><span class="line">            while current:</span><br><span class="line">                line += str(current.key) + &quot; -&gt; &quot;</span><br><span class="line">                current = current.forward[i]</span><br><span class="line">            line += &quot;None&quot;</span><br><span class="line">            print(line)</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">**说明：**</span><br><span class="line"></span><br><span class="line">- `__init__` 中给 `max_level=16` 和 `p=0.5` 默认值，保证无参实例化不会报错。</span><br><span class="line">- 其他逻辑保持不变，符合跳表的设计。</span><br><span class="line">- 这样既满足评测系统的调用方式，也保证跳表功能正确。</span><br><span class="line"></span><br><span class="line">你可以用以下代码测试：</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    sl = SkipList()</span><br><span class="line">    sl.insert(3)</span><br><span class="line">    sl.insert(6)</span><br><span class="line">    sl.insert(7)</span><br><span class="line">    sl.insert(9)</span><br><span class="line">    sl.insert(12)</span><br><span class="line">    sl.insert(19)</span><br><span class="line">    sl.insert(17)</span><br><span class="line">    sl.insert(26)</span><br><span class="line">    sl.insert(21)</span><br><span class="line">    sl.insert(25)</span><br><span class="line">    sl.display()</span><br><span class="line"></span><br><span class="line">    print(&quot;Search 19:&quot;, sl.search(19))</span><br><span class="line">    print(&quot;Search 15:&quot;, sl.search(15))</span><br><span class="line"></span><br><span class="line">    sl.delete(19)</span><br><span class="line">    print(&quot;After deleting 19:&quot;)</span><br><span class="line">    sl.display()</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">这样就能验证跳表的插入、搜索和删除功能是否正常。</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">如果你还有其他需求或者测试用例，可以告诉我，我帮你进一步完善。</span><br><span class="line"></span><br><span class="line">==================== 尝试次数: 2 ====================</span><br><span class="line">🧠 [Actor] 正在生成解决方案...</span><br><span class="line">📄 [Actor] 生成的代码:</span><br><span class="line">import random</span><br><span class="line"></span><br><span class="line">class Node:</span><br><span class="line">    def __init__(self, key, level):</span><br><span class="line">        self.key = key</span><br><span class="line">        self.forward = [None] * level</span><br><span class="line"></span><br><span class="line">class SkipList:</span><br><span class="line">    def __init__(self, max_level=16, p=0.5):</span><br><span class="line">        self.max_level = max_level</span><br><span class="line">        self.p = p</span><br><span class="line">        self.level = 1</span><br><span class="line">        self.head = Node(None, max_level)</span><br><span class="line"></span><br><span class="line">    def random_level(self):</span><br><span class="line">        lvl = 1</span><br><span class="line">        while random.random() &lt; self.p and lvl &lt; self.max_level:</span><br><span class="line">            lvl += 1</span><br><span class="line">        return lvl</span><br><span class="line">    </span><br><span class="line">    def search(self, key):</span><br><span class="line">        current = self.head</span><br><span class="line">        for i in reversed(range(self.level)):</span><br><span class="line">            while current.forward[i] and current.forward[i].key &lt; key:</span><br><span class="line">                current = current.forward[i]</span><br><span class="line">        current = current.forward[0]</span><br><span class="line">        return current is not None and current.key == key</span><br><span class="line">    </span><br><span class="line">    def insert(self, key):</span><br><span class="line">        update = [None] * self.max_level</span><br><span class="line">        current = self.head</span><br><span class="line">        for i in reversed(range(self.level)):</span><br><span class="line">            while current.forward[i] and current.forward[i].key &lt; key:</span><br><span class="line">                current = current.forward[i]</span><br><span class="line">            update[i] = current</span><br><span class="line">        current = current.forward[0]</span><br><span class="line">        if current and current.key == key:</span><br><span class="line">            return</span><br><span class="line">        lvl = self.random_level()</span><br><span class="line">        if lvl &gt; self.level:</span><br><span class="line">            for i in range(self.level, lvl):</span><br><span class="line">                update[i] = self.head</span><br><span class="line">            self.level = lvl</span><br><span class="line">        new_node = Node(key, lvl)</span><br><span class="line">        for i in range(lvl):</span><br><span class="line">            new_node.forward[i] = update[i].forward[i]</span><br><span class="line">            update[i].forward[i] = new_node</span><br><span class="line">    </span><br><span class="line">    def delete(self, key):</span><br><span class="line">        update = [None] * self.max_level</span><br><span class="line">        current = self.head</span><br><span class="line">        for i in reversed(range(self.level)):</span><br><span class="line">            while current.forward[i] and current.forward[i].key &lt; key:</span><br><span class="line">                current = current.forward[i]</span><br><span class="line">            update[i] = current</span><br><span class="line">        current = current.forward[0]</span><br><span class="line">        if current and current.key == key:</span><br><span class="line">            for i in range(self.level):</span><br><span class="line">                if update[i].forward[i] != current:</span><br><span class="line">                    break</span><br><span class="line">                update[i].forward[i] = current.forward[i]</span><br><span class="line">            while self.level &gt; 1 and self.head.forward[self.level - 1] is None:</span><br><span class="line">                self.level -= 1</span><br><span class="line">⚙️ [Evaluator] 正在评估代码...</span><br><span class="line">🧪 [Evaluator] 运行测试 1: 初始化和基本结构</span><br><span class="line">❌ [Evaluator] 测试失败: 测试失败: 空跳表的层级应为 0。</span><br><span class="line">🤔 [Reflector] 正在反思错误...</span><br><span class="line">💡 [Reflector] 反思与建议:</span><br><span class="line">感谢反馈！根据错误信息“空跳表的层级应为 0”，可以推断出之前代码中跳表初始化时 `self.level` 设为 1 是不符合要求的。跳表为空时，层级应为 0，表示没有任何有效节点。</span><br><span class="line"></span><br><span class="line">此外，结合跳表的设计原则和之前代码的逻辑，以下几点需要修正和优化：</span><br><span class="line"></span><br><span class="line">1. **初始化层级**  </span><br><span class="line">   - `self.level` 应初始化为 0，表示空跳表无层级。</span><br><span class="line"></span><br><span class="line">2. **插入时更新层级**  </span><br><span class="line">   - 当插入新节点的层级大于当前跳表层级时，需将 `self.level` 更新为新节点层级。</span><br><span class="line">   - 同时，`update` 数组中对应层级的指针应指向 `self.head`。</span><br><span class="line"></span><br><span class="line">3. **删除时更新层级**  </span><br><span class="line">   - 删除节点后，如果最高层为空，应递减 `self.level`，直到最高层有节点或层级为 0。</span><br><span class="line"></span><br><span class="line">4. **搜索和插入时遍历层级范围**  </span><br><span class="line">   - 遍历层级时应从 `self.level - 1` 到 0，确保层级范围正确。</span><br><span class="line"></span><br><span class="line">5. **`update` 数组大小**  </span><br><span class="line">   - `update` 数组大小应为 `self.max_level`，以支持最大层级。</span><br><span class="line"></span><br><span class="line">6. **节点的 `forward` 数组长度**  </span><br><span class="line">   - 节点的 `forward` 数组长度应为节点层级。</span><br><span class="line"></span><br><span class="line">7. **随机层级生成**  </span><br><span class="line">   - 保持原有逻辑，符合跳表概率分布。</span><br><span class="line"></span><br><span class="line">基于以上分析，以下是修正后的完整代码：</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">import random</span><br><span class="line"></span><br><span class="line">class Node:</span><br><span class="line">    def __init__(self, key, level):</span><br><span class="line">        self.key = key</span><br><span class="line">        # forward数组长度为level，索引0到level-1</span><br><span class="line">        self.forward = [None] * level</span><br><span class="line"></span><br><span class="line">class SkipList:</span><br><span class="line">    def __init__(self, max_level=16, p=0.5):</span><br><span class="line">        self.max_level = max_level</span><br><span class="line">        self.p = p</span><br><span class="line">        self.level = 0  # 空跳表层级为0</span><br><span class="line">        self.head = Node(None, max_level)  # 头节点最大层级</span><br><span class="line"></span><br><span class="line">    def random_level(self):</span><br><span class="line">        lvl = 1</span><br><span class="line">        while random.random() &lt; self.p and lvl &lt; self.max_level:</span><br><span class="line">            lvl += 1</span><br><span class="line">        return lvl</span><br><span class="line"></span><br><span class="line">    def search(self, key):</span><br><span class="line">        current = self.head</span><br><span class="line">        # 从最高层开始向下搜索</span><br><span class="line">        for i in reversed(range(self.level)):</span><br><span class="line">            while current.forward[i] and current.forward[i].key &lt; key:</span><br><span class="line">                current = current.forward[i]</span><br><span class="line">        current = current.forward[0]</span><br><span class="line">        return current is not None and current.key == key</span><br><span class="line"></span><br><span class="line">    def insert(self, key):</span><br><span class="line">        update = [None] * self.max_level</span><br><span class="line">        current = self.head</span><br><span class="line">        # 找到每层插入位置的前驱节点</span><br><span class="line">        for i in reversed(range(self.level)):</span><br><span class="line">            while current.forward[i] and current.forward[i].key &lt; key:</span><br><span class="line">                current = current.forward[i]</span><br><span class="line">            update[i] = current</span><br><span class="line">        # 0层的后继节点</span><br><span class="line">        current = current.forward[0]</span><br><span class="line"></span><br><span class="line">        # 如果key已存在，直接返回</span><br><span class="line">        if current and current.key == key:</span><br><span class="line">            return</span><br><span class="line"></span><br><span class="line">        lvl = self.random_level()</span><br><span class="line">        # 如果新节点层级大于当前跳表层级，更新update数组和跳表层级</span><br><span class="line">        if lvl &gt; self.level:</span><br><span class="line">            for i in range(self.level, lvl):</span><br><span class="line">                update[i] = self.head</span><br><span class="line">            self.level = lvl</span><br><span class="line"></span><br><span class="line">        new_node = Node(key, lvl)</span><br><span class="line">        # 插入节点，更新forward指针</span><br><span class="line">        for i in range(lvl):</span><br><span class="line">            new_node.forward[i] = update[i].forward[i]</span><br><span class="line">            update[i].forward[i] = new_node</span><br><span class="line"></span><br><span class="line">    def delete(self, key):</span><br><span class="line">        update = [None] * self.max_level</span><br><span class="line">        current = self.head</span><br><span class="line">        # 找到每层待删除节点的前驱节点</span><br><span class="line">        for i in reversed(range(self.level)):</span><br><span class="line">            while current.forward[i] and current.forward[i].key &lt; key:</span><br><span class="line">                current = current.forward[i]</span><br><span class="line">            update[i] = current</span><br><span class="line">        current = current.forward[0]</span><br><span class="line"></span><br><span class="line">        if current and current.key == key:</span><br><span class="line">            # 更新指针，跳过当前节点</span><br><span class="line">            for i in range(self.level):</span><br><span class="line">                if update[i].forward[i] != current:</span><br><span class="line">                    break</span><br><span class="line">                update[i].forward[i] = current.forward[i]</span><br><span class="line">            # 调整跳表层级，去除空层</span><br><span class="line">            while self.level &gt; 0 and self.head.forward[self.level - 1] is None:</span><br><span class="line">                self.level -= 1</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">### 说明</span><br><span class="line"></span><br><span class="line">- 初始化时 `self.level = 0`，符合空跳表层级为0的要求。</span><br><span class="line">- 插入时若新节点层级大于当前层级，更新 `update` 数组对应层级为 `self.head`，并更新 `self.level`。</span><br><span class="line">- 删除时若最高层为空，递减 `self.level`，直到最高层有节点或层级为0。</span><br><span class="line">- 搜索、插入、删除时遍历层级范围均为 `[self.level - 1, ..., 0]`。</span><br><span class="line">- 代码结构清晰，符合跳表设计规范。</span><br><span class="line"></span><br><span class="line">请使用此代码进行测试，若有进一步问题，欢迎继续反馈！</span><br><span class="line"></span><br><span class="line">==================== 尝试次数: 3 ====================</span><br><span class="line">🧠 [Actor] 正在生成解决方案...</span><br><span class="line">📄 [Actor] 生成的代码:</span><br><span class="line">import random</span><br><span class="line"></span><br><span class="line">class Node:</span><br><span class="line">    def __init__(self, key, level):</span><br><span class="line">        self.key = key</span><br><span class="line">        self.forward = [None] * level</span><br><span class="line"></span><br><span class="line">class SkipList:</span><br><span class="line">    def __init__(self, max_level=16, p=0.5):</span><br><span class="line">        self.max_level = max_level</span><br><span class="line">        self.p = p</span><br><span class="line">        self.level = 0  # 空跳表层级应为0</span><br><span class="line">        self.head = Node(None, max_level)</span><br><span class="line"></span><br><span class="line">    def random_level(self):</span><br><span class="line">        lvl = 1</span><br><span class="line">        while random.random() &lt; self.p and lvl &lt; self.max_level:</span><br><span class="line">            lvl += 1</span><br><span class="line">        return lvl</span><br><span class="line">    </span><br><span class="line">    def search(self, key):</span><br><span class="line">        current = self.head</span><br><span class="line">        for i in reversed(range(self.level)):</span><br><span class="line">            while current.forward[i] and current.forward[i].key &lt; key:</span><br><span class="line">                current = current.forward[i]</span><br><span class="line">        current = current.forward[0]</span><br><span class="line">        return current is not None and current.key == key</span><br><span class="line">    </span><br><span class="line">    def insert(self, key):</span><br><span class="line">        update = [None] * self.max_level</span><br><span class="line">        current = self.head</span><br><span class="line">        for i in reversed(range(self.level)):</span><br><span class="line">            while current.forward[i] and current.forward[i].key &lt; key:</span><br><span class="line">                current = current.forward[i]</span><br><span class="line">            update[i] = current</span><br><span class="line">    </span><br><span class="line">        current = current.forward[0]</span><br><span class="line">        if current and current.key == key:</span><br><span class="line">            return  # 不允许重复插入</span><br><span class="line">    </span><br><span class="line">        lvl = self.random_level()</span><br><span class="line">        if lvl &gt; self.level:</span><br><span class="line">            for i in range(self.level, lvl):</span><br><span class="line">                update[i] = self.head</span><br><span class="line">            self.level = lvl</span><br><span class="line">    </span><br><span class="line">        new_node = Node(key, lvl)</span><br><span class="line">        for i in range(lvl):</span><br><span class="line">            new_node.forward[i] = update[i].forward[i]</span><br><span class="line">            update[i].forward[i] = new_node</span><br><span class="line">    </span><br><span class="line">    def delete(self, key):</span><br><span class="line">        update = [None] * self.max_level</span><br><span class="line">        current = self.head</span><br><span class="line">        for i in reversed(range(self.level)):</span><br><span class="line">            while current.forward[i] and current.forward[i].key &lt; key:</span><br><span class="line">                current = current.forward[i]</span><br><span class="line">            update[i] = current</span><br><span class="line">    </span><br><span class="line">        current = current.forward[0]</span><br><span class="line">        if current and current.key == key:</span><br><span class="line">            for i in range(self.level):</span><br><span class="line">                if update[i].forward[i] != current:</span><br><span class="line">                    break</span><br><span class="line">                update[i].forward[i] = current.forward[i]</span><br><span class="line">    </span><br><span class="line">            while self.level &gt; 0 and self.head.forward[self.level - 1] is None:</span><br><span class="line">                self.level -= 1</span><br><span class="line">⚙️ [Evaluator] 正在评估代码...</span><br><span class="line">🧪 [Evaluator] 运行测试 1: 初始化和基本结构</span><br><span class="line">✅ [Evaluator] 测试 1 通过！</span><br><span class="line">🧪 [Evaluator] 运行测试 2: 插入和搜索 (成功路径)</span><br><span class="line">✅ [Evaluator] 测试 2 通过！</span><br><span class="line">🧪 [Evaluator] 运行测试 3: 搜索 (失败路径)</span><br><span class="line">✅ [Evaluator] 测试 3 通过！</span><br><span class="line">🧪 [Evaluator] 运行测试 4: 删除操作</span><br><span class="line">✅ [Evaluator] 测试 4 通过！</span><br><span class="line">🧪 [Evaluator] 运行测试 5: 有序性验证</span><br><span class="line">✅ [Evaluator] 测试 5 通过！</span><br><span class="line">🎉 [Evaluator] 所有测试通过！跳表实现正确且健壮！</span><br><span class="line"></span><br><span class="line">🏁 流程结束。</span><br></pre></td></tr></table></figure>

<h3 id="代码整体流程：-4"><a href="#代码整体流程：-4" class="headerlink" title="代码整体流程："></a><strong>代码整体流程：</strong></h3><pre class="mermaid">sequenceDiagram
    %% 1. 使用唯一的、非关键字的ID定义参与者
    participant user_p as "用户"
    participant graph_p as "LangGraph 流程"
    participant actor_node as "生成节点 (Actor)"
    participant evaluator_node as "评估节点 (Evaluator)"
    participant reflector_node as "反思节点 (Reflector)"

    %% --- 流程开始 ---
    %% 2. 在所有交互中，使用这些唯一的ID
    user_p->>graph_p: 请求实现跳表
    activate graph_p
    graph_p->>actor_node: [尝试 1] 生成代码
    activate actor_node

    %% --- 第一次尝试 (Attempt 1) ---
    actor_node-->>graph_p: 返回初版代码
    deactivate actor_node
    graph_p->>evaluator_node: 评估代码
    activate evaluator_node
    Note right of evaluator_node: 执行单元测试...<br>测试 1 失败: __init__ 缺少参数
    evaluator_node-->>graph_p: 返回错误信息
    deactivate evaluator_node

    Note over graph_p: 条件判断 should_continue()<br>因测试失败, 决定进行反思
    graph_p->>reflector_node: 请求反思
    activate reflector_node
    Note right of reflector_node: 分析错误原因 (构造函数问题)<br>生成修正建议 (添加默认参数)
    reflector_node-->>graph_p: 返回反思结果
    deactivate reflector_node

    %% --- 第二次尝试 (Attempt 2) ---
    graph_p->>actor_node: [尝试 2] 重新生成代码
    activate actor_node
    actor_node-->>graph_p: 返回第二版代码
    deactivate actor_node
    graph_p->>evaluator_node: 评估代码
    activate evaluator_node
    Note right of evaluator_node: 执行单元测试...<br>测试 1 失败: 空跳表 level 应为 0
    evaluator_node-->>graph_p: 返回新的错误信息
    deactivate evaluator_node

    Note over graph_p: 条件判断 should_continue()<br>因再次失败, 决定再次反思
    graph_p->>reflector_node: 请求反思
    activate reflector_node
    Note right of reflector_node: 分析新错误 (初始化层级问题)<br>生成更深入的修正建议 (level=0)
    reflector_node-->>graph_p: 返回新的反思结果
    deactivate reflector_node

    %% --- 第三次尝试 (Attempt 3) ---
    graph_p->>actor_node: [尝试 3] 最终生成代码
    activate actor_node
    actor_node-->>graph_p: 返回第三版代码
    deactivate actor_node
    graph_p->>evaluator_node: 评估代码
    activate evaluator_node
    Note right of evaluator_node: 执行所有单元测试...<br>测试 1-5 全部通过！
    evaluator_node-->>graph_p: 返回成功信息
    deactivate evaluator_node

    %% --- 流程结束 ---
    Note over graph_p: 条件判断 should_continue()<br>因测试成功, 决定结束流程
    graph_p-->>user_p: 返回最终结果
    deactivate graph_p</pre>

<p>时序图解读</p>
<ol>
<li><strong>启动与初次尝试</strong>:<ul>
<li>LangGraph 接收到用户实现“跳表”的复杂任务，启动流程。</li>
<li>它首先调用 Actor 节点。Actor 生成了第一版代码，但存在两个逻辑缺陷：<strong>init</strong> 没有默认参数，且空列表的 level 初始化为 1。</li>
</ul>
</li>
<li><strong>第一次反思循环</strong>:<ul>
<li>LangGraph 将第一版代码交给 Evaluator。</li>
<li>Evaluator 运行单元测试，立即在初始化阶段就失败了，因为它无法无参数地创建 SkipList 对象。它将这个明确的 TypeError 返回。</li>
<li>LangGraph 的 should_continue 判断检测到失败，将流程导向 Reflector。</li>
<li>Reflector 接收到失败的代码和错误日志，准确地分析出是构造函数参数问题，并提供了修正建议（添加默认参数）。</li>
</ul>
</li>
<li><strong>第二次反思循环</strong>:<ul>
<li>LangGraph 带着 Reflector 的宝贵建议，再次调用 Actor。</li>
<li>Actor 生成了第二版代码，这次解决了构造函数的问题。</li>
<li>代码再次被交给 Evaluator。这次初始化成功了，但倒在了第一个断言上：“空跳表的层级应为 0”。这是一个更细微的逻辑错误。</li>
<li>流程再次进入 Reflector。Reflector 基于新的错误，进一步反思，并指出了 level 初始化应为 0 的核心问题。</li>
</ul>
</li>
<li><strong>成功与结束</strong>:<ul>
<li>Actor 在第三次尝试中，吸收了前两次的所有经验，生成了逻辑正确的第三版代码。</li>
<li>Evaluator 这一次对第三版代码执行了全部 5 个测试用例，从基本结构、增、删、查到有序性验证，全部通过。</li>
<li>Evaluator 返回了一个成功的消息。</li>
<li>LangGraph 的 should_continue 判断检测到成功信号，将流程导向 END，整个任务圆满结束。</li>
</ul>
</li>
</ol>
<p><strong>引用文献</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.google.com/url?sa=E&q=https://arxiv.org/abs/2303.11366">Shinn, N., Cassano, F., Gopinath, A., Narasimhan, K., &amp; Yao, S. (2023). Reflexion: Language Agents with Verbal Reinforcement Learning.</a></li>
</ul>
<h2 id="6-ReWOO-Reasoning-WithOut-Observation"><a href="#6-ReWOO-Reasoning-WithOut-Observation" class="headerlink" title="6. ReWOO (Reasoning WithOut Observation)"></a>6. ReWOO (Reasoning WithOut Observation)</h2><h3 id="模式介绍-5"><a href="#模式介绍-5" class="headerlink" title="模式介绍:"></a><strong>模式介绍:</strong></h3><p>ReWOO 是一种旨在提高 Agent 效率的模式，它将推理过程与从工具中获取的“观察”分离。在 ReAct 等模式中，LLM 在每一步都需要等待工具的返回结果才能进行下一步的推理，这可能导致大量的 token 消耗和较高的延迟。<br>ReWOO 通过以下三个模块来解决这个问题：</p>
<ol>
<li><p><strong>Planner (规划器)</strong>: 接收任务后，一次性生成一个完整的计划，这个计划包含了所有需要的工具调用，但使用占位符（如 #E1, #E2）来表示工具的输出。</p>
</li>
<li><p><strong>Worker (工作者)</strong>: 负责执行计划中的所有工具调用，并将结果与对应的占位符关联起来。</p>
</li>
<li><p><strong>Solver (解决者)</strong>: 接收完整的计划和所有工具的执行结果，然后将结果替换掉计划中的占位符，最后生成最终的答案。</p>
</li>
</ol>
<p>通过这种方式，ReWOO 显著减少了 LLM 的调用次数，提高了 token 效率和执行速度，同时保持了清晰的推理流程。</p>
<pre class="mermaid">graph TD
    A[用户问题] --> B[Planner: 生成带占位符的完整计划];
    B --> C["计划: #E1=ToolA(...), #E2=ToolB(#E1)"];
    C --> D[Worker: 并行/串行执行所有工具调用];
    D --> E["收集所有工具结果 (E1, E2, ...)"];
    E --> F[Solver: 将结果替换到计划中];
    F --> G[生成最终答案];</pre>

<h3 id="Python代码案例-LangChain-1"><a href="#Python代码案例-LangChain-1" class="headerlink" title="Python代码案例 (LangChain):"></a><strong>Python代码案例 (LangChain):</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span>, TypedDict</span><br><span class="line"><span class="keyword">from</span> dotenv <span class="keyword">import</span> load_dotenv</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> langchain_community.tools.tavily_search <span class="keyword">import</span> TavilySearchResults</span><br><span class="line"><span class="keyword">from</span> langchain_core.output_parsers <span class="keyword">import</span> StrOutputParser</span><br><span class="line"><span class="keyword">from</span> langchain_core.prompts <span class="keyword">import</span> ChatPromptTemplate</span><br><span class="line"><span class="keyword">from</span> langchain_openai <span class="keyword">import</span> ChatOpenAI</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> langgraph.graph <span class="keyword">import</span> END, StateGraph</span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 配置区 ---</span></span><br><span class="line"><span class="comment"># 加载当前目录下的 .env 文件</span></span><br><span class="line">load_dotenv()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># =================================================================================</span></span><br><span class="line"><span class="comment"># 1. 定义图的状态 (Graph State)</span></span><br><span class="line"><span class="comment"># =================================================================================</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReWOOState</span>(<span class="title class_ inherited__">TypedDict</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    ReWOO 代理的状态</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    task: <span class="built_in">str</span></span><br><span class="line">    plan_string: <span class="built_in">str</span></span><br><span class="line">    steps: <span class="type">List</span>[<span class="built_in">dict</span>]</span><br><span class="line">    evidences: <span class="type">List</span>[<span class="built_in">tuple</span>]</span><br><span class="line">    response: <span class="built_in">str</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># =================================================================================</span></span><br><span class="line"><span class="comment"># 2. 定义工具 (Tools)</span></span><br><span class="line"><span class="comment"># =================================================================================</span></span><br><span class="line"><span class="comment"># Worker (执行器) 可以使用的工具。</span></span><br><span class="line"></span><br><span class="line">google_search = TavilySearchResults(max_results=<span class="number">2</span>)</span><br><span class="line">tools = &#123;</span><br><span class="line">    <span class="string">&quot;Google&quot;</span>: google_search.invoke,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># =================================================================================</span></span><br><span class="line"><span class="comment"># 3. 实现 Planner (规划器)</span></span><br><span class="line"><span class="comment"># =================================================================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化 LLM 模型</span></span><br><span class="line">llm = ChatOpenAI(model=<span class="string">&quot;gpt-4.1&quot;</span>, temperature=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># --- MODIFIED ---</span></span><br><span class="line"><span class="comment"># 更新了 Planner 的提示，引导它使用 Solver 来完成最终的计算和汇总任务。</span></span><br><span class="line">planner_prompt = ChatPromptTemplate.from_template(</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">针对以下任务，请制定能够分步骤解决问题的计划。</span></span><br><span class="line"><span class="string">对于每个计划，请按照以下格式进行描述：</span></span><br><span class="line"><span class="string">计划：对计划的简要描述。</span></span><br><span class="line"><span class="string">#E[步骤编号] = 工具[工具的参数]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">支持的工具如下：</span></span><br><span class="line"><span class="string">- Google[query]: 在网络上搜索查询内容。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">重要提示：</span></span><br><span class="line"><span class="string">计划的最后一步必须是 Solver。Solver 会接收之前所有步骤的证据（例如 #E1, #E2），并基于这些信息进行推理、计算，最终生成答案。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">这是一个示例：</span></span><br><span class="line"><span class="string">任务：美国现任总统是谁，他多大了？</span></span><br><span class="line"><span class="string">计划：查找美国现任总统。</span></span><br><span class="line"><span class="string">#E1 = Google[美国现任总统]</span></span><br><span class="line"><span class="string">计划：查找这位总统的年龄。</span></span><br><span class="line"><span class="string">#E2 = Google[#E1的年龄]</span></span><br><span class="line"><span class="string">计划：综合以上信息，回答用户的问题。</span></span><br><span class="line"><span class="string">#E3 = Solver[#E1, #E2]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">现在，请为以下任务制定计划。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">任务：&#123;task&#125;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">planner = planner_prompt | llm | StrOutputParser()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">planner_node</span>(<span class="params">state: ReWOOState</span>) -&gt; <span class="built_in">dict</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    接收任务并生成详细计划的节点。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    task = state[<span class="string">&quot;task&quot;</span>]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n--- [Planner Node] ---&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;  Input Task: <span class="subst">&#123;task&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    plan_string = planner.invoke(&#123;<span class="string">&quot;task&quot;</span>: task&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;  Output Plan:\n<span class="subst">&#123;plan_string.strip()&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;--- [Planner Node End] ---\n&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;plan_string&quot;</span>: plan_string&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># =================================================================================</span></span><br><span class="line"><span class="comment"># 4. 实现 Worker (执行器)</span></span><br><span class="line"><span class="comment"># =================================================================================</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">worker_node</span>(<span class="params">state: ReWOOState</span>) -&gt; <span class="built_in">dict</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    执行计划中的工具调用节点。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    plan_string = state[<span class="string">&quot;plan_string&quot;</span>]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n--- [Worker Node] ---&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;  Input Plan:\n<span class="subst">&#123;plan_string.strip()&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    steps = []</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> plan_string.strip().split(<span class="string">&quot;\n&quot;</span>):</span><br><span class="line">        <span class="keyword">if</span> line.startswith(<span class="string">&quot;计划：&quot;</span>):</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">match</span> = re.<span class="keyword">match</span>(<span class="string">r&quot;#E(\d+) = (\w+)\[(.+)\]&quot;</span>, line)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">match</span>:</span><br><span class="line">            step_num, tool, arg = <span class="keyword">match</span>.groups()</span><br><span class="line">            <span class="keyword">if</span> tool == <span class="string">&quot;Solver&quot;</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            steps.append(&#123;<span class="string">&quot;step_num&quot;</span>: <span class="built_in">int</span>(step_num), <span class="string">&quot;tool&quot;</span>: tool, <span class="string">&quot;arg&quot;</span>: arg&#125;)</span><br><span class="line"></span><br><span class="line">    evidences = []</span><br><span class="line">    <span class="keyword">for</span> step <span class="keyword">in</span> steps:</span><br><span class="line">        tool_name = step[<span class="string">&quot;tool&quot;</span>]</span><br><span class="line">        argument = step[<span class="string">&quot;arg&quot;</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 动态替换参数中的证据ID (例如, #E1)</span></span><br><span class="line">        placeholders = re.findall(<span class="string">r&quot;#E(\d+)&quot;</span>, argument)</span><br><span class="line">        <span class="keyword">if</span> placeholders:</span><br><span class="line">            <span class="keyword">for</span> p_num <span class="keyword">in</span> placeholders:</span><br><span class="line">                placeholder_tag = <span class="string">f&quot;#E<span class="subst">&#123;p_num&#125;</span>&quot;</span></span><br><span class="line">                <span class="keyword">for</span> num, evidence_text <span class="keyword">in</span> evidences:</span><br><span class="line">                    <span class="keyword">if</span> num == <span class="built_in">int</span>(p_num):</span><br><span class="line">                        <span class="comment"># 直接用完整的证据文本替换</span></span><br><span class="line">                        argument = argument.replace(placeholder_tag, evidence_text)</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;    - Executing: Step <span class="subst">&#123;step[<span class="string">&#x27;step_num&#x27;</span>]&#125;</span> | Tool: <span class="subst">&#123;tool_name&#125;</span> | Argument: &#x27;<span class="subst">&#123;argument&#125;</span>&#x27;&quot;</span>)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            result = tools[tool_name](argument)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">isinstance</span>(result, <span class="built_in">list</span>):</span><br><span class="line">                result_str = <span class="string">&quot;\n&quot;</span>.join([<span class="built_in">str</span>(r) <span class="keyword">for</span> r <span class="keyword">in</span> result])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                result_str = <span class="built_in">str</span>(result)</span><br><span class="line">            evidences.append((step[<span class="string">&quot;step_num&quot;</span>], result_str))</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;      &gt; Tool execution failed: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">            evidences.append((step[<span class="string">&quot;step_num&quot;</span>], <span class="string">f&quot;Error: <span class="subst">&#123;e&#125;</span>&quot;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n  Output Evidences:&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> evidence <span class="keyword">in</span> evidences:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;    - E<span class="subst">&#123;evidence[<span class="number">0</span>]&#125;</span>: <span class="subst">&#123;<span class="built_in">str</span>(evidence[<span class="number">1</span>])[:<span class="number">100</span>]&#125;</span>...&quot;</span>)  <span class="comment"># 打印部分证据内容</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;--- [Worker Node End] ---\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;steps&quot;</span>: steps, <span class="string">&quot;evidences&quot;</span>: evidences&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># =================================================================================</span></span><br><span class="line"><span class="comment"># 5. 实现 Solver (求解器)</span></span><br><span class="line"><span class="comment"># =================================================================================</span></span><br><span class="line">solver_prompt = ChatPromptTemplate.from_template(</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">解决以下任务或问题。为了解决问题，你将获得一个计划以及该计划的执行结果。</span></span><br><span class="line"><span class="string">你的答案应该完全基于执行结果。不要编造任何信息。</span></span><br><span class="line"><span class="string">请从执行结果中提取所需的数值信息，进行必要的计算，并提供一个全面、清晰、独立的最终答案。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">任务：&#123;task&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">计划：</span></span><br><span class="line"><span class="string">&#123;plan&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">执行结果：</span></span><br><span class="line"><span class="string">&#123;evidences&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">现在，请解决这个问题，并用中文回答。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">solver = solver_prompt | llm | StrOutputParser()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">solver_node</span>(<span class="params">state: ReWOOState</span>) -&gt; <span class="built_in">dict</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    综合所有信息生成最终答案的节点。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n--- [Solver Node] ---&quot;</span>)</span><br><span class="line"></span><br><span class="line">    plan_description = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> state[<span class="string">&quot;plan_string&quot;</span>].strip().split(<span class="string">&quot;\n&quot;</span>):</span><br><span class="line">        <span class="keyword">if</span> line.startswith(<span class="string">&quot;计划：&quot;</span>):</span><br><span class="line">            plan_description += line + <span class="string">&quot;\n&quot;</span></span><br><span class="line"></span><br><span class="line">    evidence_str = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> step_num, result <span class="keyword">in</span> state[<span class="string">&quot;evidences&quot;</span>]:</span><br><span class="line">        evidence_str += <span class="string">f&quot;#E<span class="subst">&#123;step_num&#125;</span> 的证据: <span class="subst">&#123;result&#125;</span>\n\n&quot;</span></span><br><span class="line"></span><br><span class="line">    solver_input_payload = &#123;</span><br><span class="line">        <span class="string">&quot;task&quot;</span>: state[<span class="string">&quot;task&quot;</span>],</span><br><span class="line">        <span class="string">&quot;plan&quot;</span>: plan_description,</span><br><span class="line">        <span class="string">&quot;evidences&quot;</span>: evidence_str,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;  Input to Solver LLM (Task, Plan, Evidences):&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;    Task: <span class="subst">&#123;solver_input_payload[<span class="string">&#x27;task&#x27;</span>]&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;    Plan: <span class="subst">&#123;solver_input_payload[<span class="string">&#x27;plan&#x27;</span>].strip()&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;    Evidences: <span class="subst">&#123;solver_input_payload[<span class="string">&#x27;evidences&#x27;</span>].strip()[:<span class="number">200</span>]&#125;</span>...&quot;</span>)</span><br><span class="line"></span><br><span class="line">    response = solver.invoke(solver_input_payload)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;\n  Output Response:\n<span class="subst">&#123;response&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;--- [Solver Node End] ---\n&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;response&quot;</span>: response&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># =================================================================================</span></span><br><span class="line"><span class="comment"># 6. 构建并运行 LangGraph</span></span><br><span class="line"><span class="comment"># =================================================================================</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;主函数，用于构建和运行 LangGraph 应用&quot;&quot;&quot;</span></span><br><span class="line">    graph = StateGraph(ReWOOState)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 替换 lambda 为具名函数，提高可读性</span></span><br><span class="line">    graph.add_node(<span class="string">&quot;planner&quot;</span>, planner_node)</span><br><span class="line">    graph.add_node(<span class="string">&quot;worker&quot;</span>, worker_node)</span><br><span class="line">    graph.add_node(<span class="string">&quot;solver&quot;</span>, solver_node)</span><br><span class="line"></span><br><span class="line">    graph.set_entry_point(<span class="string">&quot;planner&quot;</span>)</span><br><span class="line"></span><br><span class="line">    graph.add_edge(<span class="string">&quot;planner&quot;</span>, <span class="string">&quot;worker&quot;</span>)</span><br><span class="line">    graph.add_edge(<span class="string">&quot;worker&quot;</span>, <span class="string">&quot;solver&quot;</span>)</span><br><span class="line">    graph.add_edge(<span class="string">&quot;solver&quot;</span>, END)</span><br><span class="line"></span><br><span class="line">    app = graph.<span class="built_in">compile</span>()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 定义任务</span></span><br><span class="line">    task = <span class="string">&quot;求2024年中国北京、上海、广州、深圳的人口总和&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;开始执行 ReWOO 代理任务: &#x27;<span class="subst">&#123;task&#125;</span>&#x27;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 使用 invoke 执行，因为我们已经在节点内部添加了详细的日志</span></span><br><span class="line">    final_state = app.invoke(&#123;<span class="string">&quot;task&quot;</span>: task&#125;, config=&#123;<span class="string">&quot;recursion_limit&quot;</span>: <span class="number">5</span>&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n=================================&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;✅ 任务执行完毕 - 最终答案:&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;=================================&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(final_state[<span class="string">&quot;response&quot;</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<h3 id="输出：-4"><a href="#输出：-4" class="headerlink" title="输出："></a><strong>输出：</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">开始执行 ReWOO 代理任务: &#x27;求2024年中国北京、上海、广州、深圳的人口总和&#x27;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--- [Planner Node] ---</span><br><span class="line">  Input Task: 求2024年中国北京、上海、广州、深圳的人口总和</span><br><span class="line">  Output Plan:</span><br><span class="line">计划：查找2024年北京的人口数据。  </span><br><span class="line">#E1 = Google[2024年北京人口]</span><br><span class="line"></span><br><span class="line">计划：查找2024年上海的人口数据。  </span><br><span class="line">#E2 = Google[2024年上海人口]</span><br><span class="line"></span><br><span class="line">计划：查找2024年广州的人口数据。  </span><br><span class="line">#E3 = Google[2024年广州人口]</span><br><span class="line"></span><br><span class="line">计划：查找2024年深圳的人口数据。  </span><br><span class="line">#E4 = Google[2024年深圳人口]</span><br><span class="line"></span><br><span class="line">计划：将上述四个城市的人口数据相加，得出总和。  </span><br><span class="line">#E5 = Solver[#E1, #E2, #E3, #E4]</span><br><span class="line">--- [Planner Node End] ---</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--- [Worker Node] ---</span><br><span class="line">  Input Plan:</span><br><span class="line">计划：查找2024年北京的人口数据。  </span><br><span class="line">#E1 = Google[2024年北京人口]</span><br><span class="line"></span><br><span class="line">计划：查找2024年上海的人口数据。  </span><br><span class="line">#E2 = Google[2024年上海人口]</span><br><span class="line"></span><br><span class="line">计划：查找2024年广州的人口数据。  </span><br><span class="line">#E3 = Google[2024年广州人口]</span><br><span class="line"></span><br><span class="line">计划：查找2024年深圳的人口数据。  </span><br><span class="line">#E4 = Google[2024年深圳人口]</span><br><span class="line"></span><br><span class="line">计划：将上述四个城市的人口数据相加，得出总和。  </span><br><span class="line">#E5 = Solver[#E1, #E2, #E3, #E4]</span><br><span class="line">    - Executing: Step 1 | Tool: Google | Argument: &#x27;2024年北京人口&#x27;</span><br><span class="line">    - Executing: Step 2 | Tool: Google | Argument: &#x27;2024年上海人口&#x27;</span><br><span class="line">    - Executing: Step 3 | Tool: Google | Argument: &#x27;2024年广州人口&#x27;</span><br><span class="line">    - Executing: Step 4 | Tool: Google | Argument: &#x27;2024年深圳人口&#x27;</span><br><span class="line"></span><br><span class="line">  Output Evidences:</span><br><span class="line">    - E1: &#123;&#x27;title&#x27;: &#x27;人口_首都之窗 - 北京市人民政府&#x27;, &#x27;url&#x27;: &#x27;https://www.beijing.gov.cn/renwen/bjgk/rk/202503/t20250325_40...</span><br><span class="line">    - E2: &#123;&#x27;title&#x27;: &#x27;2024年上海常住人口2480.26万人，新增就业人数62.17万人&#x27;, &#x27;url&#x27;: &#x27;https://wap.51ldb.com/shsldb/ms/content/0195...</span><br><span class="line">    - E3: &#123;&#x27;title&#x27;: &#x27;2024年广州常住人口1897.8万，城镇化率提升至87.24%&#x27;, &#x27;url&#x27;: &#x27;http://m.fangchan.com/news/218/2025-03-31/7312...</span><br><span class="line">    - E4: &#123;&#x27;title&#x27;: &#x27;15座万亿城市2024年人口数据：深圳增量第一 - 新浪财经&#x27;, &#x27;url&#x27;: &#x27;https://finance.sina.com.cn/roll/2025-03-31/doc-...</span><br><span class="line">--- [Worker Node End] ---</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--- [Solver Node] ---</span><br><span class="line">  Input to Solver LLM (Task, Plan, Evidences):</span><br><span class="line">    Task: 求2024年中国北京、上海、广州、深圳的人口总和</span><br><span class="line">    Plan: 计划：查找2024年北京的人口数据。  </span><br><span class="line">计划：查找2024年上海的人口数据。  </span><br><span class="line">计划：查找2024年广州的人口数据。  </span><br><span class="line">计划：查找2024年深圳的人口数据。  </span><br><span class="line">计划：将上述四个城市的人口数据相加，得出总和。</span><br><span class="line">    Evidences: #E1 的证据: &#123;&#x27;title&#x27;: &#x27;人口_首都之窗 - 北京市人民政府&#x27;, &#x27;url&#x27;: &#x27;https://www.beijing.gov.cn/renwen/bjgk/rk/202503/t20250325_4043973.html&#x27;, &#x27;content&#x27;: &#x27;无障碍繁体/简体智能问答\n\n我在听，请说话(10s)\n\n抱歉，没听清，请再说一遍吧\n\n人文北京\u3000&gt;\u3000...</span><br><span class="line"></span><br><span class="line">  Output Response:</span><br><span class="line">根据执行结果，2024年中国北京、上海、广州、深圳的人口数据如下：</span><br><span class="line"></span><br><span class="line">1. 北京：2183.2万人  </span><br><span class="line">2. 上海：2480.26万人  </span><br><span class="line">3. 广州：1897.8万人  </span><br><span class="line">4. 深圳：1798.95万人  </span><br><span class="line"></span><br><span class="line">将四个城市的人口相加：</span><br><span class="line"></span><br><span class="line">2183.2 + 2480.26 + 1897.8 + 1798.95 = 8359.21万人</span><br><span class="line"></span><br><span class="line">**最终答案：**</span><br><span class="line"></span><br><span class="line">2024年中国北京、上海、广州、深圳的人口总和为**8359.21万人**。</span><br><span class="line">--- [Solver Node End] ---</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">=================================</span><br><span class="line">✅ 任务执行完毕 - 最终答案:</span><br><span class="line">=================================</span><br><span class="line">根据执行结果，2024年中国北京、上海、广州、深圳的人口数据如下：</span><br><span class="line"></span><br><span class="line">1. 北京：2183.2万人  </span><br><span class="line">2. 上海：2480.26万人  </span><br><span class="line">3. 广州：1897.8万人  </span><br><span class="line">4. 深圳：1798.95万人  </span><br><span class="line"></span><br><span class="line">将四个城市的人口相加：</span><br><span class="line"></span><br><span class="line">2183.2 + 2480.26 + 1897.8 + 1798.95 = 8359.21万人</span><br><span class="line"></span><br><span class="line">**最终答案：**</span><br><span class="line"></span><br><span class="line">2024年中国北京、上海、广州、深圳的人口总和为**8359.21万人**。</span><br></pre></td></tr></table></figure>

<h3 id="代码整体流程：-5"><a href="#代码整体流程：-5" class="headerlink" title="代码整体流程："></a><strong>代码整体流程：</strong></h3><pre class="mermaid">sequenceDiagram
    participant User
    participant Main App
    participant Planner Node
    participant Worker Node
    participant Google Tool
    participant Solver Node
    participant LLM (gpt-4.1)

    User->>Main App: 提交任务: "求2024年..."
    Main App->>Planner Node: 调用图入口 (invoke)

    %% Planner 阶段: 制定计划
    Planner Node->>LLM (gpt-4.1): 发送任务和 planner_prompt
    LLM (gpt-4.1)-->>Planner Node: 返回计划字符串 (Plan String)
    Note over Planner Node: Plan: #E1=Google, #E2=Google... #E5=Solver
    Planner Node-->>Main App: 更新状态 (State)

    %% Worker 阶段: 执行工具
    Main App->>Worker Node: 传递 Plan String
    Worker Node->>Worker Node: 解析计划, 识别 E1-E4 工具调用
    
    Worker Node->>Google Tool: 执行 #E1: Google[2024年北京人口]
    Google Tool-->>Worker Node: 返回北京人口证据 (Evidence #E1)
    
    Worker Node->>Google Tool: 执行 #E2: Google[2024年上海人口]
    Google Tool-->>Worker Node: 返回上海人口证据 (Evidence #E2)
    
    Worker Node->>Google Tool: 执行 #E3: Google[2024年广州人口]
    Google Tool-->>Worker Node: 返回广州人口证据 (Evidence #E3)

    Worker Node->>Google Tool: 执行 #E4: Google[2024年深圳人口]
    Google Tool-->>Worker Node: 返回深圳人口证据 (Evidence #E4)

    Note over Worker Node: 收集所有证据, 忽略 Solver 步骤
    Worker Node-->>Main App: 更新状态 (State) with Evidences

    %% Solver 阶段: 综合信息并回答
    Main App->>Solver Node: 传递任务, 计划和所有证据
    Solver Node->>LLM (gpt-4.1): 发送 solver_prompt (包含所有信息)
    Note over LLM (gpt-4.1): LLM 内部进行: <br/>1. 从证据中提取数字 <br/>2. 计算总和 <br/>3. 格式化最终答案
    LLM (gpt-4.1)-->>Solver Node: 返回最终答案 (Response)
    Solver Node-->>Main App: 更新状态 (State) with Response

    %% 结束
    Main App-->>User: 打印最终答案: "总和为 8359.21万人"</pre>

<p>这个图清晰地展示了从用户任务输入开始，经过<strong>规划（Planner）</strong>、<strong>执行（Worker）</strong> 和 <strong>求解（Solver）</strong> 三个核心阶段，最终得出答案的全过程。</p>
<p>时序图解读</p>
<ol>
<li><strong>启动</strong>：用户通过 Main App 提交一个复杂的任务。</li>
<li><strong>规划 (Planner)</strong>：Planner Node 调用大语言模型（LLM）将任务分解成一个详细的、可执行的计划。这个计划明确了需要调用哪些工具（4次 Google 搜索）以及最后如何整合信息（使用 Solver）。</li>
<li><strong>执行 (Worker)</strong>：Worker Node 像一个勤奋的工人，严格按照计划执行每一步。它依次调用 Google Tool，收集所有必要的信息片段（即“证据”），但它并不知道如何使用这些信息，只是忠实地完成数据搜集工作。</li>
<li><strong>求解 (Solver)</strong>：Solver Node 扮演着“大脑”的角色。它接收到原始任务、完整的计划以及 Worker 搜集到的所有零散证据。它再次调用 LLM，要求它基于所有已知信息，进行最终的<strong>综合、推理、计算</strong>，并生成一个人类可读的、完整的最终答案。</li>
<li><strong>完成</strong>：Main App 将 Solver 生成的最终答案呈现给用户，任务结束。</li>
</ol>
<p>这个流程完美地体现了 ReWOO 架构“<strong>推理-规划-执行-求解</strong>”的核心思想，将复杂的任务拆解，并通过专门的“大脑”（Solver&#x2F;LLM）来整合结果，从而解决了最初 Calculator 工具因无法理解上下文而出错的问题。</p>
<p><strong>引用文献</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.google.com/url?sa=E&q=https://arxiv.org/abs/2305.18323">Xu, C., Yao, S., Gao, T., Duan, T., &amp; Narasimhan, K. (2023). ReWOO: Decoupling Reasoning from Observations for Efficient Augmented Language Models.</a></li>
</ul>
<h2 id="7-Multi-Agent-Architectures"><a href="#7-Multi-Agent-Architectures" class="headerlink" title="7. Multi-Agent Architectures"></a>7. Multi-Agent Architectures</h2><h3 id="模式介绍-6"><a href="#模式介绍-6" class="headerlink" title="模式介绍:"></a><strong>模式介绍:</strong></h3><p>多智能体架构通过让多个独立的、具有特定角色的 Agent 协同工作来解决单个 Agent 难以处理的复杂问题。这种模式的核心思想是“分而治之”，将一个庞大的任务分解给不同的专家 Agent，每个 Agent 负责其擅长的领域，并通过相互通信来协作完成共同的目标。</p>
<p>常见的多智能体架构包括：<br>层级结构 (Hierarchical): 一个“管理者” Agent 负责分解任务和协调，并将子任务分配给下属的“专家” Agent。</p>
<ul>
<li>网络结构 (Network): 所有 Agent 都是平等的，它们可以自由地相互通信和协作。</li>
<li>顺序结构 (Sequential): 任务在一个 Agent 链中按顺序传递，每个 Agent 完成自己的部分后再交给下一个。</li>
</ul>
<p>像 Microsoft 的 AutoGen 这样的框架，就是专门为构建和协调多智能体应用而设计的，它通过自动化的 Agent 间对话来简化复杂工作流的编排。</p>
<pre class="mermaid">graph TD
    A[用户请求] --> B[管理者 Agent];
    B --> C{任务分解与规划};
    C --> D[分配任务给专家 Agent A];
    C --> E[分配任务给专家 Agent B];
    D --> F[专家 A 执行任务];
    E --> G[专家 B 执行任务];
    F --> H[返回结果给管理者];
    G --> H;
    H --> I{整合结果};
    I --> J[生成最终解决方案];</pre>



<h3 id="Python代码案例-AutoGen"><a href="#Python代码案例-AutoGen" class="headerlink" title="Python代码案例 (AutoGen ):"></a><strong>Python代码案例 (AutoGen ):</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> autogen</span><br><span class="line"><span class="keyword">from</span> dotenv <span class="keyword">import</span> load_dotenv</span><br><span class="line"></span><br><span class="line">load_dotenv()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从 .env 文件加载配置</span></span><br><span class="line"></span><br><span class="line">config_list = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;model&quot;</span>: <span class="string">&quot;gpt-4.1&quot;</span>,</span><br><span class="line">        <span class="string">&quot;api_key&quot;</span>: os.environ.get(<span class="string">&quot;OPENAI_API_KEY&quot;</span>),</span><br><span class="line">        <span class="string">&quot;base_url&quot;</span>: os.environ.get(<span class="string">&quot;OPENAI_BASE_URL&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置大语言模型（LLM）</span></span><br><span class="line"><span class="comment"># 将上面创建的配置列表传递给 llm_config</span></span><br><span class="line">llm_config = &#123;</span><br><span class="line">    <span class="string">&quot;config_list&quot;</span>: config_list,</span><br><span class="line">    <span class="string">&quot;cache_seed&quot;</span>: <span class="number">42</span>,  <span class="comment"># 使用种子以保证结果的可复现性</span></span><br><span class="line">    <span class="string">&quot;timeout&quot;</span>: <span class="number">600</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建助理代理 (AssistantAgent)</span></span><br><span class="line"><span class="comment"># 这个代理负责根据指令生成代码</span></span><br><span class="line">assistant = autogen.AssistantAgent(</span><br><span class="line">    name=<span class="string">&quot;assistant&quot;</span>,</span><br><span class="line">    llm_config=llm_config,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建用户代理 (UserProxyAgent)</span></span><br><span class="line"><span class="comment"># 这个代理代表用户，并负责执行代码</span></span><br><span class="line">user_proxy = autogen.UserProxyAgent(</span><br><span class="line">    name=<span class="string">&quot;user_proxy&quot;</span>,</span><br><span class="line">    human_input_mode=<span class="string">&quot;NEVER&quot;</span>,  <span class="comment"># 在这个例子中不寻求人类输入</span></span><br><span class="line">    max_consecutive_auto_reply=<span class="number">10</span>,</span><br><span class="line">    is_termination_msg=<span class="keyword">lambda</span> x: x.get(<span class="string">&quot;content&quot;</span>, <span class="string">&quot;&quot;</span>).rstrip().endswith(<span class="string">&quot;TERMINATE&quot;</span>),</span><br><span class="line">    code_execution_config=&#123;</span><br><span class="line">        <span class="string">&quot;work_dir&quot;</span>: <span class="string">&quot;coding&quot;</span>,  <span class="comment"># 代码将在此目录下执行</span></span><br><span class="line">        <span class="string">&quot;use_docker&quot;</span>: <span class="literal">False</span>,  <span class="comment"># 设置为 False 以在本地环境执行。官方建议在 Docker 容器中执行以确保安全。</span></span><br><span class="line">    &#125;,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发起对话</span></span><br><span class="line"><span class="comment"># 用户代理向助理代理发起一个任务</span></span><br><span class="line">user_proxy.initiate_chat(</span><br><span class="line">    assistant,</span><br><span class="line">    message=<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    今天日期是什么？对比一下 META 和 NVDA 从年初至今的股价表现，并用图表展示出来。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    重要提示：在使用 matplotlib 绘图时，为了正确显示中文，请务必在你的 Python 代码中加入以下两行配置：</span></span><br><span class="line"><span class="string">    import matplotlib.pyplot as plt</span></span><br><span class="line"><span class="string">    plt.rcParams[&#x27;font.sans-serif&#x27;] = [&#x27;SimHei&#x27;]</span></span><br><span class="line"><span class="string">    plt.rcParams[&#x27;axes.unicode_minus&#x27;] = False</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    图表的标题应为“META vs NVDA 股价走势”，X轴标签为“日期”，Y轴标签为“收盘价”。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="输出：-5"><a href="#输出：-5" class="headerlink" title="输出："></a><strong>输出：</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">user_proxy (to assistant):</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    今天日期是什么？对比一下 META 和 NVDA 从年初至今的股价表现，并用图表展示出来。</span><br><span class="line">    </span><br><span class="line">    重要提示：在使用 matplotlib 绘图时，为了正确显示中文，请务必在你的 Python 代码中加入以下两行配置：</span><br><span class="line">    import matplotlib.pyplot as plt</span><br><span class="line">    plt.rcParams[&#x27;font.sans-serif&#x27;] = [&#x27;SimHei&#x27;]</span><br><span class="line">    plt.rcParams[&#x27;axes.unicode_minus&#x27;] = False</span><br><span class="line">    </span><br><span class="line">    图表的标题应为“META vs NVDA 股价走势”，X轴标签为“日期”，Y轴标签为“收盘价”。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">assistant (to user_proxy):</span><br><span class="line"></span><br><span class="line">计划：</span><br><span class="line"></span><br><span class="line">1. 首先获取今天的日期，作为查询时间范围的结束日期。</span><br><span class="line">2. 从年初（1月1日）到今天，分别下载 META 和 NVDA 的每日收盘价。</span><br><span class="line">3. 使用 matplotlib 绘制收盘价对比走势图，并设置中文字体与标题。</span><br><span class="line">4. 显示图表。</span><br><span class="line"></span><br><span class="line">下面是完整代码：</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">import datetime</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">import pandas as pd</span><br><span class="line">import yfinance as yf</span><br><span class="line"></span><br><span class="line"># 保证中文显示</span><br><span class="line">plt.rcParams[&#x27;font.sans-serif&#x27;] = [&#x27;SimHei&#x27;]</span><br><span class="line">plt.rcParams[&#x27;axes.unicode_minus&#x27;] = False</span><br><span class="line"></span><br><span class="line"># 第一步：获取今天日期</span><br><span class="line">today = datetime.date.today()</span><br><span class="line">print(&quot;今天日期是：&quot;, today)</span><br><span class="line"></span><br><span class="line"># 第二步：设置起止日期</span><br><span class="line">start_date = datetime.date(today.year, 1, 1)</span><br><span class="line">end_date = today</span><br><span class="line"></span><br><span class="line"># 下载META和NVDA的收盘价</span><br><span class="line">meta = yf.download(&#x27;META&#x27;, start=start_date, end=end_date)</span><br><span class="line">nvda = yf.download(&#x27;NVDA&#x27;, start=start_date, end=end_date)</span><br><span class="line"></span><br><span class="line"># 整理收盘价数据</span><br><span class="line">meta_close = meta[&#x27;Close&#x27;]</span><br><span class="line">nvda_close = nvda[&#x27;Close&#x27;]</span><br><span class="line"></span><br><span class="line"># 第三步：绘制对比图</span><br><span class="line">plt.figure(figsize=(12,6))</span><br><span class="line">plt.plot(meta_close.index, meta_close.values, label=&#x27;META&#x27;)</span><br><span class="line">plt.plot(nvda_close.index, nvda_close.values, label=&#x27;NVDA&#x27;)</span><br><span class="line">plt.title(&#x27;META vs NVDA 股价走势&#x27;)</span><br><span class="line">plt.xlabel(&#x27;日期&#x27;)</span><br><span class="line">plt.ylabel(&#x27;收盘价&#x27;)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.tight_layout()</span><br><span class="line">plt.show()</span><br><span class="line">```</span><br><span class="line">请执行上述代码，输出结果并观察图表。</span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; EXECUTING CODE BLOCK 0 (inferred language is python)...</span><br><span class="line">user_proxy (to assistant):</span><br><span class="line"></span><br><span class="line">exitcode: 0 (execution succeeded)</span><br><span class="line">Code output: </span><br><span class="line">今天日期是： 2025-09-07</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">assistant (to user_proxy):</span><br><span class="line"></span><br><span class="line">已确认今天的日期为 2025-09-07。接下来，根据这个日期，刚刚输出的代码已经完成了所有后续步骤——包括数据下载和图表绘制。因此，您应该已能在屏幕上看到“META vs NVDA 股价走势”的对比走势图。</span><br><span class="line"></span><br><span class="line">两个股票（META和NVDA）从2025年初至今（2025-09-07）的收盘价随时间变化已绘制出来。</span><br><span class="line">- X轴为日期（2025年1月1日至2025年9月7日）</span><br><span class="line">- Y轴为收盘价</span><br><span class="line">- 图表标题为“META vs NVDA 股价走势”</span><br><span class="line">- 曲线分别为META与NVDA</span><br><span class="line"></span><br><span class="line">如果您已看到图表，任务圆满完成；如需进一步分析或保存图片，请告知。</span><br><span class="line"></span><br><span class="line">TERMINATE</span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; TERMINATING RUN (26556eb2-20f6-485e-997d-bba9cae76705): Termination message condition on agent &#x27;user_proxy&#x27; met</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2025/09/05/agent%E6%80%9D%E7%BB%B4%E6%A8%A1%E5%BC%8F%E4%BB%8B%E7%BB%8D/image-20250907172428203.png" alt="image-20250907172428203"></p>
<h3 id="代码整体流程：-6"><a href="#代码整体流程：-6" class="headerlink" title="代码整体流程："></a><strong>代码整体流程：</strong></h3><pre class="mermaid">sequenceDiagram
    %% 1. 定义参与者，使用唯一的、非关键字的ID
    participant user_p as 用户 (运行脚本)
    participant proxy_p as 用户代理 (UserProxyAgent)
    participant assistant_p as 助理代理 (AssistantAgent)
    participant llm_p as LLM (gpt-4.1)
    participant env_p as 本地执行环境
    participant api_p as Yahoo Finance API

    %% --- 流程开始 ---
    user_p->>proxy_p: 调用 .initiate_chat() 发起任务
    activate proxy_p
    proxy_p->>assistant_p: 发送初始任务消息
    activate assistant_p

    %% --- 2. 助理代理进行规划和编码 ---
    Note over assistant_p: 接收任务, 需要思考和生成代码
    assistant_p->>llm_p: 请求规划和Python代码
    activate llm_p
    llm_p-->>assistant_p: 返回计划和完整的Python脚本
    deactivate llm_p
    
    assistant_p-->>proxy_p: 回复消息 (内含Python代码块)
    deactivate assistant_p

    %% --- 3. 用户代理执行代码 ---
    Note over proxy_p: 收到消息, 检测到可执行的代码块
    proxy_p->>env_p: 执行收到的Python脚本
    activate env_p
    
    Note over env_p: 脚本开始运行...
    env_p->>env_p: 打印当前日期
    env_p->>api_p: 调用 yfinance.download() 获取股价
    activate api_p
    api_p-->>env_p: 返回 META 和 NVDA 的股价数据
    deactivate api_p
    
    Note over env_p: 使用 matplotlib 绘制图表<br>(图表窗口在用户屏幕上弹出)
    env_p-->>proxy_p: 返回执行结果 (exitcode: 0, stdout: "今天日期是...")
    deactivate env_p

    %% --- 4. 反馈与总结 ---
    proxy_p->>assistant_p: 发送执行结果 (成功代码和输出)
    activate assistant_p
    
    Note over assistant_p: 接收到成功执行的反馈, 需要总结
    assistant_p->>llm_p: 请求基于成功结果进行总结
    activate llm_p
    llm_p-->>assistant_p: 返回总结性文本和 "TERMINATE" 信号
    deactivate llm_p

    assistant_p-->>proxy_p: 回复最终总结, 并以 "TERMINATE" 结尾
    deactivate assistant_p

    %% --- 流程结束 ---
    Note over proxy_p: 收到消息, 检测到 "TERMINATE" 关键词<br>匹配 is_termination_msg 条件, 结束对话
    proxy_p-->>user_p: 对话结束, 任务完成
    deactivate proxy_p</pre>

<p>Multi-Agent 流程时序图 (Mermaid)</p>
<p>这张图清晰地展示了两个智能体如何分工协作：</p>
<ul>
<li><strong>AssistantAgent</strong> 扮演<strong>规划者和程序员</strong>的角色，负责理解任务并生成可执行的代码。</li>
<li><strong>UserProxyAgent</strong> 扮演<strong>执行者和验证者</strong>的角色，负责运行代码、反馈结果，并最终决定任务是否完成。</li>
</ul>
<p>时序图解读</p>
<ol>
<li><strong>任务发起 (Initiation)</strong>:<ul>
<li>用户运行 Python 脚本，UserProxyAgent (用户代理) 被激活，并根据指令向 AssistantAgent (助理代理) 发送了第一个包含复杂任务的消息。</li>
</ul>
</li>
<li><strong>规划与编码 (Planning &amp; Coding)</strong>:<ul>
<li>AssistantAgent 接收到任务后，它并不直接行动，而是首先与 LLM 沟通。</li>
<li>它请求 LLM 将用户的自然语言任务分解成一个清晰的计划，并基于该计划生成一个完整的、可执行的 Python 脚本。</li>
<li>AssistantAgent 将这个包含代码的完整回复发送回 UserProxyAgent。</li>
</ul>
</li>
<li><strong>执行与交互 (Execution &amp; Interaction)</strong>:<ul>
<li>UserProxyAgent 收到回复后，其内置的机制检测到了一个 Python 代码块。</li>
<li>它<strong>自动地</strong>将这段代码在指定的 本地执行环境 中运行。</li>
<li>在执行期间，该脚本与外部的 Yahoo Finance API 进行了交互来获取数据，并在用户的屏幕上弹出了一个 Matplotlib 图表。</li>
<li>执行完毕后，本地执行环境 将执行结果（包括退出码 exitcode: 0 和标准输出 stdout）返回给 UserProxyAgent。</li>
</ul>
</li>
<li><strong>反馈与终止 (Feedback &amp; Termination)</strong>:<ul>
<li>UserProxyAgent 将代码的执行结果作为新的消息，反馈给 AssistantAgent。</li>
<li>AssistantAgent 接收到“执行成功”的反馈后，再次与 LLM 沟通，生成一段总结性的文字，确认任务已经完成，并在消息的末尾附上了关键词 TERMINATE。</li>
<li>当 UserProxyAgent 收到这条包含 TERMINATE 的消息时，它匹配了预设的 is_termination_msg 规则，从而<strong>自动终止了整个对话</strong>，标志着任务的圆满完成。</li>
</ul>
</li>
</ol>
<p>这个流程完美地展示了多智能体架构的优势：通过角色分离，一个智能体（助理）专注于高级的推理和规划，而另一个智能体（用户代理）则专注于与环境的实际交互和执行，它们通过对话驱动，高效地解决了单个智能体难以处理的复合型任务。</p>
<p><strong>引用文献</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.google.com/url?sa=E&q=https://arxiv.org/abs/2308.08155">Wu, Q., et al. (2023). AutoGen: Enabling Next-Gen LLM Applications via Multi-Agent Conversation Framework.</a></li>
<li><a target="_blank" rel="noopener" href="https://www.google.com/url?sa=E&q=https://www.smythos.com/blog/multi-agent-system-architecture">SmythOS Blog: Multi-Agent System Architecture</a></li>
</ul>
<h2 id="8-总结："><a href="#8-总结：" class="headerlink" title="8. 总结："></a>8. 总结：</h2><h3 id="核心模式对比总览表"><a href="#核心模式对比总览表" class="headerlink" title="核心模式对比总览表"></a>核心模式对比总览表</h3><table>
<thead>
<tr>
<th align="left">模式 (Pattern)</th>
<th align="left">核心思想 (Core Idea)</th>
<th align="left">优点 (Advantages)</th>
<th align="left">适用场景 (Use Cases)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>Chain-of-Thought (CoT)</strong></td>
<td align="left"><strong>循序渐进的推理</strong>。通过引导 LLM “一步一步地思考”，将复杂问题分解为中间推理步骤。</td>
<td align="left">简单有效，显著提升复杂任务的准确性，推理过程透明可解释。</td>
<td align="left"><strong>基础推理</strong>。数学题、逻辑谜题、需要多步推导才能得出结论的问答。</td>
</tr>
<tr>
<td align="left"><strong>Self-Ask</strong></td>
<td align="left"><strong>自我提问与解答</strong>。在 CoT 基础上，将问题显式地分解为一系列后续子问题，并调用工具寻找答案。</td>
<td align="left">结构化推理过程，每一步都有明确的子目标和可验证的答案，可靠性高。</td>
<td align="left"><strong>多跳（Multi-hop）事实问答</strong>。需要连续查找多个关联信息才能回答的复杂问题。</td>
</tr>
<tr>
<td align="left"><strong>ReAct</strong></td>
<td align="left"><strong>思考与行动的交错循环</strong>。在一个“思考→行动→观察”的循环中，动态地决定下一步，并与外部工具交互。</td>
<td align="left"><strong>高度灵活和适应性强</strong>，能处理动态变化和不确定的任务，是通用 Agent 的经典模式。</td>
<td align="left"><strong>通用和探索性任务</strong>。需要与环境（如网页、API）持续交互，且下一步不确定的任务。</td>
</tr>
<tr>
<td align="left"><strong>Plan-and-Execute</strong></td>
<td align="left"><strong>先规划，后执行</strong>。首先由一个“规划器”制定出完整的、多步骤的计划，然后由一个“执行器”逐一完成。</td>
<td align="left">结构化、可预测，LLM 调用次数少，<strong>成本和延迟较低</strong>，适合长期任务。</td>
<td align="left"><strong>结构化和可预测的复杂项目</strong>。如“写一份市场分析报告”、“规划一次旅行”等目标明确的任务。</td>
</tr>
<tr>
<td align="left"><strong>ReWOO</strong></td>
<td align="left"><strong>解耦推理与观察</strong>。Planner 一次性生成带占位符的计划，Worker 并行执行所有工具，Solver 最后整合信息。</td>
<td align="left"><strong>高效、快速、可并行</strong>，显著减少 LLM 调用次数和等待时间，Token 效率高。</td>
<td align="left"><strong>效率至上的信息整合任务</strong>。需要从多个独立来源收集信息并最终汇总的任务。</td>
</tr>
<tr>
<td align="left"><strong>Reflexion</strong></td>
<td align="left"><strong>通过自我反思进行迭代改进</strong>。Agent 在一次尝试失败后，会评估结果、反思错误，并将经验用于下一次尝试。</td>
<td align="left"><strong>具备从失败中学习的能力</strong>，能解决需要试错和逐步优化的复杂问题。</td>
<td align="left"><strong>需要试错和优化的任务</strong>。代码生成与调试、创意写作、复杂的科学问题求解。</td>
</tr>
<tr>
<td align="left"><strong>Multi-Agent Architectures</strong></td>
<td align="left"><strong>分工协作的专家团队</strong>。将一个复杂任务分解给多个具有不同角色和能力的 Agent，通过对话协同完成。</td>
<td align="left"><strong>能解决单个 Agent 无法处理的极其复杂的问题</strong>，通过分工和多视角提升解决方案的质量和鲁棒性。</td>
<td align="left"><strong>大规模和多领域的复杂项目</strong>。软件开发、商业流程自动化、科学研究、复杂系统模拟。</td>
</tr>
</tbody></table>
<hr>
<h3 id="综合对比与分析"><a href="#综合对比与分析" class="headerlink" title="综合对比与分析"></a>综合对比与分析</h3><p>这些模式并非完全独立，而是呈现出一种演进和互补的关系。</p>
<h4 id="1-从简单推理到复杂交互"><a href="#1-从简单推理到复杂交互" class="headerlink" title="1. 从简单推理到复杂交互"></a>1. 从简单推理到复杂交互</h4><ul>
<li><strong>Chain-of-Thought</strong> 是最基础的“思维”增强技术，它只发生在 LLM 内部，不与外部世界交互。</li>
<li><strong>Self-Ask</strong> 和 <strong>ReAct</strong> 在 CoT 的基础上迈出了一大步，它们引入了<strong>行动（Action）</strong>，让 Agent 能够使用工具与外部环境交互。<ul>
<li><strong>Self-Ask</strong> 的行动更具结构性，以“一问一答”的形式推进。</li>
<li><strong>ReAct</strong> 则更加灵活，它的“思考”更加自由，可以决定任何下一步的行动，适应性更强。</li>
</ul>
</li>
</ul>
<h4 id="2-规划策略的对决：动态适应-vs-预先规划"><a href="#2-规划策略的对决：动态适应-vs-预先规划" class="headerlink" title="2. 规划策略的对决：动态适应 vs. 预先规划"></a>2. 规划策略的对决：动态适应 vs. 预先规划</h4><p>这是 Agent 设计中的一个核心权衡点。</p>
<ul>
<li><p><strong>ReAct (动态适应)</strong>:</p>
<ul>
<li><strong>对比 Plan-and-Execute</strong>: ReAct 在每一步都重新评估情况，非常灵活，但代价是频繁调用 LLM，导致速度慢、成本高。它就像一个边走边看地图的探险家。</li>
<li><strong>对比 ReWOO</strong>: ReAct 是串行的“思考-行动”循环，而 ReWOO 通过解耦实现了并行，效率远高于 ReAct。</li>
</ul>
</li>
<li><p><strong>Plan-and-Execute (预先规划)</strong>:</p>
<ul>
<li><strong>对比 ReAct</strong>: 它的优点是结构清晰、成本低。但最大的缺点是<strong>僵化</strong>，一旦计划中的某一步出错或外部环境变化，它很难适应，可能导致整个任务失败。它就像一个严格按照预设食谱做菜的厨师。</li>
</ul>
</li>
<li><p><strong>ReWOO (效率优化)</strong>:</p>
<ul>
<li>可以看作是 <strong>Plan-and-Execute</strong> 的一个变种，但它通过占位符的设计，使得规划和执行的结合更加高效。它解决了 Plan-and-Execute 的部分僵化问题，因为最后的 Solver 可以在看到所有证据后进行智能整合，甚至纠正 Worker 的小错误。</li>
</ul>
</li>
</ul>
<h4 id="3-是否具备学习能力"><a href="#3-是否具备学习能力" class="headerlink" title="3. 是否具备学习能力"></a>3. 是否具备学习能力</h4><ul>
<li><strong>Reflexion</strong> 是这里唯一一个明确引入了**“从经验中学习”**机制的模式。<ul>
<li><strong>对比其他所有模式</strong>: ReAct, ReWOO 等模式如果在一个任务中失败了，它们只能中止。而 Reflexion 失败后会进入一个“反思”阶段，生成宝贵的经验，用于指导下一次<strong>全新的尝试</strong>。这使得它在处理需要反复试错才能找到最优解的问题时，具有无与伦比的优势。</li>
</ul>
</li>
</ul>
<h4 id="4-复杂度的维度：个体-vs-团队"><a href="#4-复杂度的维度：个体-vs-团队" class="headerlink" title="4. 复杂度的维度：个体 vs. 团队"></a>4. 复杂度的维度：个体 vs. 团队</h4><ul>
<li><strong>Multi-Agent Architectures</strong> 将问题解决的范式从“单个超级英雄”提升到了“一支专家团队”。<ul>
<li><strong>对比所有单 Agent 模式</strong>: 当任务的复杂度、所需知识领域的广度、或者需要内部审查和批判性思维的程度，超过了单个 Agent 的能力上限时，多智能体架构就成了必然选择。例如，你可以组建一个团队：一个 <code>Plan-and-Execute</code> 模式的<strong>项目经理 Agent</strong>，一个 <code>ReAct</code> 模式的<strong>研究员 Agent</strong>，和一个 <code>Reflexion</code> 模式的<strong>程序员 Agent</strong>，它们各司其职，通过对话协作完成一个软件开发项目。</li>
</ul>
</li>
</ul>
<h3 id="总结与如何选择"><a href="#总结与如何选择" class="headerlink" title="总结与如何选择"></a>总结与如何选择</h3><p>这些模式为构建不同能力的 AI Agent 提供了丰富的工具箱。选择哪种模式取决于你的具体需求：</p>
<ul>
<li><strong>基础推理增强</strong>: 从 <strong>Chain-of-Thought</strong> 开始。</li>
<li><strong>事实查询与整合</strong>: <strong>Self-Ask</strong> 是一个结构清晰的好选择。</li>
<li><strong>通用和动态任务</strong>: <strong>ReAct</strong> 是最经典和灵活的范式。</li>
<li><strong>成本敏感且流程固定的任务</strong>: <strong>Plan-and-Execute</strong> 更经济。</li>
<li><strong>追求极致效率和并行处理</strong>: <strong>ReWOO</strong> 是 ReAct 的高效替代品。</li>
<li><strong>需要反复试错和自我优化的任务</strong>: <strong>Reflexion</strong> 是不二之选。</li>
<li><strong>解决企业级、超大规模的复杂问题</strong>: <strong>Multi-Agent Architectures</strong> 提供了无限的可能性。</li>
</ul>
<p>未来的趋势很可能是将这些模式进行<strong>混合（Hybrid）</strong>，构建出既能高效规划，又能灵活适应，同时还能从失败中学习的、由多个专家 Agent 组成的复杂智能系统。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://penggehero.github.io/2025/08/21/%E3%80%90Python%E7%BC%96%E7%A8%8B%EF%BC%9A%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5%E3%80%91-%E9%A1%B9%E7%9B%AE-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="penggewu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="云泽的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/08/21/%E3%80%90Python%E7%BC%96%E7%A8%8B%EF%BC%9A%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5%E3%80%91-%E9%A1%B9%E7%9B%AE-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">【Python编程：从入门到实践】-项目-读书笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-08-21 09:49:13 / 修改时间：09:52:26" itemprop="dateCreated datePublished" datetime="2025-08-21T09:49:13+08:00">2025-08-21</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="【Python编程：从入门到实践】-项目-读书笔记"><a href="#【Python编程：从入门到实践】-项目-读书笔记" class="headerlink" title="【Python编程：从入门到实践】-项目-读书笔记"></a>【Python编程：从入门到实践】-项目-读书笔记</h1><blockquote>
<p>根据 <a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E9%81%97%E5%BF%98%E6%9B%B2%E7%BA%BF/7278665?fr=aladdin">遗忘曲线</a>：如果没有记录和回顾，6天后便会忘记75%的内容</p>
<p>  读书笔记正是帮助你记录和回顾的工具，不必拘泥于形式，其核心是：记录、翻看、思考</p>
</blockquote>
<table>
<thead>
<tr>
<th><strong>书名</strong></th>
<th>Python编程：从入门到实践（第3版）</th>
</tr>
</thead>
<tbody><tr>
<td><strong>原版书名</strong></td>
<td>Python Crash Course, 3rd Edition</td>
</tr>
<tr>
<td><strong>作者</strong></td>
<td><font style="color:rgb(26, 28, 30);background-color:rgb(252, 252, 252);">[美] 埃里克·马瑟斯 (Eric Matthes)</font></td>
</tr>
<tr>
<td><strong>译者</strong></td>
<td>袁国忠</td>
</tr>
<tr>
<td><strong>状态</strong></td>
<td><font style="background:#DBF1B7;color:#2A4200">已读完</font></td>
</tr>
<tr>
<td><strong>简介</strong></td>
<td><strong>Python入门经典，用三大项目实战，带你从零快速上手。</strong></td>
</tr>
</tbody></table>
<h2 id="项目一：外星人入侵-详细学习笔记"><a href="#项目一：外星人入侵-详细学习笔记" class="headerlink" title="项目一：外星人入侵 - 详细学习笔记"></a>项目一：外星人入侵 - 详细学习笔记</h2><hr>
<h3 id="项目整体介绍"><a href="#项目整体介绍" class="headerlink" title="项目整体介绍"></a><strong>项目整体介绍</strong></h3><p><strong>项目目标：</strong><br>“外星人入侵”是一个经典的2D街机射击游戏。我们的最终目标是创建一个功能完整的游戏，在这个游戏中，玩家可以控制一艘飞船，射击不断向下入侵的外星人舰队，同时游戏会记录得分、最高分、玩家等级和剩余生命。</p>
<p><strong>核心技术：</strong><br>我们将使用 <strong>Pygame</strong> 这个强大的Python第三方库。Pygame提供了一整套专门用于游戏开发的功能，包括创建窗口、绘制图形、处理用户输入（键盘、鼠标）、播放声音等。它让我们能专注于游戏的<strong>逻辑</strong>，而不用去处理底层的图形绘制细节。</p>
<p><strong>项目结构与学习路径：</strong><br>这是一个结构化的项目，通过将不同的功能封装在不同的**类（Class）<strong>和</strong>模块（Module，即.py文件）**中来构建。这种方式是现代软件开发的标准实践，能让代码更清晰、更易于管理和扩展。我们将分三章完成：</p>
<ul>
<li><strong>第12章：武装飞船</strong> - 搭建游戏框架，创建玩家可控的飞船，并实现射击功能。</li>
<li><strong>第13章：外星人</strong> - 创建外星人，组成舰队，让它们移动，并实现碰撞检测。</li>
<li><strong>第14章：记分</strong> - 添加Play按钮，建立完整的记分系统，并让游戏难度递增。</li>
</ul>
<hr>
<h3 id="第12章：武装飞船"><a href="#第12章：武装飞船" class="headerlink" title="第12章：武装飞船"></a><strong>第12章：武装飞船</strong></h3><p><strong>本章核心目标：</strong> 搭建游戏的基础框架，让一个可由玩家控制的飞船出现在屏幕上，并能发射子弹。</p>
<h4 id="1-搭建游戏框架"><a href="#1-搭建游戏框架" class="headerlink" title="1. 搭建游戏框架"></a><strong>1. 搭建游戏框架</strong></h4><p>首先，我们需要创建一个窗口来作为游戏的舞台。</p>
<ul>
<li>**创建主文件 **<code>alien_invasion.py</code>：这是游戏的启动文件和总控制器。</li>
<li><strong>创建</strong><code>AlienInvasion</code><strong>类</strong>：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># alien_invasion.py</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> pygame</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AlienInvasion</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;管理游戏资源和行为的类&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;初始化游戏并创建游戏资源&quot;&quot;&quot;</span></span><br><span class="line">        pygame.init() <span class="comment"># 1. 初始化Pygame</span></span><br><span class="line"></span><br><span class="line">        <span class="variable language_">self</span>.screen = pygame.display.set_mode((<span class="number">1200</span>, <span class="number">800</span>)) <span class="comment"># 2. 创建窗口</span></span><br><span class="line">        pygame.display.set_caption(<span class="string">&quot;Alien Invasion&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run_game</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;开始游戏的主循环&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>: <span class="comment"># 3. 游戏主循环</span></span><br><span class="line">            <span class="comment"># 侦听键盘和鼠标事件</span></span><br><span class="line">            <span class="keyword">for</span> event <span class="keyword">in</span> pygame.event.get():</span><br><span class="line">                <span class="keyword">if</span> event.<span class="built_in">type</span> == pygame.QUIT:</span><br><span class="line">                    sys.exit()</span><br><span class="line"></span><br><span class="line">            pygame.display.flip() <span class="comment"># 4. 刷新屏幕</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    ai = AlienInvasion()</span><br><span class="line">    ai.run_game()</span><br></pre></td></tr></table></figure>

<p><strong>细节解析：</strong></p>
<pre><code>1. `pygame.init()`：初始化所有Pygame模块，是每个Pygame程序的必需步骤。
2. `pygame.display.set_mode()`：创建一个窗口。它返回一个`surface`对象，这是屏幕上可以绘制图形的区域。
3. `while True:`：游戏主循环，让游戏持续运行，不断检测输入和更新画面。
4. `pygame.display.flip()`：刷新屏幕。在每次循环中，都会重新绘制屏幕，`flip`将最新的画面显示出来。
</code></pre>
<h4 id="2-将设置模块化-Settings类"><a href="#2-将设置模块化-Settings类" class="headerlink" title="2. 将设置模块化 (Settings类)"></a><strong>2. 将设置模块化 (</strong><code>Settings</code><strong>类)</strong></h4><p>为了不让代码变得混乱，我们把所有设置（如屏幕尺寸、颜色）集中管理。</p>
<ul>
<li><strong>创建</strong><code>settings.py</code><strong>文件</strong>：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># settings.py</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Settings</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;存储游戏中所有设置的类&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;初始化游戏的设置&quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.screen_width = <span class="number">1200</span></span><br><span class="line">        <span class="variable language_">self</span>.screen_height = <span class="number">800</span></span><br><span class="line">        <span class="variable language_">self</span>.bg_color = (<span class="number">230</span>, <span class="number">230</span>, <span class="number">230</span>) <span class="comment"># RGB颜色：浅灰色</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>在主程序中使用</strong>：在<code>alien_invasion.py</code>中导入<code>Settings</code>类，并创建一个实例 <code>self.settings</code>。</li>
</ul>
<h4 id="3-创建飞船-Ship类"><a href="#3-创建飞船-Ship类" class="headerlink" title="3. 创建飞船 (Ship类)"></a><strong>3. 创建飞船 (</strong><code>Ship</code><strong>类)</strong></h4><p>我们创建一个单独的类来处理所有与飞船相关的逻辑。</p>
<ul>
<li><strong>创建</strong><code>ship.py</code><strong>文件</strong>：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ship.py</span></span><br><span class="line"><span class="keyword">import</span> pygame</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ship</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, ai_game</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;初始化飞船并设置其初始位置&quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.screen = ai_game.screen</span><br><span class="line">        <span class="variable language_">self</span>.screen_rect = ai_game.screen.get_rect() <span class="comment"># 1. 获取屏幕的rect</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 加载飞船图像并获取其外接矩形</span></span><br><span class="line">        <span class="variable language_">self</span>.image = pygame.image.load(<span class="string">&#x27;images/ship.bmp&#x27;</span>)</span><br><span class="line">        <span class="variable language_">self</span>.rect = <span class="variable language_">self</span>.image.get_rect() <span class="comment"># 2. 获取飞船的rect</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 每艘新飞船都放在屏幕底部的中央</span></span><br><span class="line">        <span class="variable language_">self</span>.rect.midbottom = <span class="variable language_">self</span>.screen_rect.midbottom <span class="comment"># 3. 定位</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">blitme</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;在指定位置绘制飞船&quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.screen.blit(<span class="variable language_">self</span>.image, <span class="variable language_">self</span>.rect) <span class="comment"># 4. 绘制</span></span><br></pre></td></tr></table></figure>

<p><strong>细节解析：</strong></p>
<pre><code>1. `get_rect()`：获取一个`surface`（无论是屏幕还是图像）的**矩形区域（rect）**。
2. `rect`对象：你可以把它想象成一个围绕图像的隐形框，通过操作它的属性（如`.midbottom`）来轻松定位图像。
3. `midbottom`：是`rect`的一个属性，代表矩形底边的中心点。将飞船的`midbottom`设置为屏幕的`midbottom`，就能让飞船居中于屏幕底部。
4. `blit()`：是“绘制”的意思，将一个图像(`self.image`)画在另一个`surface`(`self.screen`)上由`self.rect`指定的位置。
</code></pre>
<h4 id="4-实现飞船移动"><a href="#4-实现飞船移动" class="headerlink" title="4. 实现飞船移动"></a><strong>4. 实现飞船移动</strong></h4><ul>
<li><strong>使用移动标志</strong>：在<code>Ship</code>类的<code>__init__</code>中添加标志 <code>self.moving_right = False</code> 和 <code>self.moving_left = False</code>。</li>
<li><strong>更新</strong><code>_check_events()</code><strong>方法</strong>：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># alien_invasion.py (在_check_events方法中)</span></span><br><span class="line"><span class="keyword">elif</span> event.<span class="built_in">type</span> == pygame.KEYDOWN: <span class="comment"># 按键按下</span></span><br><span class="line">    <span class="keyword">if</span> event.key == pygame.K_RIGHT:</span><br><span class="line">        <span class="variable language_">self</span>.ship.moving_right = <span class="literal">True</span></span><br><span class="line"><span class="keyword">elif</span> event.<span class="built_in">type</span> == pygame.KEYUP: <span class="comment"># 按键松开</span></span><br><span class="line">    <span class="keyword">if</span> event.key == pygame.K_RIGHT:</span><br><span class="line">        <span class="variable language_">self</span>.ship.moving_right = <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>创建</strong><code>Ship</code><strong>类的</strong><code>update()</code><strong>方法</strong>：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ship.py</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;根据移动标志调整飞船的位置&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="variable language_">self</span>.moving_right:</span><br><span class="line">        <span class="variable language_">self</span>.rect.x += <span class="number">1</span> <span class="comment"># 暂时移动1个像素</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>在主循环中调用</strong>：在<code>run_game()</code>的<code>while</code>循环里调用<code>self.ship.update()</code>，这样每一帧都会检查标志并移动飞船。</li>
</ul>
<h4 id="5-实现射击功能"><a href="#5-实现射击功能" class="headerlink" title="5. 实现射击功能"></a><strong>5. 实现射击功能</strong></h4><ol>
<li><strong>创建</strong><code>Bullet</code><strong>类 (</strong><code>bullet.py</code><strong>)</strong>：</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># bullet.py</span></span><br><span class="line"><span class="keyword">import</span> pygame</span><br><span class="line"><span class="keyword">from</span> pygame.sprite <span class="keyword">import</span> Sprite</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bullet</span>(<span class="title class_ inherited__">Sprite</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, ai_game</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__() <span class="comment"># 必须调用父类的__init__</span></span><br><span class="line">        <span class="variable language_">self</span>.screen = ai_game.screen</span><br><span class="line">        <span class="variable language_">self</span>.settings = ai_game.settings</span><br><span class="line">        <span class="variable language_">self</span>.color = <span class="variable language_">self</span>.settings.bullet_color</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 在(0, 0)处创建一个表示子弹的矩形，然后设置正确的位置</span></span><br><span class="line">        <span class="variable language_">self</span>.rect = pygame.Rect(<span class="number">0</span>, <span class="number">0</span>, <span class="variable language_">self</span>.settings.bullet_width,</span><br><span class="line">            <span class="variable language_">self</span>.settings.bullet_height)</span><br><span class="line">        <span class="variable language_">self</span>.rect.midtop = ai_game.ship.rect.midtop <span class="comment"># 从飞船顶部发出</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 存储用浮点数表示的子弹位置</span></span><br><span class="line">        <span class="variable language_">self</span>.y = <span class="built_in">float</span>(<span class="variable language_">self</span>.rect.y)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;向上移动子弹&quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.y -= <span class="variable language_">self</span>.settings.bullet_speed <span class="comment"># y坐标减小</span></span><br><span class="line">        <span class="variable language_">self</span>.rect.y = <span class="variable language_">self</span>.y</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">draw_bullet</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;在屏幕上绘制子弹&quot;&quot;&quot;</span></span><br><span class="line">        pygame.draw.rect(<span class="variable language_">self</span>.screen, <span class="variable language_">self</span>.color, <span class="variable language_">self</span>.rect)</span><br></pre></td></tr></table></figure>

<pre><code>- 这个类需要继承`pygame.sprite.Sprite`，这让我们能使用**编组（Group）**来统一管理所有子弹。
</code></pre>
<ol start="2">
<li><strong>管理子弹</strong>：<ul>
<li>在<code>AlienInvasion</code>中创建一个编组：<code>self.bullets = pygame.sprite.Group()</code>。</li>
<li>当玩家按下空格键时 (<code>K_SPACE</code>)，创建一个<code>Bullet</code>实例并将其添加到<code>self.bullets</code>编组中。</li>
<li>在主循环中，调用<code>self.bullets.update()</code>来移动所有子弹。</li>
<li>在<code>_update_screen()</code>中，遍历<code>self.bullets</code>编组，并对每个子弹调用<code>draw_bullet()</code>方法。</li>
<li><strong>删除消失的子弹</strong>：遍历<code>self.bullets.copy()</code>，检查子弹是否飞出屏幕顶部(<code>bullet.rect.bottom &lt;= 0</code>)，如果是，则从<code>self.bullets</code>中移除它。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="第13章：外星人"><a href="#第13章：外星人" class="headerlink" title="第13章：外星人"></a><strong>第13章：外星人</strong></h3><p><strong>本章核心目标：</strong> 在屏幕上创建一群外星人，让它们能够作为一个整体移动，并实现子弹与外星人、外星人与飞船的碰撞检测。</p>
<h4 id="1-创建外星人"><a href="#1-创建外星人" class="headerlink" title="1. 创建外星人"></a><strong>1. 创建外星人</strong></h4><ul>
<li><strong>创建</strong><code>Alien</code><strong>类 (</strong><code>alien.py</code><strong>)</strong>：这个类的结构与<code>Ship</code>类非常相似，也需要加载图像、获取<code>rect</code>。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># alien.py</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Alien</span>(<span class="title class_ inherited__">Sprite</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, ai_game</span>):</span><br><span class="line">        <span class="comment"># ...</span></span><br><span class="line">        <span class="variable language_">self</span>.image = pygame.image.load(<span class="string">&#x27;images/alien.bmp&#x27;</span>)</span><br><span class="line">        <span class="variable language_">self</span>.rect = <span class="variable language_">self</span>.image.get_rect()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 每个外星人最初都在屏幕左上角附近</span></span><br><span class="line">        <span class="variable language_">self</span>.rect.x = <span class="variable language_">self</span>.rect.width</span><br><span class="line">        <span class="variable language_">self</span>.rect.y = <span class="variable language_">self</span>.rect.height</span><br><span class="line">        <span class="comment"># ...</span></span><br></pre></td></tr></table></figure>

<h4 id="2-创建外星舰队"><a href="#2-创建外星舰队" class="headerlink" title="2. 创建外星舰队"></a><strong>2. 创建外星舰队</strong></h4><ul>
<li><strong>创建</strong><code>_create_fleet()</code><strong>方法</strong>：这个方法负责计算并创建整支舰队。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># alien_invasion.py (_create_fleet方法)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_create_fleet</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;创建外星舰队&quot;&quot;&quot;</span></span><br><span class="line">    alien = Alien(<span class="variable language_">self</span>)</span><br><span class="line">    alien_width, alien_height = alien.rect.size</span><br><span class="line">    <span class="comment"># ... 计算一行可容纳多少外星人，以及可容纳多少行 ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> row_number <span class="keyword">in</span> <span class="built_in">range</span>(number_rows):</span><br><span class="line">        <span class="keyword">for</span> alien_number <span class="keyword">in</span> <span class="built_in">range</span>(number_aliens_x):</span><br><span class="line">            <span class="variable language_">self</span>._create_alien(alien_number, row_number)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>使用嵌套循环</strong>：通过两层<code>for</code>循环，我们可以按行和列来创建外星人，并精确计算每个外星人的位置。</li>
</ul>
<h4 id="3-让舰队移动"><a href="#3-让舰队移动" class="headerlink" title="3. 让舰队移动"></a><strong>3. 让舰队移动</strong></h4><ol>
<li><strong>添加设置</strong>：在<code>settings.py</code>中添加<code>alien_speed</code>、<code>fleet_drop_speed</code>和<code>fleet_direction</code>（<code>1</code>表示向右，<code>-1</code>表示向左）。</li>
<li><code>Alien</code><strong>类的</strong><code>update()</code><strong>方法</strong>：让每个外星人根据<code>fleet_direction</code>来移动。</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># alien.py</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;向右或向左移动外星人&quot;&quot;&quot;</span></span><br><span class="line">    <span class="variable language_">self</span>.x += (<span class="variable language_">self</span>.settings.alien_speed *</span><br><span class="line">                    <span class="variable language_">self</span>.settings.fleet_direction)</span><br><span class="line">    <span class="variable language_">self</span>.rect.x = <span class="variable language_">self</span>.x</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>边缘检测</strong>：在<code>Alien</code>类中添加<code>check_edges()</code>方法，检查外星人是否碰到屏幕边缘。</li>
<li><strong>在</strong><code>AlienInvasion</code><strong>中控制舰队移动</strong>：<ul>
<li>创建<code>_update_aliens()</code>方法，它会调用<code>self.aliens.update()</code>。</li>
<li>在此方法中，调用<code>_check_fleet_edges()</code>。</li>
<li><code>_check_fleet_edges()</code>遍历舰队，如果发现有外星人碰到边缘，就调用<code>_change_fleet_direction()</code>。</li>
<li><code>_change_fleet_direction()</code>会让整个舰队下移，并反转移动方向。</li>
</ul>
</li>
</ol>
<h4 id="4-碰撞检测与游戏结束"><a href="#4-碰撞检测与游戏结束" class="headerlink" title="4. 碰撞检测与游戏结束"></a><strong>4. 碰撞检测与游戏结束</strong></h4><ol>
<li><strong>子弹与外星人碰撞</strong>：</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># alien_invasion.py (_update_bullets方法)</span></span><br><span class="line">collisions = pygame.sprite.groupcollide(</span><br><span class="line">        <span class="variable language_">self</span>.bullets, <span class="variable language_">self</span>.aliens, <span class="literal">True</span>, <span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<pre><code>- **核心函数**: `pygame.sprite.groupcollide()`
- 这行代码会检查`bullets`编组和`aliens`编组之间是否有成员碰撞。后两个`True`参数表示**碰撞后立即销毁**子弹和外星人。
- 当所有外星人被消灭后（即`self.aliens`为空），清空子弹并重新创建舰队。
</code></pre>
<ol start="2">
<li><strong>外星人与飞船碰撞</strong>：</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># alien_invasion.py (_update_aliens方法)</span></span><br><span class="line"><span class="keyword">if</span> pygame.sprite.spritecollideany(<span class="variable language_">self</span>.ship, <span class="variable language_">self</span>.aliens):</span><br><span class="line">    <span class="variable language_">self</span>._ship_hit()</span><br></pre></td></tr></table></figure>

<pre><code>- **创建**`GameStats`**类 (**`game_stats.py`**)**：用于跟踪游戏统计数据，如剩余飞船数`ships_left`。
- **核心函数**: `pygame.sprite.spritecollideany()`
- `_ship_hit()`**方法**：
    1. 检查`ships_left`是否大于0。
    2. 如果大于0，则将`ships_left`减1，清空屏幕，重置飞船和外星人，并暂停0.5秒。
    3. 如果等于0，则将游戏状态`game_active`设为`False`，游戏结束。
</code></pre>
<hr>
<h3 id="第14章：记分"><a href="#第14章：记分" class="headerlink" title="第14章：记分"></a><strong>第14章：记分</strong></h3><p><strong>本章核心目标：</strong> 完善游戏体验，添加Play按钮、记分系统和难度递增机制。</p>
<h4 id="14-1-添加Play按钮"><a href="#14-1-添加Play按钮" class="headerlink" title="14.1 添加Play按钮"></a><strong>14.1 添加Play按钮</strong></h4><ol>
<li><code>Button</code><strong>类 (</strong><code>button.py</code><strong>)</strong>：创建一个自定义的按钮类，因为它不是<code>pygame</code>内置的。<ul>
<li>它会创建一个矩形，并使用<code>pygame.font</code>模块将文本渲染成图像，然后将文本图像绘制在矩形中央。</li>
</ul>
</li>
<li><strong>管理游戏状态</strong>：<ul>
<li>在<code>AlienInvasion</code>的<code>__init__</code>中，将<code>game_active</code>标志<strong>初始设为</strong><code>False</code>。</li>
<li>在<code>_update_screen()</code>中，<strong>仅当</strong><code>game_active</code><strong>为</strong><code>False</code><strong>时</strong>才绘制Play按钮。</li>
</ul>
</li>
<li><strong>响应点击</strong>：<ul>
<li>在<code>_check_events()</code>中检测<code>MOUSEBUTTONDOWN</code>事件。</li>
<li>使用<code>button.rect.collidepoint(mouse_pos)</code>判断点击位置是否在按钮内。</li>
<li>如果点击了按钮且游戏未开始，则<strong>重置游戏</strong>（<code>stats.reset_stats()</code>）、将<code>game_active</code>设为<code>True</code>，并隐藏鼠标光标。</li>
</ul>
</li>
</ol>
<h4 id="14-2-提高难度"><a href="#14-2-提高难度" class="headerlink" title="14.2 提高难度"></a><strong>14.2 提高难度</strong></h4><ul>
<li><strong>在</strong><code>Settings</code><strong>中分离设置</strong>：将设置分为<strong>静态设置</strong>和<strong>动态设置</strong>。</li>
<li><code>increase_speed()</code><strong>方法</strong>：在<code>settings.py</code>中创建一个方法，当调用它时，飞船、子弹和外星人的速度都会乘以一个加速因子（如<code>1.1</code>）。</li>
<li><strong>调用时机</strong>：当整支外星舰队被消灭后，在创建新舰队之前，调用<code>settings.increase_speed()</code>。</li>
</ul>
<h4 id="14-3-记分系统"><a href="#14-3-记分系统" class="headerlink" title="14.3 记分系统"></a><strong>14.3 记分系统</strong></h4><ol>
<li><code>Scoreboard</code><strong>类 (</strong><code>scoreboard.py</code><strong>)</strong>：创建一个类来处理所有得分信息的显示。</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># scoreboard.py</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Scoreboard</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, ai_game</span>):</span><br><span class="line">        <span class="comment"># ... 初始化字体、颜色等 ...</span></span><br><span class="line">        <span class="variable language_">self</span>.stats = ai_game.stats</span><br><span class="line">        <span class="comment"># ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">prep_score</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;将得分渲染为图像&quot;&quot;&quot;</span></span><br><span class="line">        score_str = <span class="built_in">str</span>(<span class="variable language_">self</span>.stats.score)</span><br><span class="line">        <span class="variable language_">self</span>.score_image = <span class="variable language_">self</span>.font.render(score_str, <span class="literal">True</span>,</span><br><span class="line">                <span class="variable language_">self</span>.text_color, <span class="variable language_">self</span>.settings.bg_color)</span><br><span class="line">        <span class="comment"># ... 定位得分图像 ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">show_score</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;在屏幕上显示得分&quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.screen.blit(<span class="variable language_">self</span>.score_image, <span class="variable language_">self</span>.score_rect)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>更新和显示</strong>：<ul>
<li><strong>得分</strong>：当子弹击中外星人时，增加<code>stats.score</code>的值，然后立即调用<code>sb.prep_score()</code>来更新显示的图像。</li>
<li><strong>最高分</strong>：在<code>GameStats</code>中添加<code>high_score</code>属性。每次得分增加后，都检查是否超过了最高分，如果是则更新<code>high_score</code>和对应的图像。</li>
<li><strong>等级</strong>：在<code>GameStats</code>中添加<code>level</code>属性。每当消灭一波外星人，就将等级加1并更新图像。</li>
<li><strong>剩余飞船</strong>：不再用数字显示，而是在屏幕左上角绘制相应数量的小飞船图标。这需要让<code>Ship</code>类也继承<code>Sprite</code>，并在<code>Scoreboard</code>中创建一个飞船编组来管理这些图标。</li>
</ul>
</li>
</ol>
<p>通过这三章的学习，一个完整、动态且具有挑战性的“外星人入侵”游戏就完成了。这个过程全面覆盖了从项目搭建、面向对象编程、事件处理到游戏逻辑实现的方方面面，是巩固和应用Python基础知识的绝佳实践。</p>
<h2 id="项目二：数据可视化"><a href="#项目二：数据可视化" class="headerlink" title="项目二：数据可视化"></a>项目二：数据可视化</h2><hr>
<h3 id="项目整体介绍-1"><a href="#项目整体介绍-1" class="headerlink" title="项目整体介绍"></a><strong>项目整体介绍</strong></h3><p><strong>项目目标：</strong><br>本项目旨在教会我们如何使用Python来处理数据并将其以图形化的方式呈现出来。数据可视化是<strong>数据分析</strong>的核心环节，它能帮助我们直观地发现数据中的模式、趋势和异常点，将枯燥的数字转换成一目了然的图表。</p>
<p><strong>核心技术：</strong><br>我们将学习使用两个强大的Python数据可视化库：</p>
<ol>
<li><strong>Matplotlib</strong>：一个非常流行且功能全面的绘图库，被誉为Python数据可视化领域的“元老”。它能创建高质量的静态图表，如图线图、散点图等。</li>
<li><strong>Plotly</strong>：一个现代化的交互式绘图库。它生成的图表可以在网页浏览器中显示，用户可以通过鼠标悬停、缩放等方式与图表进行互动，非常适合制作动态和交互式的数据报告。</li>
</ol>
<p><strong>项目结构与学习路径：</strong><br>我们将通过三个循序渐进的章节来完成这个项目：</p>
<ul>
<li><strong>第15章：生成数据</strong> - 学习Matplotlib和Plotly的基本用法，通过绘制简单的图表和模拟随机游走来生成和可视化数据。</li>
<li><strong>第16章：下载数据</strong> - 学习如何处理真实世界的数据文件，特别是常见的<strong>CSV格式</strong>。我们将下载并可视化气象数据。</li>
<li><strong>第17章：使用API</strong> - 学习如何通过**API（应用程序编程接口）**从网络服务（如GitHub）上自动获取实时数据，并进行可视化。</li>
</ul>
<hr>
<h3 id="第15章：生成数据"><a href="#第15章：生成数据" class="headerlink" title="第15章：生成数据"></a><strong>第15章：生成数据</strong></h3><p><strong>本章核心目标：</strong> 掌握Matplotlib和Plotly的基本绘图流程，学会生成简单的数据集并将其可视化。</p>
<h4 id="1-安装Matplotlib和Plotly"><a href="#1-安装Matplotlib和Plotly" class="headerlink" title="1. 安装Matplotlib和Plotly"></a><strong>1. 安装Matplotlib和Plotly</strong></h4><ul>
<li><strong>安装命令</strong>：在终端中使用<code>pip</code>来安装这两个库。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">python -m pip install --user matplotlib</span><br><span class="line">python -m pip install --user plotly pandas</span><br><span class="line">```    *   **注意**：Plotly Express通常需要`pandas`库的支持，所以我们一并安装。</span><br></pre></td></tr></table></figure>

<h4 id="2-使用Matplotlib绘制简单的折线图"><a href="#2-使用Matplotlib绘制简单的折线图" class="headerlink" title="2. 使用Matplotlib绘制简单的折线图"></a><strong>2. 使用Matplotlib绘制简单的折线图</strong></h4><ol>
<li><strong>基本绘图流程</strong>：</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mpl_squares.py</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">squares = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>]</span><br><span class="line"></span><br><span class="line">fig, ax = plt.subplots() <span class="comment"># 1. 创建图表和绘图区域</span></span><br><span class="line">ax.plot(squares)         <span class="comment"># 2. 绘制数据</span></span><br><span class="line"></span><br><span class="line">plt.show()               <span class="comment"># 3. 显示图表</span></span><br></pre></td></tr></table></figure>

<p><strong>细节解析：</strong></p>
<pre><code>1. `import matplotlib.pyplot as plt`：这是使用`pyplot`模块的约定俗成的方式。
2. `plt.subplots()`：创建一个包含图表（`fig`）和单个绘图区域（`ax`）的窗口。`ax`是我们用来绘制图形的主要对象。
3. `ax.plot()`：根据提供的数据列表绘制折线图。
4. `plt.show()`：打开Matplotlib的查看器并显示绘制好的图表。
</code></pre>
<ol start="2">
<li><strong>定制图表</strong>：</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mpl_squares.py (修改后)</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">input_values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">squares = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>]</span><br><span class="line"></span><br><span class="line">plt.style.use(<span class="string">&#x27;seaborn&#x27;</span>) <span class="comment"># 1. 使用预设样式</span></span><br><span class="line">fig, ax = plt.subplots()</span><br><span class="line">ax.plot(input_values, squares, linewidth=<span class="number">3</span>) <span class="comment"># 2. 提供x,y值，设置线宽</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 设置图表标题和坐标轴标签</span></span><br><span class="line">ax.set_title(<span class="string">&quot;Square Numbers&quot;</span>, fontsize=<span class="number">24</span>)</span><br><span class="line">ax.set_xlabel(<span class="string">&quot;Value&quot;</span>, fontsize=<span class="number">14</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">&quot;Square of Value&quot;</span>, fontsize=<span class="number">14</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 设置刻度标记的大小</span></span><br><span class="line">ax.tick_params(labelsize=<span class="number">14</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p><strong>细节解析：</strong></p>
<pre><code>- 我们可以添加标题、坐标轴标签，并设置线条样式。
1. `plt.style.use()`：可以使用Matplotlib内置的样式（如`&#39;seaborn&#39;`）来美化图表。
2. `ax.plot(x, y)`：同时提供x轴和y轴的数据，可以确保图表被正确地绘制。
3. `ax.set_title()`, `ax.set_xlabel()`, `ax.set_ylabel()`：用于设置图表的各种标签。
4. `ax.tick_params()`：用于定制坐标轴刻度的外观。
</code></pre>
<h4 id="3-使用Matplotlib绘制散点图-scatter"><a href="#3-使用Matplotlib绘制散点图-scatter" class="headerlink" title="3. 使用Matplotlib绘制散点图 (scatter)"></a><strong>3. 使用Matplotlib绘制散点图 (</strong><code>scatter</code><strong>)</strong></h4><ul>
<li><strong>功能</strong>：用于绘制单个或一系列的数据点。</li>
<li><strong>自动计算数据</strong>：我们可以用<code>range()</code>和列表推导式来自动生成大量的数据点。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># scatter_squares.py</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">x_values = <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">1001</span>)</span><br><span class="line">y_values = [x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> x_values]</span><br><span class="line"></span><br><span class="line">plt.style.use(<span class="string">&#x27;seaborn&#x27;</span>)</span><br><span class="line">fig, ax = plt.subplots()</span><br><span class="line"><span class="comment"># 使用颜色映射 (colormap)</span></span><br><span class="line">ax.scatter(x_values, y_values, c=y_values, cmap=plt.cm.Blues, s=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ... 设置标题和标签 ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置每个坐标轴的取值范围</span></span><br><span class="line">ax.axis([<span class="number">0</span>, <span class="number">1100</span>, <span class="number">0</span>, <span class="number">1100000</span>])</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p><strong>细节解析：</strong></p>
<pre><code>- `ax.scatter()`：绘制散点图。
- `s=10`：设置数据点的大小。
- `c=y_values, cmap=plt.cm.Blues`：这是一个高级用法，`c`参数用于指定颜色，当它被设置为一个数值列表时，`cmap`（颜色映射）会根据这些数值的大小将点映射成不同的颜色（这里是从浅蓝到深蓝）。
</code></pre>
<h4 id="4-模拟随机游走"><a href="#4-模拟随机游走" class="headerlink" title="4. 模拟随机游走"></a><strong>4. 模拟随机游走</strong></h4><ul>
<li><code>RandomWalk</code>** 类**：创建一个类来模拟随机游走的过程。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># random_walk.py</span></span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> choice</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RandomWalk</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, num_points=<span class="number">5000</span></span>):</span><br><span class="line">        <span class="variable language_">self</span>.num_points = num_points</span><br><span class="line">        <span class="variable language_">self</span>.x_values = [<span class="number">0</span>]</span><br><span class="line">        <span class="variable language_">self</span>.y_values = [<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fill_walk</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(<span class="variable language_">self</span>.x_values) &lt; <span class="variable language_">self</span>.num_points:</span><br><span class="line">            x_direction = choice([<span class="number">1</span>, -<span class="number">1</span>])</span><br><span class="line">            x_distance = choice([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line">            x_step = x_direction * x_distance</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># ... 对y_step进行类似计算 ...</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 拒绝原地踏步</span></span><br><span class="line">            <span class="keyword">if</span> x_step == <span class="number">0</span> <span class="keyword">and</span> y_step == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 计算下一个点的x和y值</span></span><br><span class="line">            x = <span class="variable language_">self</span>.x_values[-<span class="number">1</span>] + x_step</span><br><span class="line">            y = <span class="variable language_">self</span>.y_values[-<span class="number">1</span>] + y_step</span><br><span class="line">            </span><br><span class="line">            <span class="variable language_">self</span>.x_values.append(x)</span><br><span class="line">            <span class="variable language_">self</span>.y_values.append(y)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>可视化随机游走</strong>：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rw_visual.py</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> random_walk <span class="keyword">import</span> RandomWalk</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>: <span class="comment"># 不断生成新的随机游走图</span></span><br><span class="line">    rw = RandomWalk()</span><br><span class="line">    rw.fill_walk()</span><br><span class="line"></span><br><span class="line">    plt.style.use(<span class="string">&#x27;classic&#x27;</span>)</span><br><span class="line">    fig, ax = plt.subplots()</span><br><span class="line">    point_numbers = <span class="built_in">range</span>(rw.num_points)</span><br><span class="line">    ax.scatter(rw.x_values, rw.y_values, c=point_numbers, cmap=plt.cm.Blues,</span><br><span class="line">        edgecolors=<span class="string">&#x27;none&#x27;</span>, s=<span class="number">15</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 突出起点和终点</span></span><br><span class="line">    ax.scatter(<span class="number">0</span>, <span class="number">0</span>, c=<span class="string">&#x27;green&#x27;</span>, edgecolors=<span class="string">&#x27;none&#x27;</span>, s=<span class="number">100</span>)</span><br><span class="line">    ax.scatter(rw.x_values[-<span class="number">1</span>], rw.y_values[-<span class="number">1</span>], c=<span class="string">&#x27;red&#x27;</span>, edgecolors=<span class="string">&#x27;none&#x27;</span>, s=<span class="number">100</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 隐藏坐标轴</span></span><br><span class="line">    ax.get_xaxis().set_visible(<span class="literal">False</span>)</span><br><span class="line">    ax.get_yaxis().set_visible(<span class="literal">False</span>)</span><br><span class="line">    </span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line">    keep_running = <span class="built_in">input</span>(<span class="string">&quot;Make another walk? (y/n): &quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> keep_running == <span class="string">&#x27;n&#x27;</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<h4 id="5-使用Plotly模拟掷骰子"><a href="#5-使用Plotly模拟掷骰子" class="headerlink" title="5. 使用Plotly模拟掷骰子"></a><strong>5. 使用Plotly模拟掷骰子</strong></h4><ol>
<li><code>Die</code>** 类 (<strong><code>die.py</code></strong>)**：创建一个简单的类来模拟骰子。</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># die.py</span></span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Die</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, num_sides=<span class="number">6</span></span>):</span><br><span class="line">        <span class="variable language_">self</span>.num_sides = num_sides</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">roll</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> randint(<span class="number">1</span>, <span class="variable language_">self</span>.num_sides)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>分析结果并可视化</strong>：</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># die_visual.py</span></span><br><span class="line"><span class="keyword">from</span> die <span class="keyword">import</span> Die</span><br><span class="line"><span class="keyword">import</span> plotly.express <span class="keyword">as</span> px</span><br><span class="line"></span><br><span class="line">die = Die() <span class="comment"># 创建一个6面骰子</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 掷骰子，并将结果存储在列表中</span></span><br><span class="line">results = [die.roll() <span class="keyword">for</span> roll_num <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分析结果</span></span><br><span class="line">poss_results = <span class="built_in">range</span>(<span class="number">1</span>, die.num_sides + <span class="number">1</span>)</span><br><span class="line">frequencies = [results.count(value) <span class="keyword">for</span> value <span class="keyword">in</span> poss_results]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可视化结果</span></span><br><span class="line">title = <span class="string">&quot;Results of Rolling One D6 1,000 Times&quot;</span></span><br><span class="line">labels = &#123;<span class="string">&#x27;x&#x27;</span>: <span class="string">&#x27;Result&#x27;</span>, <span class="string">&#x27;y&#x27;</span>: <span class="string">&#x27;Frequency of Result&#x27;</span>&#125;</span><br><span class="line">fig = px.bar(x=poss_results, y=frequencies, title=title, labels=labels)</span><br><span class="line">fig.show()</span><br></pre></td></tr></table></figure>

<p><strong>细节解析：</strong></p>
<pre><code>- 掷多次骰子，统计每个点数出现的频率。
- `import plotly.express as px`：这是使用Plotly Express的约定。
- `px.bar()`：创建一个**条形图（直方图）**，非常适合显示频率分布。
- `fig.show()`：在浏览器中打开并显示交互式图表。
</code></pre>
<ol start="3">
<li><strong>定制Plotly图表</strong>：可以为图表添加标题和标签，甚至更进一步地定制布局。</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ... 在fig = px.bar(...)之后添加</span></span><br><span class="line">fig.update_layout(xaxis_dtick=<span class="number">1</span>) <span class="comment"># 确保每个x轴刻度都显示</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="第16章：下载数据"><a href="#第16章：下载数据" class="headerlink" title="第16章：下载数据"></a><strong>第16章：下载数据</strong></h3><p><strong>本章核心目标：</strong> 学习处理存储在文件中的真实世界数据集，重点是<strong>CSV（逗号分隔值）文件</strong>，并使用Matplotlib将其可视化。</p>
<h4 id="1-CSV文件格式"><a href="#1-CSV文件格式" class="headerlink" title="1. CSV文件格式"></a><strong>1. CSV文件格式</strong></h4><ul>
<li><strong>概念</strong>：一种非常常见的、用纯文本存储表格数据的文件格式。每行代表一条记录，记录中的字段用逗号分隔。</li>
</ul>
<h4 id="2-解析CSV文件头"><a href="#2-解析CSV文件头" class="headerlink" title="2. 解析CSV文件头"></a><strong>2. 解析CSV文件头</strong></h4><ul>
<li><code>csv</code><strong>模块</strong>：Python标准库中用于处理CSV文件的模块。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sitka_highs.py</span></span><br><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"></span><br><span class="line">path = Path(<span class="string">&#x27;weather_data/sitka_weather_07-2021_simple.csv&#x27;</span>)</span><br><span class="line">lines = path.read_text().splitlines()</span><br><span class="line"></span><br><span class="line">reader = csv.reader(lines) <span class="comment"># 1. 创建reader对象</span></span><br><span class="line">header_row = <span class="built_in">next</span>(reader)  <span class="comment"># 2. 读取文件头</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> index, column_header <span class="keyword">in</span> <span class="built_in">enumerate</span>(header_row):</span><br><span class="line">    <span class="built_in">print</span>(index, column_header)</span><br></pre></td></tr></table></figure>

<p><strong>细节解析：</strong></p>
<pre><code>1. `csv.reader()`：接收一个文件对象（或行列表），并创建一个`reader`对象，可以方便地遍历CSV的每一行。
2. `next()`：当用于`reader`对象时，它会返回文件中的下一行。第一次调用时返回的就是文件头。
</code></pre>
<h4 id="3-提取并读取数据"><a href="#3-提取并读取数据" class="headerlink" title="3. 提取并读取数据"></a><strong>3. 提取并读取数据</strong></h4><ul>
<li><strong>遍历数据</strong>：在读取文件头之后，继续对<code>reader</code>对象进行<code>for</code>循环，就可以遍历文件的其余数据行。</li>
<li><strong>数据转换</strong>：从CSV文件中读取的数据都是<strong>字符串</strong>，如果需要进行计算，必须用<code>int()</code>或<code>float()</code>转换为数字。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sitka_highs.py</span></span><br><span class="line">highs = []</span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> reader:</span><br><span class="line">    high = <span class="built_in">int</span>(row[<span class="number">4</span>]) <span class="comment"># 假设最高温在第5列（索引为4）</span></span><br><span class="line">    highs.append(high)</span><br></pre></td></tr></table></figure>

<h4 id="4-处理日期数据-datetime模块"><a href="#4-处理日期数据-datetime模块" class="headerlink" title="4. 处理日期数据 (datetime模块)"></a><strong>4. 处理日期数据 (</strong><code>datetime</code><strong>模块)</strong></h4><ul>
<li><strong>功能</strong>：Python标准库中用于处理日期和时间的模块。</li>
<li><code>datetime.strptime()</code>：将<strong>字符串</strong>格式的日期转换为Python能够理解的<code>datetime</code><strong>对象</strong>。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="comment"># 格式代码 &#x27;%Y-%m-%d&#x27; 告诉Python如何解析日期字符串&#x27;2021-07-01&#x27;</span></span><br><span class="line">first_date = datetime.strptime(<span class="string">&#x27;2021-07-01&#x27;</span>, <span class="string">&#x27;%Y-%m-%d&#x27;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>在图表中使用日期</strong>：将日期字符串转换为<code>datetime</code>对象后，就可以将它们作为x轴数据传递给<code>plot()</code>，Matplotlib会自动处理日期的显示。<ul>
<li><code>fig.autofmt_xdate()</code>：自动格式化x轴的日期标签，使其倾斜以避免重叠。</li>
</ul>
</li>
</ul>
<h4 id="5-错误检查"><a href="#5-错误检查" class="headerlink" title="5. 错误检查"></a><strong>5. 错误检查</strong></h4><ul>
<li><strong>问题</strong>：真实世界的数据集常常是不完整的，比如某一天的数据缺失。</li>
<li><strong>解决方法</strong>：使用**<code>try-except-else</code>代码块**。在尝试转换数据（如<code>int()</code>）时，如果遇到空字符串或其他无效值，会引发<code>ValueError</code>。我们可以捕获这个异常，并打印一条错误消息，然后继续处理下一行数据。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> reader:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        high = <span class="built_in">int</span>(row[<span class="number">3</span>])</span><br><span class="line">        low = <span class="built_in">int</span>(row[<span class="number">4</span>])</span><br><span class="line">    <span class="keyword">except</span> ValueError:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Missing data for <span class="subst">&#123;current_date&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        highs.append(high)</span><br><span class="line">        lows.append(low)</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="第17章：使用API"><a href="#第17章：使用API" class="headerlink" title="第17章：使用API"></a><strong>第17章：使用API</strong></h3><p><strong>本章核心目标：</strong> 学习如何通过**API（应用程序编程接口）**自动从网络服务获取实时数据，并使用Plotly进行可视化。</p>
<h4 id="1-什么是API"><a href="#1-什么是API" class="headerlink" title="1. 什么是API"></a><strong>1. 什么是API</strong></h4><ul>
<li><strong>概念</strong>：API是网站提供给程序用来交互的一套规则和工具。程序可以通过访问特定的URL（称为<strong>API调用</strong>）来请求数据，网站会以易于处理的格式（通常是<strong>JSON</strong>）返回数据。</li>
</ul>
<h4 id="2-使用Requests库"><a href="#2-使用Requests库" class="headerlink" title="2. 使用Requests库"></a><strong>2. 使用Requests库</strong></h4><ul>
<li><code>requests</code>：一个非常流行的第三方库，用于发送HTTP请求（即进行API调用）。</li>
<li><strong>安装</strong>：<code>python -m pip install --user requests</code></li>
<li><strong>进行API调用</strong>：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python_repos.py</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;https://api.github.com/search/repositories?q=language:python+sort:stars&#x27;</span></span><br><span class="line">headers = &#123;<span class="string">&#x27;Accept&#x27;</span>: <span class="string">&#x27;application/vnd.github.v3+json&#x27;</span>&#125; <span class="comment"># 1. 指定API版本</span></span><br><span class="line">r = requests.get(url, headers=headers) <span class="comment"># 2. 发送GET请求</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Status code: <span class="subst">&#123;r.status_code&#125;</span>&quot;</span>) <span class="comment"># 3. 检查状态码</span></span><br></pre></td></tr></table></figure>

<p><strong>细节解析：</strong></p>
<pre><code>1. `headers`：HTTP标头，可以向API提供额外信息，这里我们指定使用GitHub API的第3版。
2. `requests.get()`：发送一个GET请求到指定的URL。
3. `r.status_code`：响应对象`r`的状态码。**状态码200表示请求成功**。
</code></pre>
<h4 id="3-处理API响应"><a href="#3-处理API响应" class="headerlink" title="3. 处理API响应"></a><strong>3. 处理API响应</strong></h4><ul>
<li><strong>JSON格式</strong>：API返回的数据通常是JSON格式。</li>
<li><strong>解析JSON</strong>：<code>requests</code>库内置了JSON解码器，可以轻松地将响应转换为Python字典。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response_dict = r.json()</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>探索数据</strong>：转换成字典后，我们就可以通过键来访问数据了，就像处理普通字典一样。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Total repositories: <span class="subst">&#123;response_dict[<span class="string">&#x27;total_count&#x27;</span>]&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">repo_dicts = response_dict[<span class="string">&#x27;items&#x27;</span>] <span class="comment"># 获取仓库信息列表</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历列表，处理每个仓库的信息</span></span><br><span class="line"><span class="keyword">for</span> repo_dict <span class="keyword">in</span> repo_dicts:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;\nName: <span class="subst">&#123;repo_dict[<span class="string">&#x27;name&#x27;</span>]&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Owner: <span class="subst">&#123;repo_dict[<span class="string">&#x27;owner&#x27;</span>][<span class="string">&#x27;login&#x27;</span>]&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="comment"># ...</span></span><br></pre></td></tr></table></figure>

<h4 id="4-使用Plotly可视化API返回的数据"><a href="#4-使用Plotly可视化API返回的数据" class="headerlink" title="4. 使用Plotly可视化API返回的数据"></a><strong>4. 使用Plotly可视化API返回的数据</strong></h4><ul>
<li><strong>流程</strong>：<ol>
<li>执行API调用并获取数据。</li>
<li>遍历返回的数据，将需要可视化的信息（如仓库名、星标数、悬停文本等）提取并存储到列表中。</li>
<li>使用<code>plotly.express</code>（如<code>px.bar()</code>）创建图表，将这些列表作为数据源。</li>
</ol>
</li>
<li><strong>添加交互功能</strong>：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ... 在循环中 ...</span></span><br><span class="line">repo_name = repo_dict[<span class="string">&#x27;name&#x27;</span>]</span><br><span class="line">repo_url = repo_dict[<span class="string">&#x27;html_url&#x27;</span>]</span><br><span class="line">repo_link = <span class="string">f&quot;&lt;a href=&#x27;<span class="subst">&#123;repo_url&#125;</span>&#x27;&gt;<span class="subst">&#123;repo_name&#125;</span>&lt;/a&gt;&quot;</span></span><br><span class="line">repo_links.append(repo_link)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ... 在绘图时 ...</span></span><br><span class="line">fig = px.bar(x=repo_links, y=stars, ...)</span><br></pre></td></tr></table></figure>

<pre><code>- **悬停文本 (Hover Text)**：在`px.bar()`中设置`hover_name`参数，可以在鼠标悬停在条形上时显示更详细的信息。
- **可点击链接**：可以创建包含HTML `&lt;a&gt;` 标签的字符串列表，并将其作为x轴数据。这样图表中的标签就变成了可点击的链接。
</code></pre>
<hr>
<h4 id="项目总结"><a href="#项目总结" class="headerlink" title="项目总结"></a><strong>项目总结</strong></h4><p>项目二带领我进入了激动人心的数据科学领域。从<strong>第15章</strong>学会使用Matplotlib和Plotly生成基本图表，到<strong>第16章</strong>处理真实的CSV气象数据，再到<strong>第17章</strong>通过API获取实时的网络数据，我逐步掌握了数据可视化的完整流程。我不仅学会了如何画图，更重要的是学会了<strong>如何准备数据、处理数据中的不完美（如缺失值）、以及如何通过定制图表来更清晰地讲述数据背后的故事</strong>。这个项目让我深刻体会到，编程不仅仅是创建应用，更是一种探索和理解世界的强大工具。</p>
<h2 id="项目三：Web应用程序"><a href="#项目三：Web应用程序" class="headerlink" title="项目三：Web应用程序"></a>项目三：Web应用程序</h2><hr>
<h3 id="项目整体介绍-2"><a href="#项目整体介绍-2" class="headerlink" title="项目整体介绍"></a><strong>项目整体介绍</strong></h3><p><strong>项目目标：</strong><br>本项目的目标是创建一个名为“学习笔记”（Learning Log）的<strong>Web应用程序</strong>。用户可以通过网页浏览器访问这个应用，注册账户，然后创建自己学习的主题，并为每个主题添加学习笔记条目。这个项目将教会我们构建一个功能完整的、数据驱动的、支持多用户的动态网站。</p>
<p><strong>核心技术：</strong><br>我们将使用 <strong>Django</strong>，这是一个非常流行且功能强大的Python <strong>Web框架</strong>。框架是一套工具和规则的集合，它极大地简化了Web应用的开发过程。Django为我们处理了很多复杂的底层工作，比如：</p>
<ul>
<li><strong>URL路由</strong>：将用户请求的网址映射到正确的处理逻辑。</li>
<li><strong>数据库交互</strong>：通过**模型（Models）**来定义数据结构，Django会自动将其转换为数据库表，并提供简单的API来操作数据。</li>
<li><strong>用户认证</strong>：内置了完整的用户注册、登录、注销系统。</li>
<li><strong>模板系统</strong>：将后端逻辑与前端HTML页面分离，让我们可以动态生成网页内容。</li>
<li><strong>安全性</strong>：内置了对常见网络攻击（如CSRF）的防护。</li>
</ul>
<p><strong>项目结构与学习路径：</strong><br>我们将分三章来逐步构建和完善这个Web应用：</p>
<ul>
<li><strong>第18章：Django入门</strong> - 搭建项目基础，包括设置开发环境、创建Django项目和应用、定义数据模型，并使用Django的管理后台添加初始数据。</li>
<li><strong>第19章：用户账户</strong> - 实现用户功能，包括创建让用户添加和编辑数据的表单，以及构建完整的用户注册、登录和注销系统。</li>
<li><strong>第20章：设置应用程序的样式并部署</strong> - 使用<strong>Bootstrap</strong>框架美化应用的外观，使其适应不同尺寸的设备（响应式设计），最后将整个项目<strong>部署</strong>到真实的Web服务器上，让任何人都可以通过互联网访问。</li>
</ul>
<hr>
<h3 id="第18章：Django入门"><a href="#第18章：Django入门" class="headerlink" title="第18章：Django入门"></a><strong>第18章：Django入门</strong></h3><p><strong>本章核心目标：</strong> 搭建Django项目的骨架，定义数据结构，并通过Django强大的管理后台初步与项目进行交互。</p>
<h4 id="18-1-建立项目"><a href="#18-1-建立项目" class="headerlink" title="18.1 建立项目"></a><strong>18.1 建立项目</strong></h4><ol>
<li><strong>制定规范 (Spec)</strong>：明确项目目标——一个让用户记录学习主题和笔记的在线日志系统。</li>
<li><strong>建立虚拟环境</strong>：<ul>
<li><strong>目的</strong>：为项目创建一个隔离的Python环境，避免不同项目间的库版本冲突。这是专业开发的标准做法。</li>
<li><strong>命令</strong>：</li>
</ul>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在项目主文件夹 learning_log 中</span></span><br><span class="line">python -m venv ll_env       <span class="comment"># 创建名为ll_env的虚拟环境</span></span><br><span class="line"><span class="built_in">source</span> ll_env/bin/activate  <span class="comment"># 激活环境 (macOS/Linux)</span></span><br><span class="line"><span class="comment"># ll_env\Scripts\activate   # 激活环境 (Windows)</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>安装Django</strong>：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install django</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><strong>在Django中创建项目</strong>：<ul>
<li><strong>项目 (Project)</strong>：是整个Web应用的配置和应用的集合。</li>
<li><strong>应用 (App)</strong>：是项目中负责实现某个特定功能的模块，如博客、调查等。一个项目可以包含多个应用。</li>
<li><strong>命令</strong>：</li>
</ul>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注意末尾的句点 .</span></span><br><span class="line">django-admin startproject ll_project .</span><br></pre></td></tr></table></figure>

<pre><code>    * 这会创建一个名为 `ll_project` 的配置目录和一个 `manage.py` 工具文件。
</code></pre>
<ol start="5">
<li><strong>创建数据库</strong>：<ul>
<li>Django默认使用<strong>SQLite</strong>，这是一个轻量级的、基于单个文件的数据库。</li>
<li><strong>迁移 (Migrate)</strong>：<code>migrate</code>命令会根据项目的模型设置来创建或更新数据库的结构。</li>
</ul>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py migrate</span><br></pre></td></tr></table></figure>

<ol start="6">
<li><strong>查看项目</strong>：<ul>
<li><strong>开发服务器</strong>：Django内置了一个用于开发的轻量级Web服务器。</li>
<li><strong>命令</strong>：</li>
</ul>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py runserver</span><br></pre></td></tr></table></figure>

<pre><code>- 在浏览器中访问 `http://localhost:8000/`，看到Django的欢迎页面，表示项目已成功创建。
</code></pre>
<h4 id="18-2-创建应用程序"><a href="#18-2-创建应用程序" class="headerlink" title="18.2 创建应用程序"></a><strong>18.2 创建应用程序</strong></h4><ol>
<li><strong>创建</strong><code>learning_logs</code><strong>应用</strong>：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python manage.py startapp learning_logs</span><br><span class="line">```    *   这会创建一个名为 `learning_logs` 的新文件夹，里面包含了应用所需的基本文件结构。</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>定义模型 (Models)</strong>：</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># learning_logs/models.py</span></span><br><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Topic</span>(models.Model):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;用户学习的主题&quot;&quot;&quot;</span></span><br><span class="line">    text = models.CharField(max_length=<span class="number">200</span>) <span class="comment"># 1. 字符字段</span></span><br><span class="line">    date_added = models.DateTimeField(auto_now_add=<span class="literal">True</span>) <span class="comment"># 2. 日期时间字段</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;返回模型的字符串表示&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.text</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entry</span>(models.Model):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;学到的有关某个主题的具体知识&quot;&quot;&quot;</span></span><br><span class="line">    topic = models.ForeignKey(Topic, on_delete=models.CASCADE) <span class="comment"># 3. 外键</span></span><br><span class="line">    text = models.TextField() <span class="comment"># 4. 文本字段</span></span><br><span class="line">    date_added = models.DateTimeField(auto_now_add=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Meta</span>:</span><br><span class="line">        verbose_name_plural = <span class="string">&#x27;entries&#x27;</span> <span class="comment"># 5. 定义复数形式</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;<span class="subst">&#123;self.text[:<span class="number">50</span>]&#125;</span>...&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>细节解析：</strong></p>
<pre><code>- **文件**：`learning_logs/models.py`
- **概念**：模型是数据的**唯一、确切的信息来源**。它是一个Python类，定义了数据的字段和行为。Django会根据模型自动创建数据库表。
1. `CharField`：用于存储较短的文本，如标题。`max_length`是必需参数。
2. `DateTimeField`：用于存储日期和时间。`auto_now_add=True`表示在创建对象时自动设置为当前时间。
3. `ForeignKey`：**外键**，用于建立两个模型之间的**多对一**关系。这里表示一个`Entry`关联到一个`Topic`，而一个`Topic`可以有多个`Entry`。`on_delete=models.CASCADE`表示当关联的`Topic`被删除时，所有相关的`Entry`也会被级联删除。
4. `TextField`：用于存储大量文本，没有长度限制。
5. `Meta`类：用于存储模型的元数据。`verbose_name_plural`用于指定模型的复数形式，在管理后台中会用到。
</code></pre>
<ol start="3">
<li><strong>激活模型</strong>：<ol>
<li><strong>在</strong><code>settings.py</code><strong>中注册应用</strong>：将 <code>&#39;learning_logs&#39;,</code> 添加到<code>INSTALLED_APPS</code>列表中。</li>
<li><strong>为模型创建迁移</strong>：<code>python manage.py makemigrations learning_logs</code>。Django会检测模型的改动，并生成一个迁移文件。</li>
<li><strong>应用迁移</strong>：<code>python manage.py migrate</code>。将迁移应用到数据库，创建新的数据表。</li>
</ol>
</li>
<li><strong>Django管理网站</strong>：<ul>
<li><strong>创建超级用户</strong>：<code>python manage.py createsuperuser</code>，然后按提示设置用户名和密码。</li>
<li><strong>注册模型</strong>：在<code>learning_logs/admin.py</code>中注册你的模型，这样它们才会出现在管理后台中。</li>
</ul>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># learning_logs/admin.py</span></span><br><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> Topic, Entry</span><br><span class="line"></span><br><span class="line">admin.site.register(Topic)</span><br><span class="line">admin.site.register(Entry)</span><br></pre></td></tr></table></figure>

<pre><code>- **使用**：运行开发服务器，访问`http://localhost:8000/admin/`，用超级用户登录后，就可以通过图形界面来添加、修改和删除`Topic`和`Entry`了。
</code></pre>
<h4 id="18-3-创建网页"><a href="#18-3-创建网页" class="headerlink" title="18.3 创建网页"></a><strong>18.3 创建网页</strong></h4><p>创建网页通常分为三个步骤：定义URL、编写视图、创建模板。</p>
<ol>
<li><strong>定义URL模式</strong>：<ul>
<li><strong>项目URL配置 (</strong><code>ll_project/urls.py</code><strong>)</strong>：这是项目的总路由。我们需要在这里包含应用的URL配置。</li>
</ul>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ll_project/urls.py</span></span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path, include</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&#x27;admin/&#x27;</span>, admin.site.urls),</span><br><span class="line">    path(<span class="string">&#x27;&#x27;</span>, include(<span class="string">&#x27;learning_logs.urls&#x27;</span>)), <span class="comment"># 包含应用的urls</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<pre><code>- **应用URL配置 (**`learning_logs/urls.py`**)**：为应用创建这个新文件，定义该应用内的具体URL。
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># learning_logs/urls.py</span></span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> views</span><br><span class="line"></span><br><span class="line">app_name = <span class="string">&#x27;learning_logs&#x27;</span> <span class="comment"># 1. 定义命名空间</span></span><br><span class="line">urlpatterns = [</span><br><span class="line">    <span class="comment"># 主页</span></span><br><span class="line">    path(<span class="string">&#x27;&#x27;</span>, views.index, name=<span class="string">&#x27;index&#x27;</span>), <span class="comment"># 2. URL模式</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong>细节解析：</strong></p>
<pre><code>    1. `app_name`：定义了一个**命名空间**，可以防止不同应用之间URL名称的冲突。
    2. `path()`：第一个参数是URL模式（空字符串`&#39;&#39;`匹配根URL），第二个参数是处理该URL的**视图函数**，第三个参数是该URL模式的**名称**。
</code></pre>
<ol start="2">
<li><strong>编写视图 (Views)</strong>：<ul>
<li><strong>文件</strong>：<code>learning_logs/views.py</code></li>
<li><strong>功能</strong>：视图函数接收HTTP请求，处理业务逻辑，并返回一个HTTP响应（通常是渲染一个HTML页面）。</li>
</ul>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># learning_logs/views.py</span></span><br><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;学习笔记的主页&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">&#x27;learning_logs/index.html&#x27;</span>)</span><br></pre></td></tr></table></figure>

<pre><code>    * `render()`函数会结合**数据（可选）****和****模板**来生成一个完整的HTML页面。
</code></pre>
<ol start="3">
<li><strong>创建模板 (Templates)</strong>：<ul>
<li><strong>文件结构</strong>：在<code>learning_logs</code>应用目录下创建<code>templates/learning_logs/</code>文件夹，并将模板文件放在这里。</li>
<li><code>base.html</code>** (父模板)**：创建一个基础模板，包含所有页面的公共部分（如页头、导航栏）。</li>
</ul>
</li>
</ol>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- base.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&#123;% url &#x27;learning_logs:index&#x27; %&#125;&quot;</span>&gt;</span>Learning Log<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&#123;% block content %&#125;&#123;% endblock content %&#125;</span><br></pre></td></tr></table></figure>

<pre><code>- `index.html`** (子模板)**：继承父模板，并填充具体内容。
</code></pre>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- index.html --&gt;</span></span><br><span class="line">&#123;% extends &quot;learning_logs/base.html&quot; %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block content %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Learning Log helps you keep track of your learning...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&#123;% endblock content %&#125;</span><br></pre></td></tr></table></figure>

<p><strong>细节解析：</strong></p>
<pre><code>    * **模板标签 **`&#123;% %&#125;`：用于执行逻辑，如`extends`（继承）、`block`（定义块）。
    * `&#123;% url 'namespace:name' %&#125;`：这是Django模板中一个极其重要的标签，它会根据URL配置**动态地生成URL**。这比硬编码URL更可靠。
</code></pre>
<hr>
<h3 id="第19章：用户账户"><a href="#第19章：用户账户" class="headerlink" title="第19章：用户账户"></a><strong>第19章：用户账户</strong></h3><p><strong>本章核心目标：</strong> 在项目上添加完整的用户系统，让用户可以注册、登录、注销，并确保用户只能看到和修改自己的数据。</p>
<h4 id="19-1-让用户能够输入数据"><a href="#19-1-让用户能够输入数据" class="headerlink" title="19.1 让用户能够输入数据"></a><strong>19.1 让用户能够输入数据</strong></h4><ol>
<li><strong>Django表单 (Forms)</strong><ul>
<li><code>ModelForm</code>：一种强大的工具，可以根据你定义的模型<strong>自动生成表单</strong>。</li>
<li><strong>创建</strong><code>forms.py</code><strong>文件</strong>：</li>
</ul>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># learning_logs/forms.py</span></span><br><span class="line"><span class="keyword">from</span> django <span class="keyword">import</span> forms</span><br><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> Topic</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TopicForm</span>(forms.ModelForm):</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Meta</span>:</span><br><span class="line">        model = Topic  <span class="comment"># 基于哪个模型</span></span><br><span class="line">        fields = [<span class="string">&#x27;text&#x27;</span>] <span class="comment"># 表单中包含哪些字段</span></span><br><span class="line">        labels = &#123;<span class="string">&#x27;text&#x27;</span>: <span class="string">&#x27;&#x27;</span>&#125; <span class="comment"># 为字段text生成一个空标签</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>创建“添加新主题”的页面</strong>：<ul>
<li><strong>URL</strong>：在<code>learning_logs/urls.py</code>中添加一个新路径，如<code>path(&#39;new_topic/&#39;, views.new_topic, name=&#39;new_topic&#39;)</code>。</li>
<li>**视图 **<code>new_topic()</code>：</li>
</ul>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># learning_logs/views.py</span></span><br><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render, redirect</span><br><span class="line"><span class="keyword">from</span> .forms <span class="keyword">import</span> TopicForm</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">new_topic</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="keyword">if</span> request.method != <span class="string">&#x27;POST&#x27;</span>:</span><br><span class="line">        form = TopicForm() <span class="comment"># GET请求，创建空表单</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        form = TopicForm(data=request.POST) <span class="comment"># POST请求，用用户数据创建表单</span></span><br><span class="line">        <span class="keyword">if</span> form.is_valid(): <span class="comment"># 验证数据</span></span><br><span class="line">            form.save() <span class="comment"># 保存到数据库</span></span><br><span class="line">            <span class="keyword">return</span> redirect(<span class="string">&#x27;learning_logs:topics&#x27;</span>) <span class="comment"># 重定向到主题列表页</span></span><br><span class="line"></span><br><span class="line">    context = &#123;<span class="string">&#x27;form&#x27;</span>: form&#125;</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">&#x27;learning_logs/new_topic.html&#x27;</span>, context)</span><br></pre></td></tr></table></figure>

<pre><code>    * 这个视图需要处理两种请求：**GET**（用户第一次访问页面，显示空表单）和**POST**（用户提交了填写好的表单）。
    * 通过`request.method`来区分。
- **模板 **`new_topic.html`：
</code></pre>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- new_topic.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;&#123;% url &#x27;learning_logs:new_topic&#x27; %&#125;&quot;</span> <span class="attr">method</span>=<span class="string">&#x27;post&#x27;</span>&gt;</span></span><br><span class="line">    &#123;% csrf_token %&#125; <span class="comment">&lt;!-- 安全令牌，防止CSRF攻击 --&gt;</span></span><br><span class="line">    &#123;&#123; form.as_p &#125;&#125; <span class="comment">&lt;!-- 将表单渲染为&lt;p&gt;标签 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">name</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>Add topic<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="19-2-创建用户账户"><a href="#19-2-创建用户账户" class="headerlink" title="19.2 创建用户账户"></a><strong>19.2 创建用户账户</strong></h4><ol>
<li><strong>创建</strong><code>accounts</code><strong>应用</strong>：<code>python manage.py startapp accounts</code>。</li>
<li><strong>包含</strong><code>accounts</code><strong>的URL</strong>：在项目主<code>urls.py</code>中添加<code>path(&#39;accounts/&#39;, include(&#39;accounts.urls&#39;))</code>。</li>
<li><strong>使用Django内置的认证URL</strong>：</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># accounts/urls.py</span></span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path, include</span><br><span class="line"></span><br><span class="line">app_name = <span class="string">&#x27;accounts&#x27;</span></span><br><span class="line">urlpatterns = [</span><br><span class="line">    <span class="comment"># 包含默认的身份验证URL</span></span><br><span class="line">    path(<span class="string">&#x27;&#x27;</span>, include(<span class="string">&#x27;django.contrib.auth.urls&#x27;</span>)),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<pre><code>- 这会自动为我们提供登录 (`login`)、注销 (`logout`) 等页面的URL和视图。
</code></pre>
<ol start="4">
<li><strong>创建登录模板</strong>：在<code>accounts/templates/registration/login.html</code>中创建模板。Django的认证系统会自动在这个路径下查找模板。</li>
<li><strong>创建注册页面</strong>：<ul>
<li><strong>URL</strong>: 在<code>accounts/urls.py</code>中添加<code>path(&#39;register/&#39;, views.register, name=&#39;register&#39;)</code>。</li>
<li>**视图 **<code>register()</code>:</li>
</ul>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># accounts/views.py</span></span><br><span class="line"><span class="keyword">from</span> django.contrib.auth <span class="keyword">import</span> login</span><br><span class="line"><span class="keyword">from</span> django.contrib.auth.forms <span class="keyword">import</span> UserCreationForm</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">register</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="keyword">if</span> request.method != <span class="string">&#x27;POST&#x27;</span>:</span><br><span class="line">        form = UserCreationForm()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        form = UserCreationForm(data=request.POST)</span><br><span class="line">        <span class="keyword">if</span> form.is_valid():</span><br><span class="line">            new_user = form.save()</span><br><span class="line">            login(request, new_user) <span class="comment"># 注册后自动登录</span></span><br><span class="line">            <span class="keyword">return</span> redirect(<span class="string">&#x27;learning_logs:index&#x27;</span>)</span><br><span class="line">    <span class="comment"># ...</span></span><br></pre></td></tr></table></figure>

<pre><code>- **模板 **`register.html`: 结构与`login.html`类似。
</code></pre>
<h4 id="19-3-让用户拥有自己的数据"><a href="#19-3-让用户拥有自己的数据" class="headerlink" title="19.3 让用户拥有自己的数据"></a><strong>19.3 让用户拥有自己的数据</strong></h4><ol>
<li><strong>限制访问 (</strong><code>@login_required</code><strong>)</strong><ul>
<li><strong>装饰器 (Decorator)</strong>：是一种修改函数行为的简便方法。</li>
<li>在<code>views.py</code>中，在需要保护的视图函数前加上<code>@login_required</code>，未登录的用户访问时会自动被重定向到登录页面。</li>
</ul>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib.auth.decorators <span class="keyword">import</span> login_required</span><br><span class="line"></span><br><span class="line"><span class="meta">@login_required</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">topics</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="comment"># ...</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>将数据关联到用户</strong>：<ul>
<li><strong>修改</strong><code>Topic</code><strong>模型</strong>：添加一个外键，将其与<code>User</code>模型关联。</li>
</ul>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># learning_logs/models.py</span></span><br><span class="line"><span class="keyword">from</span> django.contrib.auth.models <span class="keyword">import</span> User</span><br><span class="line"><span class="comment"># ... in class Topic ...</span></span><br><span class="line">owner = models.ForeignKey(User, on_delete=models.CASCADE)</span><br></pre></td></tr></table></figure>

<pre><code>- **数据迁移**：修改模型后，必须再次运行`makemigrations`和`migrate`。
</code></pre>
<ol start="3">
<li><strong>只显示用户自己的数据</strong>：<ul>
<li>在视图函数中，使用<code>.filter()</code>来查询只属于当前登录用户的数据。</li>
</ul>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># learning_logs/views.py (in topics view)</span></span><br><span class="line">topics = Topic.objects.<span class="built_in">filter</span>(owner=request.user).order_by(<span class="string">&#x27;date_added&#x27;</span>)</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><strong>确保新主题属于当前用户</strong>：<ul>
<li>在<code>new_topic</code>视图中，保存表单前，将新主题的<code>owner</code>属性设置为当前用户。</li>
</ul>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="keyword">if</span> form.is_valid():</span><br><span class="line">    new_topic = form.save(commit=<span class="literal">False</span>) <span class="comment"># 先不保存到数据库</span></span><br><span class="line">    new_topic.owner = request.user <span class="comment"># 设置所有者</span></span><br><span class="line">    new_topic.save() <span class="comment"># 再保存</span></span><br><span class="line">    <span class="keyword">return</span> redirect(<span class="string">&#x27;learning_logs:topics&#x27;</span>)</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><strong>保护页面</strong>：确保用户不能通过手动输入URL的方式访问或编辑<strong>其他用户</strong>的数据。在视图中进行检查：</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ... in topic view ...</span></span><br><span class="line"><span class="keyword">if</span> topic.owner != request.user:</span><br><span class="line">    <span class="keyword">raise</span> Http404</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="第20章：设置应用程序的样式并部署"><a href="#第20章：设置应用程序的样式并部署" class="headerlink" title="第20章：设置应用程序的样式并部署"></a><strong>第20章：设置应用程序的样式并部署</strong></h3><p><strong>本章核心目标：</strong> 美化我们的Web应用，并将其发布到互联网上，让全世界的人都能访问。</p>
<h4 id="20-1-设置样式-Bootstrap"><a href="#20-1-设置样式-Bootstrap" class="headerlink" title="20.1 设置样式 (Bootstrap)"></a><strong>20.1 设置样式 (Bootstrap)</strong></h4><ol>
<li><strong>Bootstrap简介</strong>：一个流行的前端框架，提供了一套CSS样式和JavaScript组件，可以快速构建出美观且<strong>响应式</strong>（在手机、平板、电脑上都能良好显示）的网页。</li>
<li><strong>使用</strong><code>django-bootstrap5</code>：<ul>
<li>安装：<code>pip install django-bootstrap5</code>。</li>
<li>在<code>settings.py</code>的<code>INSTALLED_APPS</code>中添加<code>&#39;django_bootstrap5&#39;</code>。</li>
</ul>
</li>
<li><strong>修改模板</strong>：<ul>
<li><code>base.html</code>：<ol>
<li>在文件顶部加载<code>bootstrap5</code>标签：<code>&#123;% load django_bootstrap5 %&#125;</code>。</li>
<li>在<code>&lt;head&gt;</code>中加载CSS和JS文件：<code>&#123;% bootstrap_css %&#125;</code> 和 <code>&#123;% bootstrap_javascript %&#125;</code>。</li>
<li>使用Bootstrap提供的HTML结构和CSS类（如<code>navbar</code>, <code>container</code>, <code>btn</code>）来构建导航栏和页面布局。</li>
</ol>
</li>
<li><strong>其他模板</strong>：使用Bootstrap的CSS类（如<code>card</code>, <code>list-group</code>）来美化表单、列表等元素。</li>
<li><strong>表单样式</strong>：使用<code>&#123;% bootstrap_form form %&#125;</code>标签可以自动为表单应用Bootstrap样式。</li>
</ul>
</li>
</ol>
<h4 id="20-2-部署-Platform-sh"><a href="#20-2-部署-Platform-sh" class="headerlink" title="20.2 部署 (Platform.sh)"></a><strong>20.2 部署 (Platform.sh)</strong></h4><p>部署是将我们的本地项目上传到一台24小时运行的<strong>Web服务器</strong>上的过程。</p>
<ol>
<li><strong>选择托管平台</strong>：书中选择了Platform.sh，但原理适用于Heroku, AWS等其他平台。</li>
<li><strong>部署前的准备</strong>：<ul>
<li><code>requirements.txt</code>：创建一个文件，列出项目的所有Python依赖库。</li>
</ul>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip freeze &gt; requirements.txt</span><br></pre></td></tr></table></figure>

<pre><code>- **配置文件**：为部署平台创建特定的配置文件（如`.platform.app.yaml`），告诉平台如何构建和运行我们的Django项目。
- **修改**`settings.py`：添加线上环境的特定配置，比如允许的主机名、数据库设置，并将`DEBUG`设为`False`（**极其重要，为了安全**）。
</code></pre>
<ol start="3">
<li><strong>使用Git进行版本控制</strong>：<ul>
<li><code>git</code>：是一个版本控制系统，用于跟踪代码的修改历史。</li>
<li><strong>基本流程</strong>：<ol>
<li><code>git init</code>: 初始化一个本地仓库。</li>
<li>创建<code>.gitignore</code>文件，告诉Git忽略哪些文件（如虚拟环境、数据库文件）。</li>
<li><code>git add .</code>: 将所有文件添加到暂存区。</li>
<li><code>git commit -m &quot;Initial commit&quot;</code>: 创建一个提交（快照）。</li>
</ol>
</li>
</ul>
</li>
<li><strong>部署到Platform.sh</strong><ul>
<li><strong>安装Platform.sh CLI</strong>：安装平台的命令行工具。</li>
<li><strong>创建项目</strong>：在Platform.sh上创建一个新项目。</li>
<li><strong>推送代码</strong>：使用<code>platform push</code>（或<code>git push</code>）将你的本地Git仓库推送到Platform.sh的远程服务器上。</li>
<li>平台会自动读取配置文件，安装依赖，运行迁移，并启动你的应用。</li>
</ul>
</li>
<li><strong>创建定制错误页面</strong>：创建<code>404.html</code>和<code>500.html</code>模板，当出现页面未找到或服务器内部错误时，向用户显示友好的错误页面，而不是调试信息。</li>
</ol>
<hr>
<h4 id="项目总结-1"><a href="#项目总结-1" class="headerlink" title="项目总结"></a><strong>项目总结</strong></h4><p>项目三是一个完整而深入的实践。通过它，我不仅学会了使用<strong>Django</strong>这个强大的框架来构建Web应用，还掌握了Web开发的整个生命周期：从<strong>规划、建模、开发，到样式设计，最终部署上线</strong>。我理解了<strong>模型-视图-模板（MVT）这一核心设计模式，学会了如何处理用户输入和认证，并意识到了在生产环境中安全配置</strong>（如<code>DEBUG=False</code>）的重要性。将项目部署到真实的服务器上，并获得一个公开的网址，这种成就感是前所未有的。这个项目为我进一步深入Web开发领域打下了坚实的基础。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://penggehero.github.io/2025/08/20/%E3%80%90Python%E7%BC%96%E7%A8%8B%EF%BC%9A%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5%E3%80%91-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="penggewu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="云泽的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/08/20/%E3%80%90Python%E7%BC%96%E7%A8%8B%EF%BC%9A%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5%E3%80%91-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">【Python编程：从入门到实践】-基础知识-读书笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-08-20 17:21:06 / 修改时间：19:17:06" itemprop="dateCreated datePublished" datetime="2025-08-20T17:21:06+08:00">2025-08-20</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="【Python编程：从入门到实践】-基础知识-读书笔记"><a href="#【Python编程：从入门到实践】-基础知识-读书笔记" class="headerlink" title="【Python编程：从入门到实践】-基础知识-读书笔记"></a>【Python编程：从入门到实践】-基础知识-读书笔记</h1><blockquote>
<p>根据 <a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E9%81%97%E5%BF%98%E6%9B%B2%E7%BA%BF/7278665?fr=aladdin">遗忘曲线</a>：如果没有记录和回顾，6天后便会忘记75%的内容</p>
<p>  读书笔记正是帮助你记录和回顾的工具，不必拘泥于形式，其核心是：记录、翻看、思考</p>
</blockquote>
<table>
<thead>
<tr>
<th><strong>书名</strong></th>
<th>Python编程：从入门到实践（第3版）</th>
</tr>
</thead>
<tbody><tr>
<td><strong>原版书名</strong></td>
<td>Python Crash Course, 3rd Edition</td>
</tr>
<tr>
<td><strong>作者</strong></td>
<td><font style="color:rgb(26, 28, 30);background-color:rgb(252, 252, 252);">[美] 埃里克·马瑟斯 (Eric Matthes)</font></td>
</tr>
<tr>
<td><strong>译者</strong></td>
<td>袁国忠</td>
</tr>
<tr>
<td><strong>状态</strong></td>
<td><font style="background:#DBF1B7;color:#2A4200">已读完</font></td>
</tr>
<tr>
<td><strong>简介</strong></td>
<td><strong>Python入门经典，用三大项目实战，带你从零快速上手。</strong></td>
</tr>
</tbody></table>
<h3 id="第一章：起步"><a href="#第一章：起步" class="headerlink" title="第一章：起步"></a><strong>第一章：起步</strong></h3><h4 id="核心概要"><a href="#核心概要" class="headerlink" title="核心概要"></a><strong>核心概要</strong></h4><p>本章是进入Python编程世界的“启动仪式”。它并不涉及复杂的编程理论，而是专注于<strong>搭建一个稳定、可靠的编程环境</strong>。作者认为，一个顺畅的开端至关重要，如果在环境配置上遇到过多挫折，很容易打击学习热情。因此，本章的目标非常明确：确保我们能够在自己的计算机上成功安装Python、配置好编辑器，并顺利运行第一个简单的程序——<code>hello_world.py</code>。</p>
<hr>
<h4 id="关键知识点与学习心得"><a href="#关键知识点与学习心得" class="headerlink" title="关键知识点与学习心得"></a><strong>关键知识点与学习心得</strong></h4><ol>
<li><strong>编程环境的重要性</strong><ul>
<li><strong>知识点</strong>：本章强调，不同的操作系统（Windows, macOS, Linux）在Python的安装和使用上存在细微差别。一个配置正确的环境是后续所有学习和实践的基础。</li>
<li><strong>心得</strong>：这部分打消了我对环境配置的恐惧。作者没有直接堆砌命令，而是先解释“为什么要做”，再告诉我们“怎么做”。这让我明白，磨刀不误砍柴工，花时间把环境弄好，是为了以后能更专注于编程逻辑本身。</li>
</ul>
</li>
<li><strong>Python版本选择</strong><ul>
<li><strong>知识点</strong>：书中推荐使用Python 3.9或更高的版本。作者明确指出，虽然旧系统可能预装了Python 2，但现在应该始终使用Python 3。</li>
<li><strong>心得</strong>：版本选择是初学者常遇到的第一个坑。书里给出了明确的指引，避免了我在版本兼容性问题上走弯路。</li>
</ul>
</li>
<li><strong>文本编辑器VS Code简介</strong><ul>
<li><strong>知识点</strong>：本章推荐使用VS Code（Visual Studio Code）作为代码编辑器。它功能强大、免费，并且对初学者友好。书中提到了它的一些优点，如语法高亮、跨平台支持，并建议安装Python扩展来增强功能。</li>
<li><strong>心得</strong>：之前我以为随便一个记事本就能写代码。读完这部分才明白，一个好的编辑器能极大地提升效率和代码可读性。语法高亮功能尤其有用，它能让我一眼就看出哪里是函数，哪里是字符串，有效减少拼写错误。</li>
</ul>
</li>
<li><strong>各操作系统下的安装流程</strong><ul>
<li><strong>知识点</strong>：书中为Windows、macOS和Linux三大主流操作系统提供了详细、分步骤的安装指南。<ul>
<li><strong>Windows</strong>：通常需要从Python官网下载安装包，并在安装时务必勾选 “Add Python to PATH” 选项。</li>
<li><strong>macOS</strong>：同样建议从官网安装，并注意使用 <code>python3</code> 命令来区分系统可能自带的旧版本。</li>
<li><strong>Linux</strong>：大多自带Python，但需要检查版本，并可能需要通过包管理器（如apt）安装最新版。</li>
</ul>
</li>
<li><strong>心得</strong>：这部分内容非常实用，就像一份手把手的操作手册。特别是 “Add Python to PATH” 这个提醒，解决了我在网上看其他教程时遇到的“命令无法识别”的经典问题。</li>
</ul>
</li>
<li><strong>第一个程序：</strong><code>hello_world.py</code><ul>
<li><strong>知识点</strong>：通过编写并运行一个只包含一行代码 <code>print(&quot;Hello Python world!&quot;)</code> 的程序，来验证整个环境是否配置成功。这个简单的程序如果能跑通，就意味着更复杂的程序也能正常运行。</li>
<li><strong>心得</strong>：这不仅仅是打印一句话那么简单，它更像是一个“点火测试”。当我看到终端成功输出 “Hello Python world!” 时，心中充满了成就感。这个正向反馈极大地鼓舞了我继续学习的信心。</li>
</ul>
</li>
<li><strong>从终端运行程序</strong><ul>
<li><strong>知识点</strong>：除了在VS Code中直接运行，本章还教学了如何在终端（或命令行）中通过 <code>cd</code> 命令切换目录，并使用 <code>python hello_world.py</code> (或 <code>python3</code>) 的方式来执行程序。</li>
<li><strong>心得</strong>：这让我了解到运行Python程序的两种主要方式。虽然在开发初期，编辑器的一键运行更方便，但学会使用终端是成为一名合格程序员的必经之路，尤其是在未来部署和管理项目时。</li>
</ul>
</li>
<li><strong>排除安装问题</strong><ul>
<li><strong>知识点</strong>：作者非常贴心地提供了一个故障排除清单，比如检查拼写、重新来过、寻求他人或在线社区的帮助等。</li>
<li><strong>心得</strong>：这部分让我感到很温暖。作者预见到了初学者可能遇到的困难，并提供了解决问题的思路，而不是简单地假设一切顺利。这让我明白，遇到问题是正常的，关键在于如何解决它。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="总结与反思"><a href="#总结与反思" class="headerlink" title="总结与反思"></a><strong>总结与反思</strong></h4><p>第一章虽然没有教授高深的编程技巧，但它的价值在于<strong>建立自信和扫清障碍</strong>。它像一位经验丰富的向导，带领我走出了学习编程的第一里路。通过亲手搭建环境并成功运行第一个程序，我不仅验证了工具的可用性，更重要的是，我在心理上完成了从“旁观者”到“实践者”的角色转变。</p>
<p>本章的学习为我后续的所有章节打下了坚实的基础。现在，我的“实验室”已经准备就绪，可以开始进行真正的“化学实验”了。</p>
<h3 id="第二章：变量和简单的数据类型"><a href="#第二章：变量和简单的数据类型" class="headerlink" title="第二章：变量和简单的数据类型"></a><strong>第二章：变量和简单的数据类型</strong></h3><h4 id="核心概要-1"><a href="#核心概要-1" class="headerlink" title="核心概要"></a><strong>核心概要</strong></h4><p>本章是Python编程的正式起点，深入讲解了程序处理信息的基本方式。核心内容围绕**变量（Variables）<strong><strong>的创建与使用，以及两种最基础的</strong></strong>数据类型（Data Types）**：**字符串（String）<strong><strong>和</strong></strong>数字（Number）**。本章详细阐述了如何命名变量、避免常见错误、操作文本数据、执行数学运算，并引入了注释和Python的设计哲学“Python之禅”，旨在为编写清晰、规范的代码打下坚实基础。</p>
<hr>
<h4 id="2-1-2-2-变量（Variables）"><a href="#2-1-2-2-变量（Variables）" class="headerlink" title="2.1 &amp; 2.2 变量（Variables）"></a><strong>2.1 &amp; 2.2 变量（Variables）</strong></h4><p><strong>1. 变量的定义与使用</strong></p>
<ul>
<li><strong>核心概念</strong>：变量是赋予某个值的“标签”。通过变量，我们可以存储和引用程序中的信息。</li>
<li><strong>代码示例</strong>：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">message = <span class="string">&quot;Hello Python world!&quot;</span></span><br><span class="line"><span class="built_in">print</span>(message)</span><br><span class="line"></span><br><span class="line">message = <span class="string">&quot;Hello Python Crash Course world!&quot;</span></span><br><span class="line"><span class="built_in">print</span>(message)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>关键点</strong>：可以随时修改变量的值，Python会记录最新的赋值。</li>
</ul>
<p><strong>2. 变量的命名规则与规范</strong></p>
<ul>
<li><strong>硬性规则（必须遵守，否则报错）</strong>：<ul>
<li>变量名只能包含字母、数字和下划线 (<code>_</code>)。</li>
<li>不能以数字开头。</li>
<li>不能包含空格，应使用下划线分隔单词。</li>
<li>不能使用Python的<strong>关键字</strong>（如 <code>print</code>, <code>if</code>, <code>for</code>）和函数名作为变量名。</li>
</ul>
</li>
<li><strong>编程规范（建议遵守，提高代码可读性）</strong>：<ul>
<li>变量名应使用小写，单词间用下划线连接（<strong>蛇形命名法</strong>），如 <code>greeting_message</code>。</li>
<li>变量名应简短且具有描述性，如 <code>name</code> 好于 <code>n</code>。</li>
<li>慎用小写字母 <code>l</code> 和大写字母 <code>O</code>，因为它们容易和数字 <code>1</code> 和 <code>0</code> 混淆。</li>
</ul>
</li>
</ul>
<p><strong>3. 避免命名错误 (</strong><code>NameError</code><strong>)</strong></p>
<ul>
<li><strong>知识点</strong>：当使用一个未定义或拼写错误的变量时，Python会引发 <code>NameError</code>。</li>
<li><strong>调试技巧</strong>：Python的错误追踪信息（traceback）非常有用。它会明确指出：<ol>
<li>错误发生的文件名和行号。</li>
<li>出错的代码行。</li>
<li>具体的错误类型和描述，有时甚至会<strong>智能地提示可能的正确拼写</strong>。</li>
</ol>
<ul>
<li><strong>示例</strong>：如果将 <code>message</code> 错拼为 <code>mesage</code>，错误提示会是：<code>NameError: name &#39;mesage&#39; is not defined. Did you mean: &#39;message&#39;?</code></li>
</ul>
</li>
<li><strong>心得</strong>：学会阅读traceback是编程中最重要的技能之一。它不是在“骂你”，而是在“帮你”。</li>
</ul>
<p><strong>4. 变量是标签（重要概念）</strong></p>
<ul>
<li><strong>知识点</strong>：书中特别强调，将变量理解为指向特定值的<strong>标签</strong>，比理解为装东西的<strong>盒子</strong>更准确。这个概念有助于未来理解更复杂的编程行为。</li>
</ul>
<hr>
<h4 id="2-3-字符串（String）"><a href="#2-3-字符串（String）" class="headerlink" title="2.3 字符串（String）"></a><strong>2.3 字符串（String）</strong></h4><p>字符串是一系列字符，用于表示文本。</p>
<p><strong>1. 定义字符串</strong></p>
<ul>
<li><strong>语法</strong>：可以使用单引号 (<code>&#39;</code>) 或双引号 (<code>&quot;</code>)。这种灵活性使得在字符串中可以方便地包含另一种引号。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;I told my friend, &quot;Python is my favorite language!&quot;&#x27;</span></span><br><span class="line"><span class="string">&quot;The language &#x27;Python&#x27; is named after Monty Python.&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>2. 修改字符串大小写（方法 Method）</strong></p>
<ul>
<li><strong>概念</strong>：方法是Python可对数据执行的操作，通过 <code>变量名.方法名()</code> 的形式调用。</li>
<li><strong>常用方法</strong>：<ul>
<li><code>.title()</code>：将每个单词的首字母改为大写。</li>
<li><code>.upper()</code>：将整个字符串改为大写。</li>
<li><code>.lower()</code>：将整个字符串改为小写。这在存储用户数据前进行统一格式化时非常有用。</li>
</ul>
</li>
</ul>
<p><strong>3. f-字符串 (f-strings)</strong></p>
<ul>
<li><strong>功能</strong>：一种强大且简洁的字符串格式化方法，用于在字符串中嵌入变量的值。</li>
<li><strong>语法</strong>：在字符串的起始引号前加上字母 <code>f</code>，然后将变量名放在花括号 <code>&#123;&#125;</code> 中。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">first_name = <span class="string">&quot;ada&quot;</span></span><br><span class="line">last_name = <span class="string">&quot;lovelace&quot;</span></span><br><span class="line">full_name = <span class="string">f&quot;<span class="subst">&#123;first_name&#125;</span> <span class="subst">&#123;last_name&#125;</span>&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Hello, <span class="subst">&#123;full_name.title()&#125;</span>!&quot;</span>) <span class="comment"># 输出: Hello, Ada Lovelace!</span></span><br></pre></td></tr></table></figure>

<p><strong>4. 处理空白</strong></p>
<ul>
<li><strong>添加空白</strong>：<ul>
<li><code>\t</code>：添加制表符（一个Tab缩进）。</li>
<li><code>\n</code>：添加换行符。</li>
</ul>
</li>
<li><strong>删除空白</strong>：这些方法<strong>不改变原始字符串</strong>，而是返回一个修改后的新字符串。<ul>
<li><code>.rstrip()</code>：删除字符串末尾的空白。</li>
<li><code>.lstrip()</code>：删除字符串开头的空白。</li>
<li><code>.strip()</code>：删除字符串两端的空白。</li>
<li><strong>重要</strong>：要永久删除空白，必须将结果重新赋给原变量：<code>favorite_language = favorite_language.strip()</code>。</li>
</ul>
</li>
</ul>
<p><strong>5. 删除前缀&#x2F;后缀</strong></p>
<ul>
<li><code>.removeprefix(&#39;prefix&#39;)</code>：如果字符串以前缀开头，则删除此前缀并返回新字符串。</li>
<li><code>.removesuffix(&#39;suffix&#39;)</code>：同理，删除后缀。</li>
</ul>
<p><strong>6. 避免语法错误 (</strong><code>SyntaxError</code><strong>)</strong></p>
<ul>
<li><strong>常见原因</strong>：字符串中的撇号与用于定义字符串的单引号冲突。</li>
<li><strong>解决方法</strong>：如果字符串内包含单引号，则使用双引号来定义整个字符串。</li>
</ul>
<hr>
<h4 id="2-4-数字（Number）"><a href="#2-4-数字（Number）" class="headerlink" title="2.4 数字（Number）"></a><strong>2.4 数字（Number）</strong></h4><p><strong>1. 整数 (Integer)</strong></p>
<ul>
<li><strong>运算</strong>：支持加 (<code>+</code>)、减 (<code>-</code>)、乘 (<code>*</code>)、除 (<code>/</code>)、乘方 (<code>**</code>)。</li>
<li><strong>注意</strong>：除法运算 (<code>/</code>) 的结果<strong>始终是浮点数</strong>，即使两个数能整除（如 <code>4 / 2</code> 结果是 <code>2.0</code>）。</li>
</ul>
<p><strong>2. 浮点数 (Float)</strong></p>
<ul>
<li><strong>定义</strong>：任何带小数点的数。</li>
<li><strong>重要提醒</strong>：浮点数运算的结果可能存在不确定的小数位数（如 <code>0.2 + 0.1</code> 得到 <code>0.30000000000000004</code>），这是由计算机内部存储数字的方式决定的，需要注意。</li>
</ul>
<p><strong>3. 数字中的下划线</strong></p>
<ul>
<li><strong>功能</strong>：为了让长数字更易读，可以在数字中使用下划线。Python在处理时会自动忽略它们。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">universe_age = <span class="number">14_000_000_000</span> </span><br></pre></td></tr></table></figure>

<p><strong>4. 多重赋值</strong></p>
<ul>
<li><strong>语法</strong>：可以在一行代码中给多个变量赋值。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x, y, z = <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p><strong>5. 常量 (Constant)</strong></p>
<ul>
<li><strong>约定</strong>：Python没有内置的常量类型，但程序员有一个普遍的约定：<strong>用全大写的变量名来表示常量</strong>，意在提醒任何阅读代码的人这个值不应被修改。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MAX_CONNECTIONS = <span class="number">5000</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="2-5-2-6-代码风格与哲学"><a href="#2-5-2-6-代码风格与哲学" class="headerlink" title="2.5 &amp; 2.6 代码风格与哲学"></a><strong>2.5 &amp; 2.6 代码风格与哲学</strong></h4><p><strong>1. 注释 (Comment)</strong></p>
<ul>
<li><strong>语法</strong>：以井号 (<code>#</code>) 开头，Python会忽略该行井号之后的所有内容。</li>
<li><strong>目的</strong>：解释代码的逻辑和意图，提高代码的可读性。</li>
</ul>
<p><strong>2. Python之禅 (The Zen of Python)</strong></p>
<ul>
<li><strong>调用方式</strong>：在Python终端中输入 <code>import this</code>。</li>
<li><strong>核心理念</strong>：这是Python语言的设计哲学，指导我们编写出优雅、简洁、易读的代码。<ul>
<li><strong>优美优于丑陋</strong> (Beautiful is better than ugly.)</li>
<li><strong>简单优于复杂</strong> (Simple is better than complex.)</li>
<li><strong>可读性很重要</strong> (Readability counts.)</li>
</ul>
</li>
</ul>
<h4 id="本章总结"><a href="#本章总结" class="headerlink" title="本章总结"></a><strong>本章总结</strong></h4><p>第二章是Python编程的基石。通过对变量、字符串和数字的详细学习，我掌握了处理基本数据的核心技能。本章不仅教会了我具体的语法和函数，如f-字符串和.strip()方法，更重要的是，它从一开始就强调了<strong>代码的可读性、规范性和调试思维</strong>。理解变量是“标签”、注意浮点数的精度问题、遵循命名规范、善用错误提示，这些细节将对我未来的编程之路产生深远的影响。“Python之禅”更是点睛之笔，让我认识到编程不仅仅是实现功能，更是一种追求简洁与优雅的艺术。</p>
<h3 id="第三章：列表简介"><a href="#第三章：列表简介" class="headerlink" title="第三章：列表简介"></a><strong>第三章：列表简介</strong></h3><h4 id="核心概要-2"><a href="#核心概要-2" class="headerlink" title="核心概要"></a><strong>核心概要</strong></h4><p>本章我们开始学习如何组织和管理<strong>一组数据</strong>。在此之前，我们使用的变量一次只能存储一个值。本章引入了Python中一个极其强大且常用的数据结构——<strong>列表（List）</strong>。列表可以让你在一个变量中存储任意数量的信息项，无论是几个还是数百万个。本章的核心目标是让你掌握列表的<strong>创建、访问、修改、添加和删除</strong>元素这五大基本操作，并学习如何对列表进行<strong>组织和管理</strong>，同时注意避免一种非常常见的错误——索引错误。</p>
<hr>
<h4 id="3-1-列表是什么（What-is-a-List-）"><a href="#3-1-列表是什么（What-is-a-List-）" class="headerlink" title="3.1 列表是什么（What is a List?）"></a><strong>3.1 列表是什么（What is a List?）</strong></h4><p><strong>1. 列表的定义</strong></p>
<ul>
<li><strong>概念</strong>：列表是由一系列按特定顺序排列的元素组成的集合。你可以把任何东西放入列表中，元素之间可以没有任何关系。</li>
<li><strong>语法</strong>：用方括号 <code>[]</code> 来表示列表，并用逗号 <code>,</code> 来分隔其中的元素。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bicycles = [<span class="string">&#x27;trek&#x27;</span>, <span class="string">&#x27;cannondale&#x27;</span>, <span class="string">&#x27;redline&#x27;</span>, <span class="string">&#x27;specialized&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(bicycles)</span><br><span class="line"><span class="comment"># 输出: [&#x27;trek&#x27;, &#x27;cannondale&#x27;, &#x27;redline&#x27;, &#x27;specialized&#x27;]</span></span><br></pre></td></tr></table></figure>

<p><strong>2. 访问列表元素</strong></p>
<ul>
<li><strong>核心概念</strong>：列表中的元素是有序的，每个元素都有一个对应的位置或<strong>索引（Index）</strong>。我们可以通过索引来精确地获取列表中的任何一个元素。</li>
<li><strong>语法</strong>：在列表名后面跟一个方括号，里面写上元素的索引。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(bicycles[<span class="number">0</span>]) <span class="comment"># 输出: trek</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>重要细节</strong>：<ul>
<li><strong>索引从0开始</strong>：这是编程中一个非常普遍且重要的规则。列表的第一个元素的索引是 <code>0</code>，第二个是 <code>1</code>，以此类推。初学者很容易在这里犯“差一错误”（off-by-one error）。</li>
<li><strong>使用列表中的值</strong>：访问到的元素可以像普通变量一样使用。例如，可以对它调用字符串方法：</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(bicycles[<span class="number">0</span>].title()) <span class="comment"># 输出: Trek</span></span><br></pre></td></tr></table></figure>

<pre><code>- **f-字符串中的应用**：可以方便地在f-字符串中使用列表元素来创建动态消息。
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">message = <span class="string">f&quot;My first bicycle was a <span class="subst">&#123;bicycles[<span class="number">0</span>].title()&#125;</span>.&quot;</span></span><br><span class="line"><span class="built_in">print</span>(message) <span class="comment"># 输出: My first bicycle was a Trek.</span></span><br></pre></td></tr></table></figure>

<p><strong>3. 使用负数索引</strong></p>
<ul>
<li><strong>功能</strong>：Python提供了一种特殊的语法来访问列表末尾的元素。</li>
<li><strong>语法</strong>：<ul>
<li>索引 <code>-1</code> 表示访问<strong>最后一个</strong>元素。</li>
<li>索引 <code>-2</code> 表示访问<strong>倒数第二个</strong>元素，以此类推。</li>
</ul>
</li>
<li><strong>优势</strong>：当你不知道列表具体有多长时，这个功能非常有用。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">motorcycles = [<span class="string">&#x27;honda&#x27;</span>, <span class="string">&#x27;yamaha&#x27;</span>, <span class="string">&#x27;suzuki&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(motorcycles[-<span class="number">1</span>]) <span class="comment"># 输出: suzuki</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="3-2-修改、添加和删除元素"><a href="#3-2-修改、添加和删除元素" class="headerlink" title="3.2 修改、添加和删除元素"></a><strong>3.2 修改、添加和删除元素</strong></h4><p>列表通常是<strong>动态的</strong>，意味着我们可以在程序运行过程中随时改变其内容。</p>
<p><strong>1. 修改列表元素</strong></p>
<ul>
<li><strong>语法</strong>：指定列表名和要修改元素的索引，然后赋予新值。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">motorcycles = [<span class="string">&#x27;honda&#x27;</span>, <span class="string">&#x27;yamaha&#x27;</span>, <span class="string">&#x27;suzuki&#x27;</span>]</span><br><span class="line">motorcycles[<span class="number">0</span>] = <span class="string">&#x27;ducati&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(motorcycles) <span class="comment"># 输出: [&#x27;ducati&#x27;, &#x27;yamaha&#x27;, &#x27;suzuki&#x27;]</span></span><br></pre></td></tr></table></figure>

<p><strong>2. 在列表中添加元素</strong></p>
<ul>
<li><strong>在列表末尾添加元素 (</strong><code>.append()</code><strong>)</strong>：这是最简单、最常用的添加方式。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">motorcycles.append(<span class="string">&#x27;ducati&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(motorcycles) <span class="comment"># 输出: [&#x27;honda&#x27;, &#x27;yamaha&#x27;, &#x27;suzuki&#x27;, &#x27;ducati&#x27;]</span></span><br></pre></td></tr></table></figure>

<pre><code>- **应用场景**：可以从一个空列表开始，通过循环和 `.append()` 动态地构建整个列表。
</code></pre>
<ul>
<li><strong>在列表中间插入元素 (</strong><code>.insert()</code><strong>)</strong>：如果你想在列表的任意位置添加新元素。<ul>
<li><strong>语法</strong>：<code>.insert(index, element)</code>，需要提供新元素的索引和值。</li>
<li><strong>注意</strong>：插入位置之后的所有元素都会自动向右移动一个位置。</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">motorcycles.insert(<span class="number">0</span>, <span class="string">&#x27;ducati&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(motorcycles) <span class="comment"># 输出: [&#x27;ducati&#x27;, &#x27;honda&#x27;, &#x27;yamaha&#x27;, &#x27;suzuki&#x27;]</span></span><br></pre></td></tr></table></figure>

<p><strong>3. 从列表中删除元素</strong></p>
<ul>
<li><strong>使用 <strong><code>del</code></strong> 语句删除（知道索引）</strong>：如果你知道要删除元素的索引，可以使用 <code>del</code>。<ul>
<li><strong>注意</strong>：使用 <code>del</code> 删除后，这个元素就<strong>彻底消失了</strong>，你无法再访问它。</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">del</span> motorcycles[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(motorcycles) <span class="comment"># 输出: [&#x27;yamaha&#x27;, &#x27;suzuki&#x27;]</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>使用 <strong><code>.pop()</code></strong> 方法删除（“弹出”元素）</strong>：<code>.pop()</code> 可以删除列表中的一个元素，并且让你能够<strong>继续使用</strong>这个被删除的元素的值。<ul>
<li><strong>默认行为</strong>：如果不提供索引，<code>.pop()</code> 会删除并返回列表<strong>末尾</strong>的元素（像从栈顶弹出一个元素）。</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">popped_motorcycle = motorcycles.pop()</span><br><span class="line"><span class="built_in">print</span>(motorcycles)       <span class="comment"># 输出: [&#x27;honda&#x27;, &#x27;yamaha&#x27;]</span></span><br><span class="line"><span class="built_in">print</span>(popped_motorcycle) <span class="comment"># 输出: suzuki</span></span><br></pre></td></tr></table></figure>

<pre><code>- **指定索引**：你也可以提供索引来删除列表中任意位置的元素：`motorcycles.pop(0)`。
- **如何选择**：当你想删除一个元素并且不再使用它时，用 `del`；如果你想在删除后仍然需要使用那个元素的值，就用 `.pop()`。
</code></pre>
<ul>
<li><strong>根据值删除元素 (</strong><code>.remove()</code><strong>)</strong>：如果你不知道元素的索引，只知道它的值。<ul>
<li><strong>语法</strong>：<code>.remove(value)</code></li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">motorcycles.remove(<span class="string">&#x27;ducati&#x27;</span>)</span><br></pre></td></tr></table></figure>

<pre><code>- **重要细节**：`.remove()` 方法**只删除第一个**匹配到的值。如果列表中有多个相同的值，你需要使用循环来确保它们都被删除（这将在后续章节介绍）。
</code></pre>
<hr>
<h4 id="3-3-组织列表"><a href="#3-3-组织列表" class="headerlink" title="3.3 组织列表"></a><strong>3.3 组织列表</strong></h4><p><strong>1. 永久性排序 (</strong><code>.sort()</code><strong>)</strong></p>
<ul>
<li><strong>功能</strong>：直接修改列表元素的排列顺序。</li>
<li><strong>默认行为</strong>：按字母顺序排序。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cars = [<span class="string">&#x27;bmw&#x27;</span>, <span class="string">&#x27;audi&#x27;</span>, <span class="string">&#x27;toyota&#x27;</span>, <span class="string">&#x27;subaru&#x27;</span>]</span><br><span class="line">cars.sort()</span><br><span class="line"><span class="built_in">print</span>(cars) <span class="comment"># 输出: [&#x27;audi&#x27;, &#x27;bmw&#x27;, &#x27;subaru&#x27;, &#x27;toyota&#x27;]</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>反向排序</strong>：传递参数 <code>reverse=True</code>。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cars.sort(reverse=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>注意</strong>：<code>.sort()</code> 的修改是<strong>永久性的</strong>，列表的原始顺序会丢失。</li>
</ul>
<p><strong>2. 临时性排序 (</strong><code>sorted()</code><strong>)</strong></p>
<ul>
<li><strong>功能</strong>：返回一个排序后的列表<strong>副本</strong>，而不改变原始列表的顺序。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cars = [<span class="string">&#x27;bmw&#x27;</span>, <span class="string">&#x27;audi&#x27;</span>, <span class="string">&#x27;toyota&#x27;</span>, <span class="string">&#x27;subaru&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sorted</span>(cars)) <span class="comment"># 输出: [&#x27;audi&#x27;, &#x27;bmw&#x27;, &#x27;subaru&#x27;, &#x27;toyota&#x27;]</span></span><br><span class="line"><span class="built_in">print</span>(cars)         <span class="comment"># 输出: [&#x27;bmw&#x27;, &#x27;audi&#x27;, &#x27;toyota&#x27;, &#x27;subaru&#x27;]</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>反向排序</strong>：同样可以传递 <code>reverse=True</code> 参数。</li>
</ul>
<p><strong>3. 反转列表顺序 (</strong><code>.reverse()</code><strong>)</strong></p>
<ul>
<li><strong>功能</strong>：反转列表元素的排列顺序，不是按字母顺序，而是简单地将列表倒置。</li>
<li><strong>注意</strong>：<code>.reverse()</code> 的修改也是<strong>永久性的</strong>，但可以再次调用它来恢复原始顺序。</li>
</ul>
<p><strong>4. 确定列表长度 (</strong><code>len()</code><strong>)</strong></p>
<ul>
<li><strong>功能</strong>：获取列表中元素的数量。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">len</span>(cars) <span class="comment"># 返回 4</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="3-4-使用列表时避免索引错误-IndexError"><a href="#3-4-使用列表时避免索引错误-IndexError" class="headerlink" title="3.4 使用列表时避免索引错误 (IndexError)"></a><strong>3.4 使用列表时避免索引错误 (</strong><code>IndexError</code><strong>)</strong></h4><ul>
<li><strong>错误原因</strong>：当你试图访问一个不存在的索引时，Python会引发 <code>IndexError</code>。最常见的原因是忘记了索引从0开始，或者错误地估计了列表的长度。</li>
<li><strong>示例</strong>：对于 <code>motorcycles = [&#39;honda&#39;, &#39;yamaha&#39;, &#39;suzuki&#39;]</code>，<code>motorcycles[3]</code> 就会引发 <code>IndexError</code>，因为有效的索引是0, 1, 2。</li>
<li><strong>解决方法</strong>：<ul>
<li>时刻记住索引是从0开始的。</li>
<li>使用 <code>-1</code> 来访问最后一个元素，这总能正确工作，除非列表为空。</li>
<li>如果列表为空，任何索引访问都会出错。</li>
</ul>
</li>
<li><strong>调试技巧</strong>：如果遇到 <code>IndexError</code> 却找不到原因，可以尝试打印列表本身或其长度 (<code>len()</code>)，这有助于你了解列表的当前状态。</li>
</ul>
<h4 id="本章总结-1"><a href="#本章总结-1" class="headerlink" title="本章总结"></a><strong>本章总结</strong></h4><p>第三章为我们打开了数据集合的大门。通过学习列表，我掌握了存储和操作一组数据的基本方法。关键操作包括：使用从0开始的索引访问元素、修改、添加 (.append(), .insert()) 和删除 (del, .pop(), .remove()) 元素。我还学会了如何通过 .sort()（永久）和 sorted()（临时）来组织列表，以及使用 .reverse() 和 len()。最重要的是，我了解了 IndexError 这种常见错误的原因和避免方法。这些都是使用Python处理数据的核心技能，为后续学习更复杂的循环和数据结构奠定了坚实的基础。</p>
<h3 id="第四章：操作列表"><a href="#第四章：操作列表" class="headerlink" title="第四章：操作列表"></a><strong>第四章：操作列表</strong></h3><h4 id="核心概要-3"><a href="#核心概要-3" class="headerlink" title="核心概要"></a><strong>核心概要</strong></h4><p>在第三章，我们学会了如何处理列表中的单个元素。但如果列表包含成百上千个元素，逐个处理显然是不现实的。本章的核心就是解决这个问题，引入了<strong>循环（Loop）<strong><strong>的概念，特别是</strong><code>for</code><strong>循环。通过循环，我们可以</strong></strong>遍历（Traverse）<strong><strong>整个列表，对每个元素执行相同的操作。本章还将深入讲解</strong></strong>代码缩进<strong>的重要性，并介绍如何创建</strong>数值列表**、使用列表的**一部分（切片）</strong>，以及学习一种不可变的列表——<strong>元组（Tuple）</strong>。最后，本章提供了关于代码格式的指导，帮助我们写出更专业、更易读的代码。</p>
<hr>
<h4 id="4-1-遍历整个列表"><a href="#4-1-遍历整个列表" class="headerlink" title="4.1 遍历整个列表"></a><strong>4.1 遍历整个列表</strong></h4><p><strong>1. <strong><code>for</code></strong> 循环</strong></p>
<ul>
<li><strong>目的</strong>：当你需要对列表中的每个元素都执行相同的操作时，使用<code>for</code>循环可以自动化这个过程。</li>
<li><strong>语法</strong>：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">magicians = [<span class="string">&#x27;alice&#x27;</span>, <span class="string">&#x27;david&#x27;</span>, <span class="string">&#x27;carolina&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> magician <span class="keyword">in</span> magicians:</span><br><span class="line">    <span class="built_in">print</span>(magician)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>语法解析</strong>：<ol>
<li><code>for magician in magicians:</code>：这行代码告诉Python从列表<code>magicians</code>中取出一个元素，并将其存储在临时变量<code>magician</code>中。</li>
<li><code>:</code>：冒号告诉Python，接下来的一行是循环体的开始。</li>
<li><strong>循环体</strong>：冒号后面的所有<strong>缩进</strong>的代码行都是循环的一部分。</li>
</ol>
</li>
<li><strong>执行过程</strong>：Python会重复执行循环体，每次循环都将列表中的下一个元素赋给临时变量<code>magician</code>，直到列表中的所有元素都被处理完毕。</li>
<li><strong>命名规范</strong>：临时变量的命名最好使用有意义的单数形式，而列表名使用复数形式，如 <code>for cat in cats:</code> 或 <code>for dog in dogs:</code>。这让代码的意图一目了然。</li>
</ul>
<p><strong>2. 在</strong><code>for</code><strong>循环中执行更多操作</strong></p>
<ul>
<li><strong>知识点</strong>：循环体内可以包含任意多行代码，它们都会对列表中的每个元素执行一次。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> magician <span class="keyword">in</span> magicians:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;magician.title()&#125;</span>, that was a great trick!&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;I can&#x27;t wait to see your next trick, <span class="subst">&#123;magician.title()&#125;</span>.\n&quot;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>注意</strong>：所有希望在循环内重复执行的代码都<strong>必须缩进</strong>。</li>
</ul>
<p><strong>3. 在</strong><code>for</code><strong>循环结束后执行操作</strong></p>
<ul>
<li><strong>知识点</strong>：没有缩进的代码行位于循环之外，它们只会在整个循环结束后执行一次。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Thank you, everyone. That was a great magic show!&quot;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>应用</strong>：这常用于在处理完所有列表项后进行总结或执行后续步骤。</li>
</ul>
<hr>
<h4 id="4-2-避免缩进错误"><a href="#4-2-避免缩进错误" class="headerlink" title="4.2 避免缩进错误"></a><strong>4.2 避免缩进错误</strong></h4><p><strong>1. 缩进的重要性</strong></p>
<ul>
<li><strong>核心概念</strong>：Python<strong>通过缩进来判断代码行之间的关系</strong>。缩进决定了哪些代码属于哪个代码块（如<code>for</code>循环体）。这是Python语法的一个强制性要求，也是其代码清晰易读的关键原因之一。</li>
<li><strong>规范</strong>：PEP 8 编码规范建议使用<strong>4个空格</strong>作为一级缩进。</li>
</ul>
<p><strong>2. 常见的缩进错误</strong></p>
<ul>
<li><strong>忘记缩进 (</strong><code>IndentationError</code><strong>)</strong>：本应缩进的代码（如<code>for</code>循环后的第一行）没有缩进，Python会报告<code>IndentationError: expected an indented block</code>。</li>
<li><strong>不必要的缩进 (</strong><code>IndentationError</code><strong>)</strong>：不属于任何代码块的代码行被错误地缩进，Python会报告<code>IndentationError: unexpected indent</code>。</li>
<li><strong>忘记缩进额外的代码行（逻辑错误）</strong>：这是最隐蔽的错误。代码在语法上没有问题，可以运行，但结果不符合预期。比如，循环体中本应有两行缩进的代码，但你只缩进了第一行，导致第二行代码只在循环结束后执行了一次。</li>
<li><strong>循环后不必要的缩进（逻辑错误）</strong>：本应在循环结束后执行的代码被错误地缩进，导致它在每次循环中都被执行。</li>
<li><strong>遗漏冒号 (</strong><code>SyntaxError</code><strong>)</strong>：<code>for</code>语句（以及后续将学到的<code>if</code>, <code>def</code>等）末尾的冒号非常重要，如果遗漏，会导致<code>SyntaxError: expected &#39;:&#39;</code>。</li>
</ul>
<hr>
<h4 id="4-3-创建数值列表"><a href="#4-3-创建数值列表" class="headerlink" title="4.3 创建数值列表"></a><strong>4.3 创建数值列表</strong></h4><p><strong>1. 使用 <strong><code>range()</code></strong> 函数</strong></p>
<ul>
<li><strong>功能</strong>：轻松生成一系列连续的整数。</li>
<li><strong>语法</strong>：<code>range(start, stop)</code>。它会生成从<code>start</code>开始，到<code>stop - 1</code>结束的数。这是一个“<strong>包前不包后</strong>”的规则。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">5</span>):</span><br><span class="line">    <span class="built_in">print</span>(value)  <span class="comment"># 输出 1, 2, 3, 4</span></span><br></pre></td></tr></table></figure>

<p><strong>2. 使用 <strong><code>range()</code></strong> 创建数字列表</strong></p>
<ul>
<li><strong>功能</strong>：可以将<code>range()</code>的结果直接转换为列表。</li>
<li><strong>语法</strong>：使用<code>list()</code>函数。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">numbers = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>, <span class="number">6</span>))</span><br><span class="line"><span class="built_in">print</span>(numbers)  <span class="comment"># 输出: [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>指定步长</strong>：<code>range()</code>可以接受第三个参数，表示步长。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">even_numbers = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">2</span>, <span class="number">11</span>, <span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(even_numbers) <span class="comment"># 输出: [2, 4, 6, 8, 10]</span></span><br></pre></td></tr></table></figure>

<p><strong>3. 对数字列表执行简单统计</strong></p>
<ul>
<li><strong>内置函数</strong>：Python提供了一些简单的函数来处理数字列表。<ul>
<li><code>min()</code>：找出最小值。</li>
<li><code>max()</code>：找出最大值。</li>
<li><code>sum()</code>：计算总和。</li>
</ul>
</li>
</ul>
<p><strong>4. 列表推导式 (List Comprehension)</strong></p>
<ul>
<li><strong>功能</strong>：一种将<code>for</code>循环和创建新元素的代码合并成一行的简洁语法。</li>
<li><strong>语法</strong>：<code>[expression for item in iterable]</code></li>
<li><strong>示例</strong>：创建一个包含前10个整数平方的列表。<ul>
<li><strong>常规方法</strong>：</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">squares = []</span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>):</span><br><span class="line">    square = value ** <span class="number">2</span></span><br><span class="line">    squares.append(square)</span><br></pre></td></tr></table></figure>

<pre><code>- **列表推导式**：
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">squares = [value**<span class="number">2</span> <span class="keyword">for</span> value <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>)]</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>心得</strong>：列表推导式非常强大和高效，是Python的一大特色。虽然初学时可能觉得有些复杂，但一旦掌握，就能写出非常简洁的代码。</li>
</ul>
<hr>
<h4 id="4-4-使用列表的一部分（切片-Slice）"><a href="#4-4-使用列表的一部分（切片-Slice）" class="headerlink" title="4.4 使用列表的一部分（切片 Slice）"></a><strong>4.4 使用列表的一部分（切片 Slice）</strong></h4><p><strong>1. 创建切片</strong></p>
<ul>
<li><strong>功能</strong>：处理列表中的一部分元素。</li>
<li><strong>语法</strong>：<code>list_name[start:stop]</code>。同样是“<strong>包前不包后</strong>”。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">players = [<span class="string">&#x27;charles&#x27;</span>, <span class="string">&#x27;martina&#x27;</span>, <span class="string">&#x27;michael&#x27;</span>, <span class="string">&#x27;florence&#x27;</span>, <span class="string">&#x27;eli&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(players[<span class="number">0</span>:<span class="number">3</span>]) <span class="comment"># 输出: [&#x27;charles&#x27;, &#x27;martina&#x27;, &#x27;michael&#x27;]</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>语法简写</strong>：<ul>
<li><code>players[:4]</code>：如果省略起始索引，切片从列表开头开始。</li>
<li><code>players[2:]</code>：如果省略终止索引，切片到列表末尾结束。</li>
<li><code>players[-3:]</code>：可以使用负数索引，表示从倒数第三个元素切到末尾。</li>
</ul>
</li>
</ul>
<p><strong>2. 遍历切片</strong></p>
<ul>
<li><strong>功能</strong>：可以在<code>for</code>循环中使用切片来遍历列表的一部分。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> player <span class="keyword">in</span> players[:<span class="number">3</span>]:</span><br><span class="line">    <span class="built_in">print</span>(player.title())</span><br></pre></td></tr></table></figure>

<p><strong>3. 复制列表</strong></p>
<ul>
<li><strong>错误的方式</strong>：直接赋值 <code>friend_foods = my_foods</code> 并没有创建新列表，而是让两个变量指向了<strong>同一个列表</strong>。修改其中一个会影响另一个。</li>
<li><strong>正确的方式</strong>：使用不带任何索引的切片 <code>[:]</code> 来创建整个列表的<strong>副本</strong>。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">my_foods = [<span class="string">&#x27;pizza&#x27;</span>, <span class="string">&#x27;falafel&#x27;</span>, <span class="string">&#x27;carrot cake&#x27;</span>]</span><br><span class="line">friend_foods = my_foods[:] <span class="comment"># 创建副本</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="4-5-元组（Tuple）"><a href="#4-5-元组（Tuple）" class="headerlink" title="4.5 元组（Tuple）"></a><strong>4.5 元组（Tuple）</strong></h4><p><strong>1. 元组的定义</strong></p>
<ul>
<li><strong>核心概念</strong>：元组是一种<strong>不可变</strong>的列表。一旦创建，就不能修改其中的元素。</li>
<li><strong>语法</strong>：使用圆括号 <code>()</code> 来定义。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dimensions = (<span class="number">200</span>, <span class="number">50</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>注意</strong>：尝试修改元组中的元素会导致<code>TypeError</code>。</li>
</ul>
<p><strong>2. 遍历元组</strong></p>
<ul>
<li><strong>方法</strong>：和列表一样，可以使用<code>for</code>循环来遍历元组中的所有值。</li>
</ul>
<p><strong>3. 修改元组变量</strong></p>
<ul>
<li><strong>知识点</strong>：虽然不能修改元组的<strong>元素</strong>，但可以给存储元组的<strong>变量</strong>重新赋值一个新的元组。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dimensions = (<span class="number">200</span>, <span class="number">50</span>)</span><br><span class="line">dimensions = (<span class="number">400</span>, <span class="number">100</span>) <span class="comment"># 这是合法的</span></span><br></pre></td></tr></table></figure>

<p><strong>4. 适用场景</strong></p>
<ul>
<li>当你需要存储一组不应被修改的值时，使用元组比列表更安全。</li>
</ul>
<hr>
<h4 id="4-6-设置代码格式"><a href="#4-6-设置代码格式" class="headerlink" title="4.6 设置代码格式"></a><strong>4.6 设置代码格式</strong></h4><ul>
<li><strong>PEP 8</strong>：Python官方的代码风格指南。</li>
<li><strong>核心建议</strong>：<ul>
<li><strong>缩进</strong>：使用4个空格。</li>
<li><strong>行长</strong>：建议每行代码不超过80个字符，注释不超过72个字符。</li>
<li><strong>空行</strong>：用空行来组织代码，分隔不同的逻辑部分，但不要滥用。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="本章总结-2"><a href="#本章总结-2" class="headerlink" title="本章总结"></a><strong>本章总结</strong></h4><p>第四章是质的飞跃。<code>for</code>循环让我具备了处理大规模数据的能力，不再局限于手动操作单个元素。对<strong>缩进</strong>的深入理解让我明白了Python代码结构的本质。<strong>列表推导式</strong>展示了Python的简洁之美。<strong>切片</strong>操作提供了处理列表子集的灵活性，尤其是<code>[:]</code>在复制列表时的重要作用。最后，<strong>元组</strong>的引入让我知道了在需要保护数据不被修改时，还有列表之外的选择。本章不仅是关于“如何做”，更是关于“如何做得更好、更规范”，为编写更复杂、更专业的程序打下了坚实的基础。</p>
<h3 id="第五章：if语句"><a href="#第五章：if语句" class="headerlink" title="第五章：if语句"></a><strong>第五章：if语句</strong></h3><h4 id="核心概要-4"><a href="#核心概要-4" class="headerlink" title="核心概要"></a><strong>核心概要</strong></h4><p>本章我们开始学习如何让程序具备<strong>决策能力</strong>。在此之前，我们编写的程序都是按顺序执行每一行代码。本章引入了<code>if</code>语句，它允许程序<strong>检查当前的某个条件是否满足，并根据检查结果执行相应的操作</strong>。这使得程序能够响应不同的情况，变得更加智能和灵活。本章的核心内容包括<strong>条件测试</strong>的各种形式、简单的**<code>if</code>语句**、<code>if-else</code><strong>结构</strong>、<code>if-elif-else</code><strong>链</strong>，以及如何将这些逻辑判断应用到列表中。</p>
<hr>
<h4 id="5-1-5-2-条件测试（Conditional-Tests）"><a href="#5-1-5-2-条件测试（Conditional-Tests）" class="headerlink" title="5.1 &amp; 5.2 条件测试（Conditional Tests）"></a><strong>5.1 &amp; 5.2 条件测试（Conditional Tests）</strong></h4><p>条件测试是每一条<code>if</code>语句的核心，其结果要么是<code>True</code>（真），要么是<code>False</code>（假）。</p>
<p><strong>1. 检查是否相等 (</strong><code>==</code><strong>)</strong></p>
<ul>
<li><strong>核心概念</strong>：这是最基本的条件测试，用于判断两个值是否相等。</li>
<li><strong>语法</strong>：使用**两个等号 **<code>==</code>。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">car = <span class="string">&#x27;bmw&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(car == <span class="string">&#x27;bmw&#x27;</span>) <span class="comment"># 输出: True</span></span><br><span class="line"></span><br><span class="line">car = <span class="string">&#x27;audi&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(car == <span class="string">&#x27;bmw&#x27;</span>) <span class="comment"># 输出: False</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>重要区别</strong>：<ul>
<li><strong>一个等号 (</strong><code>=</code><strong>)</strong> 是<strong>赋值</strong>，意为“将右边的值赋给左边的变量”。</li>
<li><strong>两个等号 (</strong><code>==</code><strong>)</strong> 是<strong>比较</strong>，意为“左边的值是否等于右边的值？”</li>
</ul>
</li>
</ul>
<p><strong>2. 检查是否相等时忽略大小写</strong></p>
<ul>
<li><strong>问题</strong>：直接使用 <code>==</code> 进行比较时，是<strong>区分大小写</strong>的。<code>&#39;Audi&#39;</code> 和 <code>&#39;audi&#39;</code> 会被认为是不同的。</li>
<li><strong>解决方法</strong>：在比较前，先将变量的值统一转换为小写（或大写），通常使用 <code>.lower()</code> 方法。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">car = <span class="string">&#x27;Audi&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(car.lower() == <span class="string">&#x27;audi&#x27;</span>) <span class="comment"># 输出: True</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>注意</strong>：<code>.lower()</code> 方法<strong>不改变</strong>原始变量 <code>car</code> 的值，只是返回一个新的小写版本的字符串用于比较。</li>
</ul>
<p><strong>3. 检查是否不相等 (</strong><code>!=</code><strong>)</strong></p>
<ul>
<li><strong>语法</strong>：使用感叹号和等号 <code>!=</code>。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">requested_topping = <span class="string">&#x27;mushrooms&#x27;</span></span><br><span class="line"><span class="keyword">if</span> requested_topping != <span class="string">&#x27;anchovies&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hold the anchovies!&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>4. 数值比较</strong></p>
<ul>
<li><strong>操作符</strong>：除了相等和不相等，还支持标准的数学比较。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">age = <span class="number">18</span></span><br><span class="line"><span class="built_in">print</span>(age == <span class="number">18</span>) <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(age &lt; <span class="number">21</span>)  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(age &gt;= <span class="number">18</span>) <span class="comment"># True</span></span><br></pre></td></tr></table></figure>

<pre><code>- `&gt;` (大于)
- `&lt;` (小于)
- `&gt;=` (大于等于)
- `&lt;=` (小于等于)
</code></pre>
<p><strong>5. 检查多个条件</strong></p>
<ul>
<li>**使用 <strong><code>and</code>：当需要</strong>所有条件都为<code>True</code>**时，整个表达式才为<code>True</code>。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">age_0 = <span class="number">22</span></span><br><span class="line">age_1 = <span class="number">18</span></span><br><span class="line"><span class="built_in">print</span>(age_0 &gt;= <span class="number">21</span> <span class="keyword">and</span> age_1 &gt;= <span class="number">21</span>) <span class="comment"># False, 因为 age_1 不满足条件</span></span><br></pre></td></tr></table></figure>

<ul>
<li>**使用 <strong><code>or</code>：当</strong>至少有一个条件为<code>True</code>**时，整个表达式就为<code>True</code>。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">age_0 = <span class="number">22</span></span><br><span class="line">age_1 = <span class="number">18</span></span><br><span class="line"><span class="built_in">print</span>(age_0 &gt;= <span class="number">21</span> <span class="keyword">or</span> age_1 &gt;= <span class="number">21</span>) <span class="comment"># True, 因为 age_0 满足条件</span></span><br></pre></td></tr></table></figure>

<p><strong>6. 检查特定值是否在列表中 (</strong><code>in</code><strong>)</strong></p>
<ul>
<li><strong>功能</strong>：判断一个值是否存在于一个列表中。</li>
<li><strong>语法</strong>：使用关键字 <code>in</code>。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">requested_toppings = [<span class="string">&#x27;mushrooms&#x27;</span>, <span class="string">&#x27;onions&#x27;</span>, <span class="string">&#x27;pineapple&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;mushrooms&#x27;</span> <span class="keyword">in</span> requested_toppings) <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;pepperoni&#x27;</span> <span class="keyword">in</span> requested_toppings) <span class="comment"># False</span></span><br></pre></td></tr></table></figure>

<p><strong>7. 检查特定值是否不在列表中 (</strong><code>not in</code><strong>)</strong></p>
<ul>
<li><strong>功能</strong>：与<code>in</code>相反，判断一个值是否<strong>不</strong>存在于一个列表中。</li>
<li><strong>语法</strong>：使用关键字 <code>not in</code>。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">banned_users = [<span class="string">&#x27;andrew&#x27;</span>, <span class="string">&#x27;carolina&#x27;</span>, <span class="string">&#x27;david&#x27;</span>]</span><br><span class="line">user = <span class="string">&#x27;marie&#x27;</span></span><br><span class="line"><span class="keyword">if</span> user <span class="keyword">not</span> <span class="keyword">in</span> banned_users:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;user.title()&#125;</span>, you can post a response.&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>8. 布尔表达式 (Boolean Expression)</strong></p>
<ul>
<li><strong>概念</strong>：就是条件测试的另一个名字。布尔值只有两个：<code>True</code> 和 <code>False</code>。可以直接将布尔值赋给变量，用于跟踪程序的状态。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">game_active = <span class="literal">True</span></span><br><span class="line">can_edit = <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="5-3-if-语句"><a href="#5-3-if-语句" class="headerlink" title="5.3 if 语句"></a><strong>5.3 <strong><code>if</code></strong> 语句</strong></h4><p><strong>1. 简单的</strong><code>if</code><strong>语句</strong></p>
<ul>
<li><strong>结构</strong>：由一个条件测试和在测试通过时要执行的一个或多个操作组成。</li>
<li><strong>语法</strong>：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> conditional_test:</span><br><span class="line">    do_something()</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>示例</strong>：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">age = <span class="number">19</span></span><br><span class="line"><span class="keyword">if</span> age &gt;= <span class="number">18</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;You are old enough to vote!&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Have you registered to vote yet?&quot;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>注意</strong>：和<code>for</code>循环一样，<code>if</code>语句后面的所有<strong>缩进</strong>代码块都是在条件为<code>True</code>时才执行。</li>
</ul>
<p><strong>2. <strong><code>if-else</code></strong> 语句</strong></p>
<ul>
<li><strong>功能</strong>：当条件测试通过时执行一个代码块，未通过时执行另一个代码块。</li>
<li><strong>语法</strong>：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> conditional_test:</span><br><span class="line">    do_something()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    do_something_else()</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>适用场景</strong>：非常适合处理只有两种可能性的情况。</li>
</ul>
<p><strong>3. <strong><code>if-elif-else</code></strong> 结构</strong></p>
<ul>
<li><strong>功能</strong>：用于检查两个以上的情况。Python会按顺序检查每个条件，一旦找到一个为<code>True</code>的条件，就会执行其后的代码块，并<strong>跳过</strong>余下的所有测试。</li>
<li><strong>语法</strong>：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> age &lt; <span class="number">4</span>:</span><br><span class="line">    price = <span class="number">0</span></span><br><span class="line"><span class="keyword">elif</span> age &lt; <span class="number">18</span>:</span><br><span class="line">    price = <span class="number">25</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    price = <span class="number">40</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>重要细节</strong>：<ul>
<li><code>elif</code> 是 <code>else if</code> 的缩写。</li>
<li>可以根据需要使用任意数量的<code>elif</code>代码块。</li>
<li><code>else</code>代码块是可选的。如果省略它，那么在所有<code>if</code>和<code>elif</code>条件都不满足时，程序将不执行任何操作。</li>
</ul>
</li>
</ul>
<p><strong>4. 测试多个条件</strong></p>
<ul>
<li><strong>问题</strong>：<code>if-elif-else</code>结构只执行一个代码块。如果你需要检查多个条件，并且<strong>每个满足的条件都要触发相应的操作</strong>，该怎么办？</li>
<li><strong>解决方法</strong>：使用一系列<strong>独立的</strong><code>if</code><strong>语句</strong>。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">requested_toppings = [<span class="string">&#x27;mushrooms&#x27;</span>, <span class="string">&#x27;extra cheese&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="string">&#x27;mushrooms&#x27;</span> <span class="keyword">in</span> requested_toppings:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Adding mushrooms.&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="string">&#x27;pepperoni&#x27;</span> <span class="keyword">in</span> requested_toppings:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Adding pepperoni.&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="string">&#x27;extra cheese&#x27;</span> <span class="keyword">in</span> requested_toppings:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Adding extra cheese.&quot;</span>)</span><br><span class="line">```*   **总结**：如果只需要一个分支被执行，就用`<span class="keyword">if</span>-<span class="keyword">elif</span>-<span class="keyword">else</span>`；如果需要所有满足条件的分支都被执行，就用多个独立的`<span class="keyword">if</span>`语句。</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="5-4-使用if语句处理列表"><a href="#5-4-使用if语句处理列表" class="headerlink" title="5.4 使用if语句处理列表"></a><strong>5.4 使用</strong><code>if</code><strong>语句处理列表</strong></h4><p><strong>1. 检查特殊元素</strong></p>
<ul>
<li><strong>功能</strong>：在遍历列表时，可以对特定的元素进行特殊处理。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> topping <span class="keyword">in</span> requested_toppings:</span><br><span class="line">    <span class="keyword">if</span> topping == <span class="string">&#x27;green peppers&#x27;</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Sorry, we are out of green peppers right now.&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Adding <span class="subst">&#123;topping&#125;</span>.&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>2. 确定列表是否为空</strong></p>
<ul>
<li><strong>核心概念</strong>：在<code>if</code>语句中，当列表不为空时，它被评估为<code>True</code>；当列表为空时，它被评估为<code>False</code>。</li>
<li><strong>应用</strong>：在执行<code>for</code>循环之前，先检查列表是否为空，可以避免对空列表执行循环而产生不期望的结果或错误。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">requested_toppings = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> requested_toppings: <span class="comment"># 列表不为空时为True</span></span><br><span class="line">    <span class="keyword">for</span> requested_topping <span class="keyword">in</span> requested_toppings:</span><br><span class="line">        <span class="comment"># ...</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Are you sure you want a plain pizza?&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>3. 使用多个列表</strong></p>
<ul>
<li><strong>场景</strong>：当需要将一个列表（如顾客点的配料）与另一个列表（如餐厅供应的配料）进行核对时。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">available_toppings = [<span class="string">&#x27;mushrooms&#x27;</span>, <span class="string">&#x27;olives&#x27;</span>, <span class="string">&#x27;green peppers&#x27;</span>, ...]</span><br><span class="line">requested_toppings = [<span class="string">&#x27;mushrooms&#x27;</span>, <span class="string">&#x27;french fries&#x27;</span>, <span class="string">&#x27;extra cheese&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> requested_topping <span class="keyword">in</span> requested_toppings:</span><br><span class="line">    <span class="keyword">if</span> requested_topping <span class="keyword">in</span> available_toppings:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Adding <span class="subst">&#123;requested_topping&#125;</span>.&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Sorry, we don&#x27;t have <span class="subst">&#123;requested_topping&#125;</span>.&quot;</span>)</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="5-5-设置if语句的格式"><a href="#5-5-设置if语句的格式" class="headerlink" title="5.5 设置if语句的格式"></a><strong>5.5 设置</strong><code>if</code><strong>语句的格式</strong></h4><ul>
<li><strong>PEP 8 建议</strong>：在比较运算符（如 <code>==</code>, <code>&gt;=</code>, <code>&lt;=</code>）的两边各添加一个空格，以提高可读性。<ul>
<li><strong>推荐</strong>：<code>if age &lt; 4:</code></li>
<li><strong>不推荐</strong>：<code>if age&lt;4:</code></li>
</ul>
</li>
</ul>
<hr>
<h4 id="本章总结-3"><a href="#本章总结-3" class="headerlink" title="本章总结"></a><strong>本章总结</strong></h4><p>第五章是编程逻辑的基石。通过<code>if</code>语句，我学会了如何让程序根据不同的条件执行不同的代码路径。本章从最基础的<strong>条件测试</strong>（相等、不等、大小比较、<code>and</code>&#x2F;<code>or</code>、<code>in</code>&#x2F;<code>not in</code>）讲起，逐步深入到**<code>if</code><strong>、</strong><code>if-else</code>** 和 <code>if-elif-else</code> 这三种核心的控制流结构。我明白了它们各自的适用场景，特别是何时用<code>if-elif-else</code>链，何时用一系列独立的<code>if</code>语句。将这些逻辑判断与列表相结合，让我能够编写出更加实用和智能的程序，比如处理特殊项、检查空列表、以及在多个列表之间进行数据验证。本章的学习让我真正开始“与程序对话”，告诉它在不同情况下该如何思考和行动。</p>
<h3 id="第六章：字典"><a href="#第六章：字典" class="headerlink" title="第六章：字典"></a><strong>第六章：字典</strong></h3><h4 id="核心概要-5"><a href="#核心概要-5" class="headerlink" title="核心概要"></a><strong>核心概要</strong></h4><p>在前面的章节中，我们学习了列表，它通过<strong>位置索引</strong>（0, 1, 2…）来存储和访问数据。本章引入了一个更为灵活的数据结构——<strong>字典（Dictionary）</strong>。字典存储的是<strong>键-值对（key-value pair）<strong><strong>的集合，它不依赖于位置，而是通过唯一的</strong></strong>键（key）<strong><strong>来访问与之关联的</strong></strong>值（value）<strong>。这使得字典非常适合用来模拟现实世界中各种事物的属性。本章将详细介绍如何</strong>创建、访问、添加、修改和删除<strong>字典中的键-值对，以及如何</strong>遍历</strong>字典，并探讨了<strong>嵌套</strong>这一强大的组织数据的方式，即将列表和字典互相嵌套。</p>
<hr>
<h4 id="6-1-6-2-使用字典"><a href="#6-1-6-2-使用字典" class="headerlink" title="6.1 &amp; 6.2 使用字典"></a><strong>6.1 &amp; 6.2 使用字典</strong></h4><p><strong>1. 一个简单的字典</strong></p>
<ul>
<li><strong>核心概念</strong>：字典存储的是一系列的<strong>键-值对</strong>。每个键都与一个值相关联。</li>
<li><strong>语法</strong>：使用花括号 <code>&#123;&#125;</code> 来定义字典，键和值之间用冒号 <code>:</code> 分隔，键-值对之间用逗号 <code>,</code> 分隔。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alien_0 = &#123;<span class="string">&#x27;color&#x27;</span>: <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;points&#x27;</span>: <span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>键（Key）</strong>：是唯一的标识符，通常是字符串（但也可以是数字等不可变类型）。</li>
<li><strong>值（Value）</strong>：与键相关联的数据，可以是任何Python对象：数字、字符串、列表，甚至是另一个字典。</li>
</ul>
<p><strong>2. 访问字典中的值</strong></p>
<ul>
<li><strong>语法</strong>：在字典名后面跟一个方括号，里面写上要访问的键。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(alien_0[<span class="string">&#x27;color&#x27;</span>])  <span class="comment"># 输出: green</span></span><br><span class="line"><span class="built_in">print</span>(alien_0[<span class="string">&#x27;points&#x27;</span>]) <span class="comment"># 输出: 5</span></span><br><span class="line">```*   **应用**：可以像使用普通变量一样使用访问到的值。</span><br><span class="line">```python</span><br><span class="line">new_points = alien_0[<span class="string">&#x27;points&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;You just earned <span class="subst">&#123;new_points&#125;</span> points!&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>3. 添加键-值对</strong></p>
<ul>
<li><strong>功能</strong>：字典是动态的，可以随时添加新的键-值对。</li>
<li><strong>语法</strong>：<code>dictionary_name[&#39;new_key&#39;] = new_value</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alien_0[<span class="string">&#x27;x_position&#x27;</span>] = <span class="number">0</span></span><br><span class="line">alien_0[<span class="string">&#x27;y_position&#x27;</span>] = <span class="number">25</span></span><br><span class="line"><span class="built_in">print</span>(alien_0) </span><br><span class="line"><span class="comment"># 输出: &#123;&#x27;color&#x27;: &#x27;green&#x27;, &#x27;points&#x27;: 5, &#x27;x_position&#x27;: 0, &#x27;y_position&#x27;: 25&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>4. 从空字典开始构建</strong></p>
<ul>
<li><strong>语法</strong>：先创建一个空字典 <code>&#123;&#125;</code>，然后逐个添加键-值对。</li>
<li><strong>适用场景</strong>：当需要由用户输入或程序动态生成数据来填充字典时，这种方式非常常用。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alien_0 = &#123;&#125;</span><br><span class="line">alien_0[<span class="string">&#x27;color&#x27;</span>] = <span class="string">&#x27;green&#x27;</span></span><br><span class="line">alien_0[<span class="string">&#x27;points&#x27;</span>] = <span class="number">5</span></span><br></pre></td></tr></table></figure>

<p><strong>5. 修改字典中的值</strong></p>
<ul>
<li><strong>语法</strong>：与添加键-值对的语法相同。如果键已存在，则会更新其对应的值。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alien_0 = &#123;<span class="string">&#x27;color&#x27;</span>: <span class="string">&#x27;green&#x27;</span>&#125;</span><br><span class="line">alien_0[<span class="string">&#x27;color&#x27;</span>] = <span class="string">&#x27;yellow&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(alien_0[<span class="string">&#x27;color&#x27;</span>]) <span class="comment"># 输出: yellow</span></span><br></pre></td></tr></table></figure>

<p><strong>6. 删除键-值对</strong></p>
<ul>
<li><strong>语法</strong>：使用 <code>del</code> 语句，指定字典名和要删除的键。</li>
<li><strong>注意</strong>：<code>del</code> 会将键和与之关联的值<strong>彻底删除</strong>。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alien_0 = &#123;<span class="string">&#x27;color&#x27;</span>: <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;points&#x27;</span>: <span class="number">5</span>&#125;</span><br><span class="line"><span class="keyword">del</span> alien_0[<span class="string">&#x27;points&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(alien_0) <span class="comment"># 输出: &#123;&#x27;color&#x27;: &#x27;green&#x27;&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>7. 使用 <strong><code>get()</code></strong> 方法访问值</strong></p>
<ul>
<li><strong>问题</strong>：如果使用方括号 <code>[]</code> 访问一个不存在的键，程序会引发**<code>KeyError</code>**并崩溃。</li>
<li><code>get()</code>** 的优势**：提供了一种更安全的方式来访问值。</li>
<li><strong>语法</strong>：<code>dictionary.get(&#39;key_name&#39;, default_value)</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alien_0 = &#123;<span class="string">&#x27;color&#x27;</span>: <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;speed&#x27;</span>: <span class="string">&#x27;slow&#x27;</span>&#125;</span><br><span class="line">point_value = alien_0.get(<span class="string">&#x27;points&#x27;</span>, <span class="string">&#x27;No point value assigned.&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(point_value) <span class="comment"># 输出: No point value assigned.</span></span><br></pre></td></tr></table></figure>

<pre><code>- **第一个参数**：要获取的键。
- **第二个参数（可选）**：如果该键不存在时，要返回的默认值。
- 如果省略第二个参数且键不存在，`get()` 会返回 `None` (一个表示“无”的特殊值)，但不会报错。
</code></pre>
<ul>
<li><strong>心得</strong>：当你不确定一个键是否一定存在于字典中时，使用<code>.get()</code>是更好的编程习惯。</li>
</ul>
<hr>
<h4 id="6-3-遍历字典"><a href="#6-3-遍历字典" class="headerlink" title="6.3 遍历字典"></a><strong>6.3 遍历字典</strong></h4><p><strong>1. 遍历所有的键-值对 (</strong><code>.items()</code><strong>)</strong></p>
<ul>
<li><strong>功能</strong>：可以同时获取字典中的键和值。</li>
<li><strong>语法</strong>：使用<code>.items()</code>方法，并在<code>for</code>循环中声明两个变量来分别接收键和值。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">user_0 = &#123;<span class="string">&#x27;username&#x27;</span>: <span class="string">&#x27;efermi&#x27;</span>, <span class="string">&#x27;first&#x27;</span>: <span class="string">&#x27;enrico&#x27;</span>, <span class="string">&#x27;last&#x27;</span>: <span class="string">&#x27;fermi&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> user_0.items():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;\nKey: <span class="subst">&#123;key&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Value: <span class="subst">&#123;value&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>命名规范</strong>：为了提高可读性，最好使用有意义的变量名，如 <code>for username, user_info in users.items():</code>。</li>
</ul>
<p><strong>2. 遍历所有的键 (</strong><code>.keys()</code><strong>)</strong></p>
<ul>
<li><strong>功能</strong>：只获取字典中的键。</li>
<li><strong>语法</strong>：使用<code>.keys()</code>方法。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">favorite_languages = &#123;<span class="string">&#x27;jen&#x27;</span>: <span class="string">&#x27;python&#x27;</span>, <span class="string">&#x27;sarah&#x27;</span>: <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;edward&#x27;</span>: <span class="string">&#x27;rust&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> favorite_languages.keys():</span><br><span class="line">    <span class="built_in">print</span>(name.title())</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>默认行为</strong>：遍历字典时，默认就是遍历它的键。因此，<code>for name in favorite_languages:</code> 和 <code>for name in favorite_languages.keys():</code> 的效果是<strong>完全相同</strong>的。显式使用<code>.keys()</code>可以让代码意图更清晰。</li>
</ul>
<p><strong>3. 按特定顺序遍历字典的键</strong></p>
<ul>
<li><strong>功能</strong>：如果你希望按排序后的顺序处理键。</li>
<li><strong>方法</strong>：在<code>for</code>循环中，用<code>sorted()</code>函数包裹<code>.keys()</code>的结果。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> <span class="built_in">sorted</span>(favorite_languages.keys()):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;name.title()&#125;</span>, thank you for taking the poll.&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>4. 遍历所有的值 (</strong><code>.values()</code><strong>)</strong></p>
<ul>
<li><strong>功能</strong>：只获取字典中的值。</li>
<li><strong>语法</strong>：使用<code>.values()</code>方法。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> language <span class="keyword">in</span> favorite_languages.values():</span><br><span class="line">    <span class="built_in">print</span>(language.title())</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>问题</strong>：<code>.values()</code>可能会返回重复的值。</li>
<li><strong>解决方法</strong>：要获取不重复的值，可以先用<code>set()</code>函数将其转换为<strong>集合</strong>（一种自动去重的数据结构）。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> language <span class="keyword">in</span> <span class="built_in">set</span>(favorite_languages.values()):</span><br><span class="line">    <span class="built_in">print</span>(language.title())</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="6-4-嵌套（Nesting）"><a href="#6-4-嵌套（Nesting）" class="headerlink" title="6.4 嵌套（Nesting）"></a><strong>6.4 嵌套（Nesting）</strong></h4><p>嵌套是一种强大的数据组织方式，允许你在列表和字典中存储更复杂的数据结构。</p>
<p><strong>1. 字典列表（A List of Dictionaries）</strong></p>
<ul>
<li><strong>结构</strong>：一个列表中包含多个字典，每个字典都代表一个独立的对象。</li>
<li><strong>适用场景</strong>：当你有多个结构相似的对象时，比如游戏中的一群外星人或网站上的一系列用户。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">aliens = [] <span class="comment"># 创建一个空列表来存储外星人</span></span><br><span class="line"><span class="keyword">for</span> alien_number <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">30</span>):</span><br><span class="line">    new_alien = &#123;<span class="string">&#x27;color&#x27;</span>: <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;points&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;speed&#x27;</span>: <span class="string">&#x27;slow&#x27;</span>&#125;</span><br><span class="line">    aliens.append(new_alien)</span><br></pre></td></tr></table></figure>

<p><strong>2. 在字典中存储列表（A List in a Dictionary）</strong></p>
<ul>
<li><strong>结构</strong>：字典中的某个值本身就是一个列表。</li>
<li><strong>适用场景</strong>：当一个键需要关联多个值时，比如一个披萨有多种配料，或一个人喜欢多种语言。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pizza = &#123;</span><br><span class="line">    <span class="string">&#x27;crust&#x27;</span>: <span class="string">&#x27;thick&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;toppings&#x27;</span>: [<span class="string">&#x27;mushrooms&#x27;</span>, <span class="string">&#x27;extra cheese&#x27;</span>],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问列表</span></span><br><span class="line"><span class="keyword">for</span> topping <span class="keyword">in</span> pizza[<span class="string">&#x27;toppings&#x27;</span>]:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;\t<span class="subst">&#123;topping&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>3. 在字典中存储字典（A Dictionary in a Dictionary）</strong></p>
<ul>
<li><strong>结构</strong>：字典中的值是另一个字典。</li>
<li><strong>适用场景</strong>：当一个键关联的值本身也包含复杂的结构化信息时，比如一个用户名关联着该用户的详细信息（名、姓、地址等）。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">users = &#123;</span><br><span class="line">    <span class="string">&#x27;aeinstein&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;first&#x27;</span>: <span class="string">&#x27;albert&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;last&#x27;</span>: <span class="string">&#x27;einstein&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;location&#x27;</span>: <span class="string">&#x27;princeton&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&#x27;mcurie&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;first&#x27;</span>: <span class="string">&#x27;marie&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;last&#x27;</span>: <span class="string">&#x27;curie&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;location&#x27;</span>: <span class="string">&#x27;paris&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>访问嵌套字典</strong>：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> username, user_info <span class="keyword">in</span> users.items():</span><br><span class="line">    full_name = <span class="string">f&quot;<span class="subst">&#123;user_info[<span class="string">&#x27;first&#x27;</span>]&#125;</span> <span class="subst">&#123;user_info[<span class="string">&#x27;last&#x27;</span>]&#125;</span>&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;\tFull name: <span class="subst">&#123;full_name.title()&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>注意</strong>：虽然可以嵌套很多层，但过度嵌套会让代码变得难以理解。如果结构过于复杂，可能需要考虑使用类（后续章节内容）。</li>
</ul>
<hr>
<h4 id="本章总结-4"><a href="#本章总结-4" class="headerlink" title="本章总结"></a><strong>本章总结</strong></h4><p>第六章为我的编程工具箱增添了一件极其强大的工具——字典。与列表的有序索引不同，字典通过<strong>键-值对</strong>的方式存储数据，这让我能够更直观、更灵活地模拟现实世界中的事物。我详细学习了字典的<strong>增、删、改、查</strong>操作，特别掌握了使用<code>.get()</code>方法安全地访问值以避免<code>KeyError</code>。本章的重点之一是<strong>遍历字典</strong>的多种方式：使用<code>.items()</code>遍历键值对，<code>.keys()</code>遍历键，以及<code>.values()</code>遍历值（并结合<code>set()</code>去重）。最后，<strong>嵌套</strong>的概念极大地扩展了我组织数据的能力，让我能够构建出如“字典列表”、“字典中包含列表”等复杂而强大的数据结构。掌握字典后，我处理结构化数据的能力有了质的飞跃。</p>
<h3 id="第七章：用户输入和while循环"><a href="#第七章：用户输入和while循环" class="headerlink" title="第七章：用户输入和while循环"></a><strong>第七章：用户输入和while循环</strong></h3><h4 id="核心概要-6"><a href="#核心概要-6" class="headerlink" title="核心概要"></a><strong>核心概要</strong></h4><p>到目前为止，我们编写的程序都是“自说自话”，从头到尾执行完毕，无法与用户进行交互。本章引入了两个核心概念，彻底改变了这一点：</p>
<ol>
<li><code>input()</code>** 函数**：让程序能够暂停运行，接收用户从键盘输入的信息。</li>
<li><code>while</code>** 循环**：让程序能够根据特定条件<strong>持续运行</strong>，而不是只执行一次就结束。</li>
</ol>
<p>通过结合使用 <code>input()</code> 和 <code>while</code> 循环，我们将能够编写出真正的<strong>交互式程序</strong>，比如不断询问用户问题、根据用户选择决定何时退出、以及使用循环来高效地处理列表和字典中的数据。</p>
<hr>
<h4 id="7-1-input-函数的工作原理"><a href="#7-1-input-函数的工作原理" class="headerlink" title="7.1 input() 函数的工作原理"></a><strong>7.1 <strong><code>input()</code></strong> 函数的工作原理</strong></h4><p><strong>1. 获取用户输入</strong></p>
<ul>
<li><strong>功能</strong>：<code>input()</code> 函数会暂停程序，等待用户输入文本，并在用户按下回车键后，获取输入的内容。</li>
<li><strong>语法</strong>：<code>variable = input(&quot;Your prompt message: &quot;)</code><ul>
<li><strong>提示（Prompt）</strong>：<code>input()</code> 函数可以接受一个字符串参数，这个字符串会显示给用户，告诉用户应该输入什么信息。</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">message = <span class="built_in">input</span>(<span class="string">&quot;Tell me something, and I will repeat it back to you: &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(message)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>重要特性</strong>：<code>input()</code> 函数接收到的所有输入，<strong>无论用户输入的是数字还是文本，都会被Python当作字符串来处理</strong>。</li>
</ul>
<p><strong>2. 编写清晰的提示</strong></p>
<ul>
<li><strong>规范</strong>：为了让用户体验更好，提示信息应该清晰、简洁。</li>
<li><strong>技巧</strong>：<ul>
<li>在提示信息的末尾通常会加上一个冒号和空格 (<code>: </code>)，这样用户的输入就会紧跟在提示符后面，看起来更整洁。</li>
<li>如果提示信息很长，可以先将其存储在一个变量中，再把这个变量传递给 <code>input()</code> 函数，这样可以提高代码的可读性。</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">prompt = <span class="string">&quot;If you share your name, we can personalize the messages you see.&quot;</span></span><br><span class="line">prompt += <span class="string">&quot;\nWhat is your first name? &quot;</span> <span class="comment"># 使用 += 附加字符串</span></span><br><span class="line"></span><br><span class="line">name = <span class="built_in">input</span>(prompt)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;\nHello, <span class="subst">&#123;name&#125;</span>!&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>3. 获取数值输入</strong></p>
<ul>
<li><strong>问题</strong>：因为 <code>input()</code> 返回的是字符串，所以不能直接用它来进行数学比较或运算。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">age = <span class="built_in">input</span>(<span class="string">&quot;How old are you? &quot;</span>)</span><br><span class="line"><span class="comment"># if age &gt;= 18:  &lt;-- 这里会引发 TypeError，因为不能比较字符串和整数</span></span><br><span class="line">```*   **解决方法**：使用 `<span class="built_in">int</span>()` 函数将字符串转换为整数。</span><br><span class="line">```python</span><br><span class="line">age = <span class="built_in">input</span>(<span class="string">&quot;How old are you? &quot;</span>)</span><br><span class="line">age = <span class="built_in">int</span>(age) <span class="comment"># 转换类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> age &gt;= <span class="number">18</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;You are tall enough to ride!&quot;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>注意</strong>：<code>int()</code> 函数只能转换纯数字组成的字符串。如果用户输入了非数字字符，程序会引发<code>ValueError</code>。</li>
</ul>
<p><strong>4. 求模运算符 (</strong><code>%</code><strong>)</strong></p>
<ul>
<li><strong>功能</strong>：这是一个非常有用的数学运算符，它将两个数相除并返回<strong>余数</strong>。</li>
<li><strong>语法</strong>：<code>number % divisor</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="number">4</span> % <span class="number">3</span>)  <span class="comment"># 输出: 1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">6</span> % <span class="number">3</span>)  <span class="comment"># 输出: 0</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>应用</strong>：一个常见的用途是判断一个数是奇数还是偶数。如果一个数能被2整除，那么它对2求模的余数就是0。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">number = <span class="built_in">input</span>(<span class="string">&quot;Enter a number: &quot;</span>)</span><br><span class="line">number = <span class="built_in">int</span>(number)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> number % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;The number is even.&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;The number is odd.&quot;</span>)</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="7-2-while-循环简介"><a href="#7-2-while-循环简介" class="headerlink" title="7.2 while 循环简介"></a><strong>7.2 <strong><code>while</code></strong> 循环简介</strong></h4><p><strong>1. <strong><code>for</code></strong> 循环 vs. <strong><code>while</code></strong> 循环</strong></p>
<ul>
<li><code>for</code>** 循环**：用于<strong>遍历一个集合</strong>（如列表或字典）中的每个元素，循环次数是确定的。</li>
<li><code>while</code>** 循环**：在<strong>指定的条件为</strong><code>True</code><strong>时</strong>不断地执行一个代码块，循环次数通常是不确定的，取决于条件的改变。</li>
</ul>
<p><strong>2. 使用</strong><code>while</code><strong>循环</strong></p>
<ul>
<li><strong>语法</strong>：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> conditional_test:</span><br><span class="line">    do_something()</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>示例</strong>：从1数到5</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">current_number = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> current_number &lt;= <span class="number">5</span>:</span><br><span class="line">    <span class="built_in">print</span>(current_number)</span><br><span class="line">    current_number += <span class="number">1</span> <span class="comment"># 关键一步：更新条件，否则会无限循环</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>注意</strong>：<code>+= 1</code> 是 <code>current_number = current_number + 1</code> 的简写。</li>
</ul>
<p><strong>3. 让用户选择何时退出</strong></p>
<ul>
<li><strong>方法</strong>：设置一个<strong>退出值（quit value）</strong>，当用户输入这个值时，<code>while</code>循环的条件变为<code>False</code>，循环结束。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">prompt = <span class="string">&quot;\nTell me something... (Enter &#x27;quit&#x27; to end the program.) &quot;</span></span><br><span class="line">message = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">while</span> message != <span class="string">&#x27;quit&#x27;</span>:</span><br><span class="line">    message = <span class="built_in">input</span>(prompt)</span><br><span class="line">    <span class="keyword">if</span> message != <span class="string">&#x27;quit&#x27;</span>: <span class="comment"># 避免打印出 &#x27;quit&#x27;</span></span><br><span class="line">        <span class="built_in">print</span>(message)</span><br></pre></td></tr></table></figure>

<p><strong>4. 使用标志（Flag）</strong></p>
<ul>
<li><strong>概念</strong>：标志是一个布尔变量（<code>True</code>&#x2F;<code>False</code>），用于控制程序的活动状态。</li>
<li><strong>优势</strong>：当程序有多个可能导致退出的事件时（比如游戏中的多种结束条件），使用标志可以让<code>while</code>语句的条件保持简洁，而将复杂的逻辑判断放在循环体内处理。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">active = <span class="literal">True</span> <span class="comment"># 这是一个标志</span></span><br><span class="line"><span class="keyword">while</span> active:</span><br><span class="line">    message = <span class="built_in">input</span>(prompt)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> message == <span class="string">&#x27;quit&#x27;</span>:</span><br><span class="line">        active = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(message)</span><br></pre></td></tr></table></figure>

<p><strong>5. 使用</strong><code>break</code><strong>退出循环</strong></p>
<ul>
<li><strong>功能</strong>：<code>break</code>语句可以立即退出任何循环（<code>for</code>或<code>while</code>），不再执行循环中余下的代码。</li>
<li><strong>应用</strong>：可以用来创建一个无限循环 <code>while True:</code>，然后在循环体内通过<code>if</code>语句判断退出条件，并用<code>break</code>来终止循环。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    city = <span class="built_in">input</span>(prompt)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> city == <span class="string">&#x27;quit&#x27;</span>:</span><br><span class="line">        <span class="keyword">break</span> <span class="comment"># 立即退出循环</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;I&#x27;d love to go to <span class="subst">&#123;city.title()&#125;</span>!&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>6. 在循环中使用</strong><code>continue</code></p>
<ul>
<li><strong>功能</strong>：<code>continue</code>语句会忽略本次循环中余下的代码，直接返回到循环的开头，进行下一次条件判断。</li>
<li><strong>示例</strong>：只打印奇数</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">current_number = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> current_number &lt; <span class="number">10</span>:</span><br><span class="line">    current_number += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> current_number % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">continue</span> <span class="comment"># 如果是偶数，跳过print语句，直接开始下一次循环</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(current_number)</span><br></pre></td></tr></table></figure>

<p><strong>7. 避免无限循环</strong></p>
<ul>
<li><strong>重要提醒</strong>：每个<code>while</code>循环都必须有可靠的退出路径。如果循环条件永远为<code>True</code>，程序就会陷入<strong>无限循环</strong>。</li>
<li><strong>调试</strong>：如果程序卡住不动，很可能就是陷入了无限循环。可以通过按 <code>Ctrl + C</code> 来终止它。</li>
</ul>
<hr>
<h4 id="7-3-使用while循环处理列表和字典"><a href="#7-3-使用while循环处理列表和字典" class="headerlink" title="7.3 使用while循环处理列表和字典"></a><strong>7.3 使用</strong><code>while</code><strong>循环处理列表和字典</strong></h4><p><strong>1. 在列表之间移动元素</strong></p>
<ul>
<li><strong>场景</strong>：将一个列表中的元素处理后，移到另一个列表中。例如，将待验证用户移到已验证用户列表。</li>
<li><strong>方法</strong>：使用<code>while</code>循环和<code>.pop()</code>方法。<code>while</code>循环比<code>for</code>循环更适合这种场景，因为在<code>for</code>循环中修改列表的长度是不安全的。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">unconfirmed_users = [<span class="string">&#x27;alice&#x27;</span>, <span class="string">&#x27;brian&#x27;</span>, <span class="string">&#x27;candace&#x27;</span>]</span><br><span class="line">confirmed_users = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> unconfirmed_users:</span><br><span class="line">    current_user = unconfirmed_users.pop()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Verifying user: <span class="subst">&#123;current_user.title()&#125;</span>&quot;</span>)</span><br><span class="line">    confirmed_users.append(current_user)</span><br></pre></td></tr></table></figure>

<p><strong>2. 删除列表中所有为特定值的元素</strong></p>
<ul>
<li><strong>问题</strong>：<code>for</code>循环不适合在遍历时删除元素，而<code>.remove()</code>方法一次只删除一个。</li>
<li><strong>解决方法</strong>：使用<code>while</code>循环。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pets = [<span class="string">&#x27;dog&#x27;</span>, <span class="string">&#x27;cat&#x27;</span>, <span class="string">&#x27;dog&#x27;</span>, <span class="string">&#x27;goldfish&#x27;</span>, <span class="string">&#x27;cat&#x27;</span>, <span class="string">&#x27;rabbit&#x27;</span>, <span class="string">&#x27;cat&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="string">&#x27;cat&#x27;</span> <span class="keyword">in</span> pets:</span><br><span class="line">    pets.remove(<span class="string">&#x27;cat&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>3. 使用用户输入填充字典</strong></p>
<ul>
<li><strong>场景</strong>：进行一项调查，不断收集用户的回答，并将结果存储在字典中。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">responses = &#123;&#125;</span><br><span class="line">polling_active = <span class="literal">True</span> <span class="comment"># 使用标志</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> polling_active:</span><br><span class="line">    name = <span class="built_in">input</span>(<span class="string">&quot;\nWhat is your name? &quot;</span>)</span><br><span class="line">    response = <span class="built_in">input</span>(<span class="string">&quot;Which mountain would you like to climb someday? &quot;</span>)</span><br><span class="line">    </span><br><span class="line">    responses[name] = response <span class="comment"># 存储到字典</span></span><br><span class="line">    </span><br><span class="line">    repeat = <span class="built_in">input</span>(<span class="string">&quot;Would you like to let another person respond? (yes/ no) &quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> repeat == <span class="string">&#x27;no&#x27;</span>:</span><br><span class="line">        polling_active = <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="本章总结-5"><a href="#本章总结-5" class="headerlink" title="本章总结"></a><strong>本章总结</strong></h4><p>第七章是实现程序交互性的关键。我学会了使用<code>input()</code>函数来获取用户的文本和数值输入，并理解了进行类型转换（<code>int()</code>）的重要性。更核心的是，我掌握了<code>while</code>循环，它让程序可以根据条件持续运行。我学会了三种控制<code>while</code>循环流程的方式：<strong>直接检查条件</strong>、使用<strong>标志（Flag）</strong>、以及在循环体内使用**<code>break</code>**语句。我还了解了<code>continue</code>语句如何跳过当前循环的剩余部分。最后，本章展示了<code>while</code>循环在处理列表和字典时的强大能力，特别是在需要修改集合内容（如移动或删除元素）的场景下，<code>while</code>循环比<code>for</code>循环更加安全和适用。现在，我终于可以编写一个能与人“对话”的程序了。</p>
<h3 id="第八章：函数"><a href="#第八章：函数" class="headerlink" title="第八章：函数"></a><strong>第八章：函数</strong></h3><h4 id="核心概要-7"><a href="#核心概要-7" class="headerlink" title="核心概要"></a><strong>核心概要</strong></h4><p>本章介绍了一个至关重要的编程概念——<strong>函数（Function）</strong>。函数是<strong>为了完成特定任务而组织起来的、可重复使用的代码块</strong>。在此之前，我们写的代码都是从上到下执行，如果想重复某个任务，就必须复制粘贴代码。函数彻底改变了这一点，它让我们能够给一段代码命名，然后在程序的任何地方通过这个名字来**调用（Call）**它。</p>
<p>本章的核心目标是让你掌握：</p>
<ol>
<li><strong>如何定义和调用函数</strong>。</li>
<li><strong>如何向函数传递信息</strong>（通过<strong>实参</strong>和<strong>形参</strong>）。</li>
<li><strong>如何让函数返回值</strong>，以便程序可以使用函数处理后的结果。</li>
<li><strong>如何将函数与列表等数据结构结合使用</strong>。</li>
<li><strong>如何将函数存储在独立的文件（模块）中</strong>，以保持主程序的整洁。</li>
</ol>
<p>学习函数，是为了编写更高效、更易读、更易于维护和调试的代码。</p>
<hr>
<h4 id="8-1-定义函数"><a href="#8-1-定义函数" class="headerlink" title="8.1 定义函数"></a><strong>8.1 定义函数</strong></h4><p><strong>1. 最简单的函数</strong></p>
<ul>
<li><strong>概念</strong>：一个不接收信息、也不返回信息的简单函数。</li>
<li><strong>语法</strong>：<ul>
<li>使用关键字 <code>def</code> (define的缩写)来声明函数。</li>
<li>后面跟着函数名和一对圆括号 <code>()</code>。</li>
<li>函数定义的第一行以冒号 <code>:</code> 结尾。</li>
<li>函数体内的所有代码都必须<strong>缩进</strong>。</li>
</ul>
</li>
<li><strong>文档字符串 (Docstring)</strong>：函数定义后的第一行，用三引号 <code>&quot;&quot;&quot;...&quot;&quot;&quot;</code> 括起来的字符串，用于解释函数的功能。这是一个非常好的编程习惯。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">greet_user</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;显示简单的问候语&quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用函数</span></span><br><span class="line">greet_user()</span><br></pre></td></tr></table></figure>

<p><strong>2. 向函数传递信息</strong></p>
<ul>
<li><strong>概念</strong>：可以让函数接收信息，使其功能更加灵活。</li>
<li><strong>形参 (Parameter)</strong>：在<strong>函数定义</strong>的圆括号中声明的变量，用于接收信息。</li>
<li><strong>实参 (Argument)</strong>：在<strong>调用函数</strong>时，传递给函数的具体值。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">greet_user</span>(<span class="params">username</span>): <span class="comment"># username 是形参</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;显示个性化的问告语&quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Hello, <span class="subst">&#123;username.title()&#125;</span>!&quot;</span>)</span><br><span class="line"></span><br><span class="line">greet_user(<span class="string">&#x27;jesse&#x27;</span>) <span class="comment"># &#x27;jesse&#x27; 是实参</span></span><br><span class="line">```*   **工作流程**：调用函数时，实参的值会传递并赋给对应的形参。</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="8-2-传递实参"><a href="#8-2-传递实参" class="headerlink" title="8.2 传递实参"></a><strong>8.2 传递实参</strong></h4><p>有多种方式可以向函数传递实参。</p>
<p><strong>1. 位置实参 (Positional Arguments)</strong></p>
<ul>
<li><strong>概念</strong>：这是最常见的传参方式。实参的传递顺序与形参的定义顺序一一对应。</li>
<li><strong>示例</strong>：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">describe_pet</span>(<span class="params">animal_type, pet_name</span>):</span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line">describe_pet(<span class="string">&#x27;hamster&#x27;</span>, <span class="string">&#x27;harry&#x27;</span>) <span class="comment"># &#x27;hamster&#x27; 对应 animal_type, &#x27;harry&#x27; 对应 pet_name</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>注意</strong>：<strong>顺序至关重要</strong>，如果顺序搞错，会导致逻辑错误。</li>
</ul>
<p><strong>2. 关键字实参 (Keyword Arguments)</strong></p>
<ul>
<li><strong>概念</strong>：在函数调用时，明确指定每个实参要传递给哪个形参。</li>
<li><strong>语法</strong>：<code>parameter_name = value</code></li>
<li><strong>优势</strong>：<strong>顺序不再重要</strong>，并且让函数调用的意图更加清晰。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">describe_pet(animal_type=<span class="string">&#x27;hamster&#x27;</span>, pet_name=<span class="string">&#x27;harry&#x27;</span>)</span><br><span class="line">describe_pet(pet_name=<span class="string">&#x27;harry&#x27;</span>, animal_type=<span class="string">&#x27;hamster&#x27;</span>) <span class="comment"># 效果完全相同</span></span><br></pre></td></tr></table></figure>

<p><strong>3. 默认值 (Default Values)</strong></p>
<ul>
<li><strong>功能</strong>：在定义函数时，可以为形参指定一个默认值。如果在调用函数时没有为该形参提供实参，Python就会使用这个默认值。</li>
<li><strong>语法</strong>：在形参列表中，使用等号为形参赋值。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">describe_pet</span>(<span class="params">pet_name, animal_type=<span class="string">&#x27;dog&#x27;</span></span>): <span class="comment"># animal_type 默认值为 &#x27;dog&#x27;</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line">describe_pet(pet_name=<span class="string">&#x27;willie&#x27;</span>) <span class="comment"># 只需提供 pet_name，animal_type 会自动使用 &#x27;dog&#x27;</span></span><br><span class="line">describe_pet(pet_name=<span class="string">&#x27;harry&#x27;</span>, animal_type=<span class="string">&#x27;hamster&#x27;</span>) <span class="comment"># 也可以提供新值来覆盖默认值</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>重要规则</strong>：在函数定义中，<strong>必须先列出没有默认值的形参，再列出有默认值的形参</strong>。</li>
</ul>
<p><strong>4. 避免实参错误</strong></p>
<ul>
<li><strong>常见错误</strong>：<code>TypeError</code>，通常是因为提供的实参数量与函数定义的形参数量不匹配（太多或太少）。</li>
<li><strong>调试</strong>：Python的错误信息会明确告诉你函数需要哪些参数，以及你提供了多少。</li>
</ul>
<hr>
<h4 id="8-3-返回值"><a href="#8-3-返回值" class="headerlink" title="8.3 返回值"></a><strong>8.3 返回值</strong></h4><p>函数不一定非要直接打印输出，它们可以处理数据后**返回（Return）**一个或一组值。</p>
<p><strong>1. 返回简单的值</strong></p>
<ul>
<li><strong>语法</strong>：使用 <code>return</code> 语句。</li>
<li><strong>功能</strong>：函数执行到<code>return</code>语句时会结束，并将<code>return</code>后面的值返回到函数被调用的地方。你需要用一个变量来接收这个返回值。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_formatted_name</span>(<span class="params">first_name, last_name</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;返回标准格式的姓名&quot;&quot;&quot;</span></span><br><span class="line">    full_name = <span class="string">f&quot;<span class="subst">&#123;first_name&#125;</span> <span class="subst">&#123;last_name&#125;</span>&quot;</span></span><br><span class="line">    <span class="keyword">return</span> full_name.title()</span><br><span class="line"></span><br><span class="line">musician = get_formatted_name(<span class="string">&#x27;jimi&#x27;</span>, <span class="string">&#x27;hendrix&#x27;</span>) <span class="comment"># 将返回值存储在变量 musician 中</span></span><br><span class="line"><span class="built_in">print</span>(musician) <span class="comment"># 输出: Jimi Hendrix</span></span><br></pre></td></tr></table></figure>

<p><strong>2. 让实参变成可选的</strong></p>
<ul>
<li><strong>场景</strong>：有些信息（如中间名）不是必需的。</li>
<li><strong>方法</strong>：为可选的形参提供一个默认值（通常是空字符串 <code>&#39;&#39;</code> 或 <code>None</code>）。然后在函数体内使用 <code>if</code> 语句检查该形参是否有值。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_formatted_name</span>(<span class="params">first_name, last_name, middle_name=<span class="string">&#x27;&#x27;</span></span>):</span><br><span class="line">    <span class="keyword">if</span> middle_name: <span class="comment"># 如果 middle_name 不是空字符串</span></span><br><span class="line">        full_name = <span class="string">f&quot;<span class="subst">&#123;first_name&#125;</span> <span class="subst">&#123;middle_name&#125;</span> <span class="subst">&#123;last_name&#125;</span>&quot;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        full_name = <span class="string">f&quot;<span class="subst">&#123;first_name&#125;</span> <span class="subst">&#123;last_name&#125;</span>&quot;</span></span><br><span class="line">    <span class="keyword">return</span> full_name.title()</span><br></pre></td></tr></table></figure>

<p><strong>3. 返回字典</strong></p>
<ul>
<li><strong>功能</strong>：函数可以返回任何数据类型，包括字典，这对于构建结构化的数据非常有用。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">build_person</span>(<span class="params">first_name, last_name</span>):</span><br><span class="line">    person = &#123;<span class="string">&#x27;first&#x27;</span>: first_name, <span class="string">&#x27;last&#x27;</span>: last_name&#125;</span><br><span class="line">    <span class="keyword">return</span> person</span><br></pre></td></tr></table></figure>

<p><strong>4. 结合使用函数和</strong><code>while</code><strong>循环</strong></p>
<ul>
<li><strong>应用</strong>：可以创建一个交互式程序，在<code>while</code>循环中调用函数来处理用户的输入。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># ...获取用户输入 f_name 和 l_name</span></span><br><span class="line">    formatted_name = get_formatted_name(f_name, l_name)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;\nHello, <span class="subst">&#123;formatted_name&#125;</span>!&quot;</span>)</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="8-4-8-5-8-6-传递和存储函数"><a href="#8-4-8-5-8-6-传递和存储函数" class="headerlink" title="8.4 &amp; 8.5 &amp; 8.6 传递和存储函数"></a><strong>8.4 &amp; 8.5 &amp; 8.6 传递和存储函数</strong></h4><p><strong>1. 传递列表</strong></p>
<ul>
<li><strong>功能</strong>：可以将整个列表作为实参传递给函数。函数可以直接访问和操作列表的内容。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">greet_users</span>(<span class="params">names</span>):</span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> names:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Hello, <span class="subst">&#123;name.title()&#125;</span>!&quot;</span>)</span><br><span class="line"></span><br><span class="line">usernames = [<span class="string">&#x27;hannah&#x27;</span>, <span class="string">&#x27;ty&#x27;</span>, <span class="string">&#x27;margot&#x27;</span>]</span><br><span class="line">greet_users(usernames)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>在函数中修改列表</strong>：函数对列表所做的任何修改都是<strong>永久性的</strong>，因为函数操作的是原始列表本身。</li>
<li><strong>禁止函数修改列表</strong>：如果你不希望函数修改原始列表，可以向函数传递列表的<strong>副本</strong>。<ul>
<li><strong>语法</strong>：使用切片 <code>[:]</code> 来创建副本：<code>function_name(list_name[:])</code>。</li>
</ul>
</li>
</ul>
<p><strong>2. 传递任意数量的实参</strong></p>
<ul>
<li><strong>使用 <strong><code>*args</code></strong>（收集位置实参）</strong>：<ul>
<li><strong>语法</strong>：在形参名前加一个星号 <code>*</code>。</li>
<li><strong>功能</strong>：这会告诉Python创建一个<strong>元组（Tuple）</strong>，并将所有传递给该形参的位置实参都收集到这个元组中。形参名通常约定为 <code>*args</code>。</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">make_pizza</span>(<span class="params">*toppings</span>): <span class="comment"># toppings 会是一个元组</span></span><br><span class="line">    <span class="built_in">print</span>(toppings)</span><br><span class="line"></span><br><span class="line">make_pizza(<span class="string">&#x27;pepperoni&#x27;</span>) <span class="comment"># 输出: (&#x27;pepperoni&#x27;,)</span></span><br><span class="line">make_pizza(<span class="string">&#x27;mushrooms&#x27;</span>, <span class="string">&#x27;green peppers&#x27;</span>) <span class="comment"># 输出: (&#x27;mushrooms&#x27;, &#x27;green peppers&#x27;)</span></span><br><span class="line">```*   **使用 `**kwargs`（收集关键字实参）**：</span><br></pre></td></tr></table></figure>

<pre><code>- **语法**：在形参名前加两个星号 `**`。
- **功能**：这会告诉Python创建一个**字典（Dictionary）**，并将所有传递给该形参的关键字实参都收集到这个字典中。形参名通常约定为 `**kwargs`。
</code></pre>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">build_profile</span>(<span class="params">first, last, **user_info</span>): <span class="comment"># user_info 会是一个字典</span></span><br><span class="line">    user_info[<span class="string">&#x27;first_name&#x27;</span>] = first</span><br><span class="line">    user_info[<span class="string">&#x27;last_name&#x27;</span>] = last</span><br><span class="line">    <span class="keyword">return</span> user_info</span><br><span class="line"></span><br><span class="line">user_profile = build_profile(<span class="string">&#x27;albert&#x27;</span>, <span class="string">&#x27;einstein&#x27;</span>, location=<span class="string">&#x27;princeton&#x27;</span>, field=<span class="string">&#x27;physics&#x27;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>形参顺序</strong>：在定义函数时，<code>*args</code> 必须在位置形参之后，<code>**kwargs</code> 必须在最后。</li>
</ul>
<p><strong>3. 将函数存储在模块中</strong></p>
<ul>
<li><strong>模块 (Module)</strong>：一个<code>.py</code>文件就是一个模块。</li>
<li><strong>优势</strong>：可以将函数存储在独立的文件中，然后在主程序中**导入（import）**它们。这有助于：<ul>
<li>保持主程序代码的简洁和逻辑清晰。</li>
<li>实现代码的复用。</li>
</ul>
</li>
<li><strong>导入方式</strong>：<ol>
<li><strong>导入整个模块</strong>：<code>import module_name</code>，调用时需使用 <code>module_name.function_name()</code>。</li>
<li><strong>导入特定函数</strong>：<code>from module_name import function_name</code>，调用时直接使用 <code>function_name()</code>。</li>
<li><strong>使用</strong><code>as</code><strong>给函数指定别名</strong>：<code>from module_name import function_name as fn</code>。</li>
<li><strong>使用</strong><code>as</code><strong>给模块指定别名</strong>：<code>import module_name as mn</code>。</li>
<li><strong>导入模块中所有函数（不推荐）</strong>：<code>from module_name import *</code>，这可能导致命名冲突。</li>
</ol>
</li>
</ul>
<hr>
<h4 id="8-7-函数编写指南"><a href="#8-7-函数编写指南" class="headerlink" title="8.7 函数编写指南"></a><strong>8.7 函数编写指南</strong></h4><ul>
<li><strong>命名</strong>：函数名和模块名应使用描述性的小写名称，单词间用下划线分隔。</li>
<li><strong>注释</strong>：每个函数都应有一个简洁的文档字符串（docstring），解释其功能。</li>
<li><strong>参数格式</strong>：在指定默认值时，等号两边不加空格，如 <code>def function(param=5):</code>。</li>
<li><strong>空行</strong>：使用两个空行来分隔模块中的不同函数，以提高可读性。</li>
<li><strong>import语句</strong>：应放在文件的开头。</li>
</ul>
<hr>
<h4 id="本章总结-6"><a href="#本章总结-6" class="headerlink" title="本章总结"></a><strong>本章总结</strong></h4><p>第八章是提升编程能力的关键一跃。通过学习函数，我掌握了将代码模块化、组织化的核心方法。我不仅学会了如何定义和调用函数，还深入理解了<strong>位置实参、关键字实参、默认值</strong>以及如何接收<strong>任意数量的实参</strong>（<code>*args</code>和<code>**kwargs</code>）。<code>return</code>语句让我能够让函数处理数据并返回结果，极大地增强了程序的灵活性。将函数存储在<strong>模块</strong>中并进行导入，更是让我理解了现代软件工程中代码组织和复用的基本思想。现在，我已经不再满足于编写简单的脚本，而是有能力开始构建结构更清晰、逻辑更复杂的程序了。</p>
<h3 id="第九章：类"><a href="#第九章：类" class="headerlink" title="第九章：类"></a><strong>第九章：类</strong></h3><h4 id="核心概要-8"><a href="#核心概要-8" class="headerlink" title="核心概要"></a><strong>核心概要</strong></h4><p>在之前的章节中，我们学习了如何使用函数来组织代码，以及如何使用列表和字典来存储数据。本章将这两者结合起来，引入了**类（Class）<strong>的概念。类是一种将</strong>数据（属性）<strong>和</strong>操作这些数据的方法（函数）**封装在一起的方式。</p>
<p>简单来说，<strong>类是创建对象的蓝图</strong>。比如，我们可以创建一个<code>Dog</code>类，这个类描述了所有狗共有的特征（如名字、年龄）和行为（如坐下、打滚）。然后，我们可以根据这个<code>Dog</code>类，创建出具体的、独一-无二的狗的**对象（Object）<strong><strong>或</strong></strong>实例（Instance）**，比如一只叫“威利”的6岁小狗，或者一只叫“露西”的3岁小狗。</p>
<p>本章的核心目标是让你掌握：</p>
<ol>
<li><strong>如何创建和使用类</strong>。</li>
<li><strong>如何创建类的实例，并访问其属性和调用其方法</strong>。</li>
<li><strong>如何通过继承（Inheritance）让一个类获得另一个类的所有功能</strong>，并在此基础上进行扩展。</li>
<li><strong>如何将类存储在模块中</strong>，以实现代码的组织和复用。</li>
</ol>
<hr>
<h4 id="9-1-创建和使用类"><a href="#9-1-创建和使用类" class="headerlink" title="9.1 创建和使用类"></a><strong>9.1 创建和使用类</strong></h4><p><strong>1. 创建 <strong><code>Dog</code></strong> 类</strong></p>
<ul>
<li><strong>概念</strong>：创建一个简单的<code>Dog</code>类，用于模拟小狗。</li>
<li><strong>语法</strong>：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;一次模拟小狗的简单尝试&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># ... 类的内容 ...</span></span><br></pre></td></tr></table></figure>

<pre><code>- 使用关键字 `class` 来定义一个类。
- 类名通常采用**驼峰命名法（CamelCase）**，即每个单词的首字母都大写，如 `ElectricCar`。
- 类定义后紧跟一个描述该类功能的**文档字符串**。
</code></pre>
<p><strong>2. <strong><code>__init__()</code></strong> 方法</strong></p>
<ul>
<li><strong>核心概念</strong>：这是一个<strong>特殊的方法</strong>，在每次根据类创建新实例时，Python都会<strong>自动运行</strong>它。它的名字前后都有两个下划线，用于区分普通方法。</li>
<li><strong>功能</strong>：初始化实例的属性。可以想象成是新生对象的“出生设置”。</li>
<li><code>self</code>** 形参**：<ul>
<li><code>__init__()</code> 方法的第一个形参**必须是 **<code>self</code>。</li>
<li><code>self</code> 是一个指向<strong>实例本身</strong>的引用。它让实例能够访问类中的属性和方法。</li>
<li>在创建实例时，Python会自动传递<code>self</code>实参，我们<strong>不需要手动提供</strong>。</li>
</ul>
</li>
<li><strong>属性 (Attributes)</strong>：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;初始化属性name和age&quot;&quot;&quot;</span></span><br><span class="line">    <span class="variable language_">self</span>.name = name  <span class="comment"># 将形参name的值赋给实例的属性self.name</span></span><br><span class="line">    <span class="variable language_">self</span>.age = age    <span class="comment"># 将形参age的值赋给实例的属性self.age</span></span><br></pre></td></tr></table></figure>

<pre><code>- 属性是与实例相关联的变量。
- 在`__init__()`方法中，通过`self.属性名 = 值`的方式来定义属性。
</code></pre>
<p><strong>3. 定义方法 (Methods)</strong></p>
<ul>
<li><strong>概念</strong>：在类中定义的函数称为方法。它描述了实例能够执行的操作。</li>
<li><strong>语法</strong>：与定义普通函数类似，但第一个形参**必须是 **<code>self</code>，以便方法能够访问实例的属性和其他方法。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sit</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;模拟小狗收到命令时坐下&quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;self.name&#125;</span> is now sitting.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">roll_over</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;模拟小狗收到命令时打滚&quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;self.name&#125;</span> rolled over!&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>4. 根据类创建实例</strong></p>
<ul>
<li><strong>概念</strong>：创建类的具体对象的过程称为<strong>实例化</strong>。</li>
<li><strong>语法</strong>：<code>instance_name = ClassName(arg1, arg2, ...)</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_dog = Dog(<span class="string">&#x27;Willie&#x27;</span>, <span class="number">6</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>执行过程</strong>：Python会调用<code>Dog</code>类中的<code>__init__()</code>方法，并将 <code>&#39;Willie&#39;</code> 和 <code>6</code> 这两个实参分别传递给形参<code>name</code>和<code>age</code>。<code>__init__()</code>方法创建一个实例，设置其属性，然后将这个实例返回并赋给变量<code>my_dog</code>。</li>
</ul>
<p><strong>5. 访问属性</strong></p>
<ul>
<li><strong>语法</strong>：使用**点号 **<code>.</code> 来访问实例的属性。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;My dog&#x27;s name is <span class="subst">&#123;my_dog.name&#125;</span>.&quot;</span>) <span class="comment"># 输出: My dog&#x27;s name is Willie.</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;My dog is <span class="subst">&#123;my_dog.age&#125;</span> years old.&quot;</span>) <span class="comment"># 输出: My dog is 6 years old.</span></span><br></pre></td></tr></table></figure>

<p><strong>6. 调用方法</strong></p>
<ul>
<li><strong>语法</strong>：同样使用**点号 **<code>.</code> 来调用实例的方法。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">my_dog.sit()       <span class="comment"># 输出: Willie is now sitting.</span></span><br><span class="line">my_dog.roll_over() <span class="comment"># 输出: Willie rolled over!</span></span><br></pre></td></tr></table></figure>

<p><strong>7. 创建多个实例</strong></p>
<ul>
<li><strong>概念</strong>：可以根据一个类创建任意数量的实例。每个实例都是独立的，拥有自己的一套属性，但共享相同的方法。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">your_dog = Dog(<span class="string">&#x27;Lucy&#x27;</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="9-2-使用类和实例"><a href="#9-2-使用类和实例" class="headerlink" title="9.2 使用类和实例"></a><strong>9.2 使用类和实例</strong></h4><p><strong>1. <strong><code>Car</code></strong> 类示例</strong></p>
<ul>
<li>本节通过创建一个更实际的<code>Car</code>类来进一步讲解类的使用。这个类有<code>make</code>（制造商）、<code>model</code>（型号）、<code>year</code>（年份）等属性。</li>
</ul>
<p><strong>2. 给属性指定默认值</strong></p>
<ul>
<li><strong>功能</strong>：可以让某个属性在创建实例时拥有一个固定的初始值，而无需通过形参提供。</li>
<li><strong>方法</strong>：直接在<code>__init__()</code>方法中定义这个属性即可。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, make, model, year</span>):</span><br><span class="line">        <span class="comment"># ...</span></span><br><span class="line">        <span class="variable language_">self</span>.odometer_reading = <span class="number">0</span> <span class="comment"># 里程表读数，默认值为0</span></span><br></pre></td></tr></table></figure>

<p><strong>3. 修改属性的值</strong></p>
<ul>
<li><strong>方法一：直接修改</strong>：通过实例直接访问并修改属性的值。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_new_car.odometer_reading = <span class="number">23</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>方法二：通过方法修改</strong>：在类中编写一个专门的方法来更新属性的值。这样做更规范，并且可以在方法中加入逻辑检查（如禁止将里程回调）。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">update_odometer</span>(<span class="params">self, mileage</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;将里程表读数设置为指定的值&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> mileage &gt;= <span class="variable language_">self</span>.odometer_reading:</span><br><span class="line">        <span class="variable language_">self</span>.odometer_reading = mileage</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;You can&#x27;t roll back an odometer!&quot;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>方法三：通过方法递增</strong>：编写一个方法，对属性的值进行增加，而不是设置一个全新的值。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">increment_odometer</span>(<span class="params">self, miles</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;让里程表读数增加指定的量&quot;&quot;&quot;</span></span><br><span class="line">    <span class="variable language_">self</span>.odometer_reading += miles</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="9-3-继承（Inheritance）"><a href="#9-3-继承（Inheritance）" class="headerlink" title="9.3 继承（Inheritance）"></a><strong>9.3 继承（Inheritance）</strong></h4><p><strong>1. 核心概念</strong></p>
<ul>
<li><strong>功能</strong>：当你创建的一个类是另一个已存在类的特殊版本时，可以使用继承。</li>
<li><strong>父类 (Parent Class)</strong>：被继承的类。</li>
<li><strong>子类 (Child Class)</strong>：继承父类的类。</li>
<li><strong>优势</strong>：子类会自动获得父类的所有属性和方法，同时还可以定义自己特有的属性和方法。这极大地促进了代码的复用。</li>
</ul>
<p><strong>2. 子类的</strong><code>__init__()</code><strong>方法</strong></p>
<ul>
<li><strong>语法</strong>：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ElectricCar</span>(<span class="title class_ inherited__">Car</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, make, model, year</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;初始化父类的属性&quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(make, model, year)</span><br></pre></td></tr></table></figure>

<pre><code>- 定义子类时，在类名后的圆括号中指定父类的名称：`class ElectricCar(Car):`。
- 在子类的`__init__()`方法中，必须调用父类的`__init__()`方法，以初始化父类中定义的属性。
- 使用`super()`函数来实现这一点。`super()`是一个特殊函数，它让你能够调用父类的方法。
</code></pre>
<p><strong>3. 给子类定义属性和方法</strong></p>
<ul>
<li><strong>功能</strong>：在继承了父类的基础上，可以添加子类独有的新属性和新方法。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ElectricCar</span>(<span class="title class_ inherited__">Car</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, make, model, year</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(make, model, year)</span><br><span class="line">        <span class="variable language_">self</span>.battery_size = <span class="number">40</span> <span class="comment"># 添加子类特有属性</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">describe_battery</span>(<span class="params">self</span>): <span class="comment"># 添加子类特有方法</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;This car has a <span class="subst">&#123;self.battery_size&#125;</span>-kWh battery.&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>4. 重写父类中的方法 (Overriding)</strong></p>
<ul>
<li><strong>功能</strong>：如果父类中的某个方法不适用于子类，可以在子类中定义一个<strong>同名</strong>的方法来覆盖它。</li>
<li><strong>执行过程</strong>：当子类的实例调用这个方法时，Python会忽略父类中的版本，只执行子类中定义的版本。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fill_gas_tank</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;电动汽车没有油箱&quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;This car doesn&#x27;t have a gas tank!&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>5. 将实例用作属性（组合 Composition）</strong></p>
<ul>
<li><strong>概念</strong>：当你发现一个类越来越复杂，包含了很多针对某个特定部分的属性和方法时，可以把这部分提取出来，创建一个全新的类。然后，将这个新类的实例用作原来那个类的属性。</li>
<li><strong>示例</strong>：将<code>ElectricCar</code>中所有关于电池的细节（如容量、续航里程等）都提取到一个独立的<code>Battery</code>类中。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Battery</span>:</span><br><span class="line">    <span class="comment"># ... 关于电池的属性和方法 ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ElectricCar</span>(<span class="title class_ inherited__">Car</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, make, model, year</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(make, model, year)</span><br><span class="line">        <span class="variable language_">self</span>.battery = Battery() <span class="comment"># 将Battery实例作为ElectricCar的一个属性</span></span><br><span class="line">```*   **优势**：这让主类（`ElectricCar`）的结构更清晰，代码更有条理。</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="9-4-9-5-导入类与Python标准库"><a href="#9-4-9-5-导入类与Python标准库" class="headerlink" title="9.4 &amp; 9.5 导入类与Python标准库"></a><strong>9.4 &amp; 9.5 导入类与Python标准库</strong></h4><p><strong>1. 导入类</strong></p>
<ul>
<li><strong>功能</strong>：和函数一样，可以将类存储在模块中，然后在需要时导入。</li>
<li><strong>方法</strong>：<ul>
<li><strong>导入单个类</strong>：<code>from car import Car</code></li>
<li><strong>从一个模块导入多个类</strong>：<code>from car import Car, ElectricCar</code></li>
<li><strong>导入整个模块</strong>：<code>import car</code>，使用时需要 <code>car.Car()</code>。</li>
<li><strong>使用别名</strong>：<code>from electric_car import ElectricCar as EC</code>。</li>
</ul>
</li>
</ul>
<p><strong>2. Python标准库</strong></p>
<ul>
<li><strong>概念</strong>：Python自带的一组非常有用的模块，无需额外安装。</li>
<li><strong>示例</strong>：<code>random</code>模块，提供了生成随机数的工具，如<code>randint()</code>和<code>choice()</code>。</li>
</ul>
<hr>
<h4 id="9-6-类的编程风格"><a href="#9-6-类的编程风格" class="headerlink" title="9.6 类的编程风格"></a><strong>9.6 类的编程风格</strong></h4><ul>
<li><strong>类名</strong>：使用驼峰命名法（<code>MyClassName</code>）。</li>
<li><strong>实例名和模块名</strong>：使用小写字母和下划线（<code>my_instance</code>, <code>my_module.py</code>）。</li>
<li><strong>空行</strong>：在类中，使用一个空行来分隔方法；在模块中，使用两个空行来分隔类。</li>
</ul>
<hr>
<h4 id="本章总结-7"><a href="#本章总结-7" class="headerlink" title="本章总结"></a><strong>本章总结</strong></h4><p>第九章是思维方式上的一次重大转变。通过学习<strong>类</strong>，我不再是将数据和操作分离开来思考，而是将它们<strong>封装</strong>成一个紧密联系的整体——<strong>对象</strong>。我掌握了定义类、创建实例、使用属性和方法的核心技能。<strong>继承</strong>的概念让我明白了如何构建有层次、可复用的代码结构，而<strong>组合</strong>（将实例用作属性）则教会了我如何将复杂的大类拆解成更小、更易于管理的小类。最后，学习导入类让我能够像组织函数一样，有条理地组织我的项目文件。现在，我已经具备了用<strong>面向对象</strong>的思维来模拟和解决现实世界问题的基本能力。</p>
<h3 id="第十章：文件和异常"><a href="#第十章：文件和异常" class="headerlink" title="第十章：文件和异常"></a><strong>第十章：文件和异常</strong></h3><h4 id="核心概要-9"><a href="#核心概要-9" class="headerlink" title="核心概要"></a><strong>核心概要</strong></h4><p>到目前为止，我们程序中创建的数据（如列表、字典）都存储在内存中，一旦程序结束，这些数据就会丢失。本章将解决这个问题，主要围绕两个核心主题展开：</p>
<ol>
<li><strong>文件（Files）</strong>：学习如何<strong>读取文件</strong>中的数据，以及如何将程序中的数据<strong>写入文件</strong>。这使得我们的程序能够处理持久化的数据，即程序关闭后数据依然存在。</li>
<li><strong>异常（Exceptions）</strong>：学习如何处理程序在运行时可能发生的错误。通过使用**<code>try-except</code>代码块**，我们可以预见并捕获潜在的错误（如文件不存在、除以零等），从而避免程序崩溃，并给用户提供友好的提示。</li>
</ol>
<p>此外，本章还会介绍使用<code>json</code>模块来存储复杂的Python数据结构，这是一种在程序之间共享数据和保存用户设置的常用方法。</p>
<hr>
<h4 id="10-1-读取文件"><a href="#10-1-读取文件" class="headerlink" title="10.1 读取文件"></a><strong>10.1 读取文件</strong></h4><p><strong>1. 读取整个文件</strong></p>
<ul>
<li><strong>核心模块</strong>：<code>pathlib</code> 模块中的 <code>Path</code> 类，这是现代Python中处理文件路径的首选方式。</li>
<li><strong>步骤</strong>：<ol>
<li><strong>导入</strong><code>Path</code><strong>类</strong>：<code>from pathlib import Path</code></li>
<li><strong>创建路径对象</strong>：<code>path = Path(&#39;pi_digits.txt&#39;)</code>。这会创建一个指向当前目录下<code>pi_digits.txt</code>文件的对象。</li>
<li><strong>读取文件内容</strong>：使用 <code>.read_text()</code> 方法读取文件的全部内容，并将其作为一个<strong>长字符串</strong>返回。</li>
<li><strong>清理空白</strong>：<code>.read_text()</code> 读取的内容末尾可能包含一个多余的空行，可以使用 <code>.rstrip()</code> 方法将其删除。</li>
</ol>
</li>
<li><strong>代码示例</strong>：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line"></span><br><span class="line">path = Path(<span class="string">&#x27;pi_digits.txt&#x27;</span>)</span><br><span class="line">contents = path.read_text()</span><br><span class="line"><span class="built_in">print</span>(contents.rstrip())</span><br></pre></td></tr></table></figure>

<p><strong>2. 文件路径</strong></p>
<ul>
<li><strong>相对路径 (Relative Path)</strong>：相对于<strong>当前运行的程序文件</strong>所在的位置。<ul>
<li>如果文件在同一个目录下：<code>Path(&#39;pi_digits.txt&#39;)</code></li>
<li>如果文件在子目录<code>text_files</code>中：<code>Path(&#39;text_files/pi_digits.txt&#39;)</code></li>
</ul>
</li>
<li><strong>绝对路径 (Absolute Path)</strong>：从计算机的根目录开始的完整路径。<ul>
<li><strong>优点</strong>：无论你的程序文件在哪里，都能准确找到文件。</li>
<li><strong>注意</strong>：在Windows系统中，路径分隔符是反斜杠 <code>\</code>，但在Python代码中，**建议始终使用正斜杠 **<code>/</code>，<code>pathlib</code> 会自动处理不同操作系统间的差异。</li>
</ul>
</li>
</ul>
<p><strong>3. 逐行读取</strong></p>
<ul>
<li><strong>方法</strong>：使用字符串的 <code>.splitlines()</code> 方法，它可以将一个包含多行文本的长字符串分割成一个<strong>列表</strong>，列表中的每个元素是文件中的一行。</li>
<li><strong>应用</strong>：可以结合<code>for</code>循环来处理文件中的每一行。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">contents = path.read_text()</span><br><span class="line">lines = contents.splitlines() <span class="comment"># lines 是一个列表</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">    <span class="built_in">print</span>(line)</span><br></pre></td></tr></table></figure>

<p><strong>4. 使用文件内容</strong></p>
<ul>
<li><strong>核心概念</strong>：从文件中读取的内容都是<strong>字符串</strong>。</li>
<li><strong>处理技巧</strong>：<ul>
<li><strong>拼接字符串</strong>：如果想将文件的所有行合并成一个没有换行符的字符串，可以遍历行列表并逐行附加到一个空字符串上。</li>
<li><strong>类型转换</strong>：如果文件中存储的是数字，并且你想进行数学运算，必须使用 <code>int()</code> 或 <code>float()</code> 将其从字符串转换为数字类型。</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pi_string = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">    pi_string += line.lstrip() <span class="comment"># lstrip()删除每行开头的空格</span></span><br><span class="line"></span><br><span class="line">pi_float = <span class="built_in">float</span>(pi_string)</span><br><span class="line"><span class="built_in">print</span>(pi_float + <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p><strong>5. 处理大型文件</strong></p>
<ul>
<li><strong>知识点</strong>：Python处理数据的能力没有上限，只要计算机内存足够，上述方法同样适用于包含数百万行内容的文件。</li>
<li><strong>示例</strong>：书中演示了如何读取一个包含一百万位圆周率的文件，并检查其中是否包含某个人的生日。这展示了将文件内容读入内存后进行数据分析的强大能力。</li>
</ul>
<hr>
<h4 id="10-2-写入文件"><a href="#10-2-写入文件" class="headerlink" title="10.2 写入文件"></a><strong>10.2 写入文件</strong></h4><p><strong>1. 写入一行</strong></p>
<ul>
<li><strong>方法</strong>：使用路径对象的 <code>.write_text()</code> 方法。</li>
<li><strong>语法</strong>：<code>path.write_text(&quot;Some content to write.&quot;)</code></li>
<li><strong>重要行为</strong>：<ul>
<li>如果文件<strong>不存在</strong>，<code>.write_text()</code> 会<strong>自动创建</strong>它。</li>
<li>如果文件<strong>已存在</strong>，<code>.write_text()</code> 会**覆盖（删除）**文件的原有内容，然后写入新内容。<strong>这是一个需要特别小心的操作！</strong></li>
</ul>
</li>
<li><strong>数值写入</strong>：如果要写入数字，必须先用<code>str()</code>函数将其转换为字符串。</li>
</ul>
<p><strong>2. 写入多行</strong></p>
<ul>
<li><strong>方法</strong>：在要写入的字符串中包含换行符 <code>\n</code>。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">contents = <span class="string">&quot;I love programming.\n&quot;</span></span><br><span class="line">contents += <span class="string">&quot;I love creating new games.\n&quot;</span></span><br><span class="line"></span><br><span class="line">path = Path(<span class="string">&#x27;programming.txt&#x27;</span>)</span><br><span class="line">path.write_text(contents)</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="10-3-异常-Exceptions"><a href="#10-3-异常-Exceptions" class="headerlink" title="10.3 异常 (Exceptions)"></a><strong>10.3 异常 (Exceptions)</strong></h4><p>异常是Python用来管理程序运行时错误的特殊对象。</p>
<p><strong>1. <strong><code>try-except</code></strong> 代码块</strong></p>
<ul>
<li><strong>目的</strong>：处理可能引发异常的代码，避免程序因此崩溃。</li>
<li><strong>语法</strong>：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># 可能会出错的代码</span></span><br><span class="line"><span class="keyword">except</span> ExceptionName:</span><br><span class="line">    <span class="comment"># 出错了怎么办</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>执行流程</strong>：<ul>
<li>Python首先尝试执行<code>try</code>代码块中的代码。</li>
<li>如果<strong>没有错误</strong>发生，<code>except</code>代码块会被忽略。</li>
<li>如果<strong>发生错误</strong>，并且错误类型与<code>except</code>后面指定的<code>ExceptionName</code>匹配，Python就会执行<code>except</code>代码块中的代码。</li>
</ul>
</li>
<li><strong>示例：处理</strong><code>ZeroDivisionError</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">5</span> / <span class="number">0</span>)</span><br><span class="line"><span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;You can&#x27;t divide by zero!&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>这样，程序不会崩溃，而是会打印出一条友好的提示信息。</p>
<p><strong>2. <strong><code>else</code></strong> 代码块</strong></p>
<ul>
<li><strong>功能</strong>：<code>else</code>代码块包含的是仅在<code>try</code>代码块<strong>成功执行</strong>（即没有引发任何异常）时才需要运行的代码。</li>
<li><strong>优势</strong>：将成功逻辑与<code>try</code>块中的风险代码分离，使代码结构更清晰。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    answer = <span class="built_in">int</span>(first_number) / <span class="built_in">int</span>(second_number)</span><br><span class="line"><span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;You can&#x27;t divide by zero!&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(answer)</span><br></pre></td></tr></table></figure>

<p><strong>3. 处理</strong><code>FileNotFoundError</code></p>
<ul>
<li><strong>场景</strong>：当尝试读取一个不存在的文件时，会引发<code>FileNotFoundError</code>。</li>
<li><strong>解决方法</strong>：将读取文件的代码放在<code>try</code>块中。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">path = Path(<span class="string">&#x27;alice.txt&#x27;</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    contents = path.read_text(encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="keyword">except</span> FileNotFoundError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Sorry, the file <span class="subst">&#123;path&#125;</span> does not exist.&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># ...成功读取文件后，在这里分析文本...</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>encoding=&#39;utf-8&#39;</code>：当读取的文件编码与系统默认编码不同时（尤其是在不同操作系统间分享文件时），指定编码非常重要，<code>utf-8</code>是一种通用的编码格式。</li>
</ul>
<p><strong>4. 静默失败 (Failing Silently)</strong></p>
<ul>
<li><strong>概念</strong>：有时候，我们不希望在发生错误时通知用户，而是让程序静默地继续运行。</li>
<li><strong>方法</strong>：在<code>except</code>代码块中使用<code>pass</code>语句。<code>pass</code>语句是一个占位符，告诉Python什么也不要做。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">except</span> FileNotFoundError:</span><br><span class="line">    <span class="keyword">pass</span> <span class="comment"># 静默地忽略错误</span></span><br></pre></td></tr></table></figure>

<p><strong>5. 决定报告哪些错误</strong></p>
<ul>
<li><strong>原则</strong>：这是一个设计决策。如果用户需要知道某个文件未被处理，就应该给出提示。如果程序能够正常工作而无需该文件，那么静默失败可能更合适。</li>
</ul>
<hr>
<h4 id="10-4-存储数据-json模块"><a href="#10-4-存储数据-json模块" class="headerlink" title="10.4 存储数据 (json模块)"></a><strong>10.4 存储数据 (</strong><code>json</code><strong>模块)</strong></h4><p>**1. **<code>json</code><strong>模块简介</strong></p>
<ul>
<li><strong>功能</strong>：允许你将Python的复杂数据结构（如列表、字典）转换为<strong>JSON（JavaScript Object Notation）格式</strong>的字符串，以便存储到文件中。之后还可以从文件中读取JSON字符串，并将其恢复为原始的Python数据结构。</li>
<li><strong>优势</strong>：JSON是一种跨语言的通用数据格式，非常适合在不同程序之间共享数据。</li>
</ul>
<p>**2. <strong><code>json.dumps()</code></strong> 和 **<code>json.loads()</code></p>
<ul>
<li><code>json.dumps(data)</code> (dump string)：将Python对象<strong>转换为</strong>JSON格式的字符串。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line">numbers = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>]</span><br><span class="line">contents = json.dumps(numbers) <span class="comment"># contents 是一个字符串 &#x27; [2, 3, 5, 7, 11, 13]&#x27;</span></span><br><span class="line">path.write_text(contents)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>json.loads(json_string)</code> (load string)：将JSON格式的字符串<strong>解析为</strong>Python对象。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">contents = path.read_text()</span><br><span class="line">numbers = json.loads(contents) <span class="comment"># numbers 又变回了列表 [2, 3, 5, 7, 11, 13]</span></span><br></pre></td></tr></table></figure>

<p><strong>3. 保存和读取用户生成的数据</strong></p>
<ul>
<li><strong>应用</strong>：这是一个非常常见的模式，用于记住用户的设置或信息。<ol>
<li>程序启动时，尝试从文件中加载用户信息。</li>
<li>如果文件不存在（<code>FileNotFoundError</code>），则提示用户输入信息，并使用<code>json.dumps()</code>将其保存到文件中。</li>
<li>如果文件存在，则使用<code>json.loads()</code>加载信息，并使用这些信息。</li>
</ol>
</li>
</ul>
<p><strong>4. 重构 (Refactoring)</strong></p>
<ul>
<li><strong>概念</strong>：在不改变代码外部行为的前提下，改进代码的内部结构。</li>
<li><strong>目的</strong>：让代码更清晰、更易于理解和扩展。</li>
<li><strong>方法</strong>：将紧密相关的代码块组织成函数。例如，可以将“获取已存储的用户名”和“获取新用户名”的逻辑分别封装在不同的函数中。</li>
</ul>
<hr>
<h4 id="本章总结-8"><a href="#本章总结-8" class="headerlink" title="本章总结"></a><strong>本章总结</strong></h4><p>第十章极大地扩展了我的程序的能力。通过<strong>文件操作</strong>，我的程序终于可以和外部世界进行数据交换，实现了数据的<strong>持久化</strong>。我学会了使用<code>pathlib.Path</code>来读取和写入文本文件。更重要的是，我掌握了<strong>异常处理</strong>这一关键技能。使用**<code>try-except-else</code>代码块**，我能够编写出更健壮（Robust）的程序，它们在面对预料之外的情况（如文件丢失或无效输入）时，不会轻易崩溃，而是能给出友好的反馈。最后，学习使用<code>json</code>模块，让我能够方便地保存和加载用户的复杂数据，为开发更具实用性的应用程序铺平了道路。</p>
<h3 id="第十一章：测试代码"><a href="#第十一章：测试代码" class="headerlink" title="第十一章：测试代码"></a><strong>第十一章：测试代码</strong></h3><h4 id="核心概要-10"><a href="#核心概要-10" class="headerlink" title="核心概要"></a><strong>核心概要</strong></h4><p>本章的核心主题是<strong>软件测试</strong>。在此之前，我们验证代码是否正确的方式主要是手动运行程序并观察输出。这种方式在程序简单时还行得通，但随着项目变得越来越复杂，手动测试会变得非常繁琐且容易出错。</p>
<p>本章引入了<strong>自动化测试</strong>的概念，即编写一段代码（测试代码）来自动检查另一段代码（被测试代码）的行为是否符合预期。我们将学习使用一个非常流行且强大的第三方测试框架——<code>pytest</code>。</p>
<p>本章的目标是让你掌握：</p>
<ol>
<li><strong>为什么需要测试</strong>，以及测试的基本概念（单元测试、测试用例）。</li>
<li>**如何安装和使用 **<code>pytest</code> 来测试你编写的函数和类。</li>
<li><strong>如何编写一个测试</strong>，包括创建测试文件、测试函数，以及使用**断言（assert）**来验证结果。</li>
<li><strong>如何解读测试结果</strong>，包括测试通过和测试失败时的输出信息。</li>
<li><strong>如何处理测试失败</strong>，以及如何通过添加新测试来确保代码的健壮性。</li>
<li>学习使用**夹具（fixture）**来简化测试代码，避免重复。</li>
</ol>
<hr>
<h4 id="11-1-使用-pip-安装-pytest"><a href="#11-1-使用-pip-安装-pytest" class="headerlink" title="11.1 使用 pip 安装 pytest"></a><strong>11.1 使用 pip 安装 pytest</strong></h4><p><strong>1. 第三方包</strong></p>
<ul>
<li><strong>概念</strong>：除了Python自带的标准库，还有大量由社区开发的、功能强大的库，称为第三方包。<code>pytest</code>就是其中之一。</li>
<li>**安装工具 **<code>pip</code>：<code>pip</code>是Python的包管理器，用于安装和管理第三方包。</li>
</ul>
<p>**2. 更新 **<code>pip</code></p>
<ul>
<li><strong>原因</strong>：<code>pip</code>本身也在不断更新，为了安全和稳定，在使用前最好先将它升级到最新版本。</li>
<li><strong>命令</strong>：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m pip install --upgrade pip</span><br></pre></td></tr></table></figure>

<pre><code>- `python -m pip`：确保我们使用的是当前Python环境关联的`pip`。
</code></pre>
<p>**3. 安装 **<code>pytest</code></p>
<ul>
<li><strong>命令</strong>：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m pip install --user pytest</span><br></pre></td></tr></table></figure>

<pre><code>- `--user`：这个标志告诉`pip`将包安装在用户目录下，而不是系统目录下，这可以避免权限问题，是一种好的实践。
</code></pre>
<hr>
<h4 id="11-2-测试函数"><a href="#11-2-测试函数" class="headerlink" title="11.2 测试函数"></a><strong>11.2 测试函数</strong></h4><p><strong>1. 单元测试与测试用例</strong></p>
<ul>
<li><strong>单元测试 (Unit Test)</strong>：针对程序中最小的可测试单元（通常是一个函数或一个方法）进行的测试。它的目标是验证这个单元的行为是否正确。</li>
<li><strong>测试用例 (Test Case)</strong>：一组相关的单元测试，它们共同验证一个函数或类在各种不同情况下的行为是否都符合预期。</li>
</ul>
<p><strong>2. 一个待测试的函数</strong></p>
<ul>
<li>我们首先需要一个函数来进行测试。书中以一个格式化姓名的函数为例：<ul>
<li><code>name_function.py</code>:</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_formatted_name</span>(<span class="params">first, last</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;生成格式规范的姓名&quot;&quot;&quot;</span></span><br><span class="line">    full_name = <span class="string">f&quot;<span class="subst">&#123;first&#125;</span> <span class="subst">&#123;last&#125;</span>&quot;</span></span><br><span class="line">    <span class="keyword">return</span> full_name.title()</span><br></pre></td></tr></table></figure>

<p><strong>3. 编写一个可通过的测试</strong></p>
<ul>
<li><code>pytest</code>** 的基本规则**：<ol>
<li>测试文件必须以 <code>test_</code> 开头，或者以 <code>_test.py</code> 结尾。通常使用前者，如 <code>test_name_function.py</code>。</li>
<li>测试文件中的测试函数必须以 <code>test_</code> 开头。</li>
</ol>
</li>
<li><strong>断言 (Assertion)</strong>：<ul>
<li><strong>概念</strong>：断言是你对程序行为的一种“声明”或“断定”。<code>assert</code>语句会检查其后的条件是否为<code>True</code>。</li>
<li><strong>行为</strong>：如果条件为<code>True</code>，测试继续进行。如果条件为<code>False</code>，测试<strong>失败</strong>，<code>pytest</code>会报告错误。</li>
</ul>
</li>
<li><strong>编写测试代码</strong>：<ul>
<li><code>test_name_function.py</code>:</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> name_function <span class="keyword">import</span> get_formatted_name</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_first_last_name</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;能够正确地处理像Janis Joplin这样的姓名吗？&quot;&quot;&quot;</span></span><br><span class="line">    formatted_name = get_formatted_name(<span class="string">&#x27;janis&#x27;</span>, <span class="string">&#x27;joplin&#x27;</span>)</span><br><span class="line">    <span class="keyword">assert</span> formatted_name == <span class="string">&#x27;Janis Joplin&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>4. 运行测试</strong></p>
<ul>
<li><strong>方法</strong>：在终端中，切换到包含测试文件的目录，然后简单地运行 <code>pytest</code> 命令。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pytest</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>解读测试通过的输出</strong>：<ul>
<li><code>pytest</code>会自动发现并运行所有符合命名规则的测试文件和测试函数。</li>
<li>输出中会显示收集到了多少个测试项（<code>collected 1 item</code>）。</li>
<li>每个通过的测试都会显示一个**绿色的点 **<code>.</code>。</li>
<li>最后会有一个总结，告诉你多少个测试通过了（<code>1 passed</code>）。</li>
</ul>
</li>
</ul>
<p><strong>5. 编写一个未通过的测试</strong></p>
<ul>
<li><strong>目的</strong>：观察当代码不符合预期时，测试是如何失败的。这有助于我们学习如何根据测试失败的报告来修复代码。</li>
<li><strong>场景</strong>：我们故意修改<code>get_formatted_name</code>函数，使其要求传入中间名，这会导致原来的测试失败。<ul>
<li><code>name_function.py</code> (修改后):</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_formatted_name</span>(<span class="params">first, middle, last</span>):</span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">```*   **运行测试并解读失败的输出**：</span><br></pre></td></tr></table></figure>

<pre><code>- 测试失败会显示一个**红色的 **`F`。
- 会有一个详细的`FAILURES`部分。
- **详细报告**：
    1. 指明哪个测试函数失败了（`test_first_last_name`）。
    2. 显示导致失败的代码行（`formatted_name = get_formatted_name(&#39;janis&#39;, &#39;joplin&#39;)`）。
    3. 给出具体的错误类型和信息（`TypeError: get_formatted_name() missing 1 required positional argument: &#39;last&#39;`），告诉我们函数调用时缺少了参数。
</code></pre>
<p><strong>6. 在测试未通过时怎么办？</strong></p>
<ul>
<li><strong>核心原则</strong>：当测试失败时，<strong>不要修改测试代码</strong>去适应错误的代码。测试是标尺，代码是待测量的物品。尺子是准的，错的是物品。</li>
<li><strong>正确做法</strong>：<strong>修复被测试的代码</strong>，让它的行为重新符合测试的预期。</li>
<li><strong>修复示例</strong>：将<code>get_formatted_name</code>的<code>middle</code>参数设为可选的默认值，使其能同时处理带中间名和不带中间名的两种情况。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_formatted_name</span>(<span class="params">first, last, middle=<span class="string">&#x27;&#x27;</span></span>):</span><br><span class="line">    <span class="comment"># ...</span></span><br></pre></td></tr></table></figure>

<p><strong>7. 添加新测试</strong></p>
<ul>
<li><strong>目的</strong>：在修复代码并确保它能通过旧测试后，我们还需要为新添加的功能（处理中间名）编写新的测试。</li>
<li><strong>方法</strong>：在同一个测试文件中添加一个新的测试函数。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test_first_last_middle_name</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;能够正确处理像Wolfgang Amadeus Mozart这样的姓名吗？&quot;&quot;&quot;</span></span><br><span class="line">    formatted_name = get_formatted_name(<span class="string">&#x27;wolfgang&#x27;</span>, <span class="string">&#x27;mozart&#x27;</span>, <span class="string">&#x27;amadeus&#x27;</span>)</span><br><span class="line">    <span class="keyword">assert</span> formatted_name == <span class="string">&#x27;Wolfgang Amadeus Mozart&#x27;</span></span><br><span class="line">```*   再次运行`pytest`，现在会看到两个测试都通过了（输出中有两个绿色的点 `..`）。</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="11-3-测试类"><a href="#11-3-测试类" class="headerlink" title="11.3 测试类"></a><strong>11.3 测试类</strong></h4><p>测试类的思路与测试函数类似，主要目标是测试类中<strong>方法的行为</strong>。</p>
<p><strong>1. 一个要测试的类</strong></p>
<ul>
<li>书中以一个管理匿名调查的<code>AnonymousSurvey</code>类为例。<ul>
<li><code>survey.py</code>:</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AnonymousSurvey</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, question</span>):</span><br><span class="line">        <span class="variable language_">self</span>.question = question</span><br><span class="line">        <span class="variable language_">self</span>.responses = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">store_response</span>(<span class="params">self, new_response</span>):</span><br><span class="line">        <span class="variable language_">self</span>.responses.append(new_response)</span><br></pre></td></tr></table></figure>

<p><strong>2. 测试</strong><code>AnonymousSurvey</code><strong>类</strong></p>
<ul>
<li><strong>步骤</strong>：<ol>
<li>在测试函数中，创建一个类的<strong>实例</strong>。</li>
<li>调用实例的方法来模拟使用场景。</li>
<li>使用<code>assert</code>来检查实例的属性（如存储答案的列表）是否变成了我们预期的状态。</li>
</ol>
</li>
<li><strong>代码示例</strong>：<ul>
<li><code>test_survey.py</code>:</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> survey <span class="keyword">import</span> AnonymousSurvey</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_store_single_response</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;测试单个答案会被妥善地存储&quot;&quot;&quot;</span></span><br><span class="line">    question = <span class="string">&quot;What language did you first learn to speak?&quot;</span></span><br><span class="line">    language_survey = AnonymousSurvey(question)</span><br><span class="line">    language_survey.store_response(<span class="string">&#x27;English&#x27;</span>)</span><br><span class="line">    <span class="keyword">assert</span> <span class="string">&#x27;English&#x27;</span> <span class="keyword">in</span> language_survey.responses</span><br></pre></td></tr></table></figure>

<p><strong>3. 使用夹具 (Fixtures)</strong></p>
<ul>
<li><strong>问题</strong>：当有多个测试函数时，我们可能会在每个函数中都重复创建同一个类的实例，这会导致代码冗余。</li>
<li><strong>夹具的功能</strong>：夹具是一种特殊的函数，用于<strong>搭建测试环境</strong>。它可以创建一个供多个测试函数使用的资源（如一个类的实例）。</li>
<li><strong>如何创建夹具</strong>：<ol>
<li>导入 <code>pytest</code>。</li>
<li>创建一个函数，并在其上方使用装饰器 <code>@pytest.fixture</code>。</li>
<li>这个函数创建并<code>return</code>一个资源。</li>
</ol>
</li>
<li><strong>如何使用夹具</strong>：<ol>
<li>将夹具函数的<strong>函数名</strong>作为一个<strong>参数</strong>传递给你需要使用该资源的测试函数。</li>
<li><code>pytest</code>会自动运行夹具，并将其返回值传递给测试函数。</li>
</ol>
</li>
<li><strong>代码示例</strong>（使用夹具重构 <code>test_survey.py</code>）：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"><span class="keyword">from</span> survey <span class="keyword">import</span> AnonymousSurvey</span><br><span class="line"></span><br><span class="line"><span class="meta">@pytest.fixture</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">language_survey</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;一个可供所有测试函数使用的AnonymousSurvey实例&quot;&quot;&quot;</span></span><br><span class="line">    question = <span class="string">&quot;What language did you first learn to speak?&quot;</span></span><br><span class="line">    survey = AnonymousSurvey(question)</span><br><span class="line">    <span class="keyword">return</span> survey</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_store_single_response</span>(<span class="params">language_survey</span>): <span class="comment"># 使用夹具</span></span><br><span class="line">    language_survey.store_response(<span class="string">&#x27;English&#x27;</span>)</span><br><span class="line">    <span class="keyword">assert</span> <span class="string">&#x27;English&#x27;</span> <span class="keyword">in</span> language_survey.responses</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_store_three_responses</span>(<span class="params">language_survey</span>): <span class="comment"># 使用同一个夹具</span></span><br><span class="line">    responses = [<span class="string">&#x27;English&#x27;</span>, <span class="string">&#x27;Spanish&#x27;</span>, <span class="string">&#x27;Mandarin&#x27;</span>]</span><br><span class="line">    <span class="keyword">for</span> response <span class="keyword">in</span> responses:</span><br><span class="line">        language_survey.store_response(response)</span><br><span class="line">    <span class="keyword">for</span> response <span class="keyword">in</span> responses:</span><br><span class="line">        <span class="keyword">assert</span> response <span class="keyword">in</span> language_survey.responses</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>优势</strong>：极大地减少了测试代码的重复，让测试更简洁、更易于维护。</li>
</ul>
<hr>
<h4 id="本章总结-9"><a href="#本章总结-9" class="headerlink" title="本章总结"></a><strong>本章总结</strong></h4><p>第十一章让我认识到了<strong>自动化测试</strong>的巨大价值。编写测试虽然会增加一些初期工作量，但它能带来长期的回报：</p>
<ul>
<li><strong>信心</strong>：让我确信我的代码在各种情况下都能正常工作。</li>
<li><strong>安全网</strong>：当我对代码进行修改或添加新功能时，运行测试可以立即发现是否无意中破坏了原有功能。</li>
<li><strong>更好的设计</strong>：为了让代码更容易被测试，我需要思考如何将功能拆分成更小、更独立的单元（函数和方法），这本身就会促使我写出更模块化、更高质量的代码。</li>
</ul>
<p>我掌握了使用<code>pytest</code>编写和运行<strong>单元测试</strong>的基本流程，理解了<strong>断言</strong>的核心作用，并学会了通过<strong>夹具</strong>来高效地组织我的测试用例。现在，我不仅是一个代码的“创造者”，也开始成为自己代码的“质检员”。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://penggehero.github.io/2025/08/16/RAG%E5%AE%9E%E6%88%98%EF%BC%9A%E7%94%A8LangChain%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%9F%A5%E8%AF%86%E5%BA%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="penggewu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="云泽的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/08/16/RAG%E5%AE%9E%E6%88%98%EF%BC%9A%E7%94%A8LangChain%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%9F%A5%E8%AF%86%E5%BA%93/" class="post-title-link" itemprop="url">RAG实战：用LangChain快速搭建个人知识库</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-08-16 16:35:41" itemprop="dateCreated datePublished" datetime="2025-08-16T16:35:41+08:00">2025-08-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-09-08 16:07:21" itemprop="dateModified" datetime="2025-09-08T16:07:21+08:00">2025-09-08</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="RAG实战：用LangChain快速搭建个人知识库"><a href="#RAG实战：用LangChain快速搭建个人知识库" class="headerlink" title="RAG实战：用LangChain快速搭建个人知识库"></a>RAG实战：用LangChain快速搭建个人知识库</h1><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本人在物联网（IoT）相关领域工作一年多，最近一直在看大模型和MQTT相关的知识。相比于枯燥的理论学习，我更信奉**“Learning by Doing”**，所以我想利用时下大火RAG技术搭建一个MQTT协议的个人知识库，下面将详细记录从环境搭建到应用上线的每一步，展示一个完整RAG项目的实现细节。</p>
<h1 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h1><h2 id="RAG-简介"><a href="#RAG-简介" class="headerlink" title="RAG 简介"></a>RAG 简介</h2><p>RAG（Retrieval-Augmented Generation，检索增强生成） 是一种结合信息检索与生成模型的技术。其核心思想是：在生成答案前，先从外部知识库（如文档、数据库、互联网）中检索相关证据，再基于检索结果和用户输入生成更准确、可靠的回答。如下图所示为一个最简RAG示意图。</p>
<p><img src="/2025/08/16/RAG%E5%AE%9E%E6%88%98%EF%BC%9A%E7%94%A8LangChain%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%9F%A5%E8%AF%86%E5%BA%93/640.png" alt="图片"></p>
<p>从形态上说，LLM充当大脑角色用于生成答案，检索充当触手角色用于收集证据。RAG就是一个带触手（外挂知识库）的大模型系统。</p>
<h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><h2 id="先决条件"><a href="#先决条件" class="headerlink" title="先决条件"></a>先决条件</h2><ul>
<li><strong>Python 3.9+</strong>: 确保系统已安装 Python。</li>
<li><strong>Docker</strong>: 这是运行 PostgreSQL + pgvector 最简单、最推荐的方式。</li>
<li><strong>OpenAI API Key</strong>: 前往 <a target="_blank" rel="noopener" href="https://platform.openai.com/api-keys">OpenAI 官网</a> 创建一个 API Key。（推荐白嫖地址：<a target="_blank" rel="noopener" href="https://github.com/chatanywhere/GPT_API_free%EF%BC%89">https://github.com/chatanywhere/GPT_API_free）</a></li>
</ul>
<h2 id="核心依赖项"><a href="#核心依赖项" class="headerlink" title="核心依赖项"></a>核心依赖项</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># --- Core Framework ---</span><br><span class="line">langchain              # RAG 流程的核心编排框架</span><br><span class="line"></span><br><span class="line"># --- LangChain Integrations ---</span><br><span class="line">langchain-postgres     # 用于与 PGVector 数据库交互的最新、推荐库</span><br><span class="line">langchain-openai       # 用于连接 OpenAI 的 LLM 和 Embedding 模型</span><br><span class="line"></span><br><span class="line"># --- Database Driver ---</span><br><span class="line">psycopg                # PostgreSQL 的 Python 数据库驱动程序，供 langchain-postgres 使用</span><br><span class="line"></span><br><span class="line"># --- User Interface ---</span><br><span class="line">gradio                 # 快速构建交互式 Web UI</span><br><span class="line"></span><br><span class="line"># --- Data Handling ---</span><br><span class="line">pypdf                  # 用于加载和解析 PDF 文档</span><br><span class="line">tiktoken               # OpenAI 官方的分词器，用于计算 token 数量</span><br><span class="line"></span><br><span class="line"># --- Configuration ---</span><br><span class="line">python-dotenv          # 用于从 .env 文件加载环境变量</span><br></pre></td></tr></table></figure>

<p>将以下内容保存到项目的 <code>requirements.txt</code> 文件中，以便于一键安装 (<code>pip install -r requirements.txt</code>)。</p>
<h2 id="项目结构："><a href="#项目结构：" class="headerlink" title="项目结构："></a>项目结构：</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mqtt-rag-project/</span><br><span class="line">├── .<span class="built_in">env</span>                              <span class="comment"># 环境变量文件</span></span><br><span class="line">├── app.py                            <span class="comment"># Web应用与问答服务</span></span><br><span class="line">├── hivemq-ebook-mqtt-essentials.pdf  <span class="comment"># MQTT PDF 文档</span></span><br><span class="line">├── ingest.py                         <span class="comment"># 数据入库脚本</span></span><br><span class="line">└── start-pgvector.sh                 <span class="comment"># pgvector的启动脚本</span></span><br></pre></td></tr></table></figure>

<h2 id="pgvector向量数据库-docker安装"><a href="#pgvector向量数据库-docker安装" class="headerlink" title="pgvector向量数据库 docker安装"></a>pgvector向量数据库 docker安装</h2><p>先安装postgresql客户端</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install postgresql</span><br></pre></td></tr></table></figure>

<h3 id="start-pgvector-sh"><a href="#start-pgvector-sh" class="headerlink" title="start-pgvector.sh :"></a>start-pgvector.sh :</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run --name pgvector-db \</span><br><span class="line">  -e POSTGRES_USER=root \</span><br><span class="line">  -e POSTGRES_PASSWORD=root \</span><br><span class="line">  -e POSTGRES_DB=pgvector \</span><br><span class="line">  -p 5432:5432 \</span><br><span class="line">  -d pgvector/pgvector:pg17</span><br></pre></td></tr></table></figure>

<p>验证有没有成功安装</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">psql -h localhost -p 5432 -U root pgvector</span><br></pre></td></tr></table></figure>

<p>输入密码后成功进去就OK。</p>
<h2 id="pgadmin-安装（可选）"><a href="#pgadmin-安装（可选）" class="headerlink" title="pgadmin 安装（可选）"></a>pgadmin 安装（可选）</h2><p>官网：<a target="_blank" rel="noopener" href="https://www.pgadmin.org/download/">https://www.pgadmin.org/download/</a></p>
<p>使用pgadmin可视化的看到数据库中的向量存储展示。</p>
<h1 id="项目细节："><a href="#项目细节：" class="headerlink" title="项目细节："></a>项目细节：</h1><h2 id="整体流程："><a href="#整体流程：" class="headerlink" title="整体流程："></a>整体流程：</h2><p>这是整个项目的完整工作流程图，清晰地展示了数据入库和用户问答两个阶段。</p>
<img src='data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiBjb250ZW50U3R5bGVUeXBlPSJ0ZXh0L2NzcyIgZGF0YS1kaWFncmFtLXR5cGU9IlNFUVVFTkNFIiBoZWlnaHQ9Ijk3MnB4IiBwcmVzZXJ2ZUFzcGVjdFJhdGlvPSJub25lIiBzdHlsZT0id2lkdGg6MTAwM3B4O2hlaWdodDo5NzJweDtiYWNrZ3JvdW5kOiNGRkZGRkY7IiB2ZXJzaW9uPSIxLjEiIHZpZXdCb3g9IjAgMCAxMDAzIDk3MiIgd2lkdGg9IjEwMDNweCIgem9vbUFuZFBhbj0ibWFnbmlmeSI+PHRpdGxlPk1RVFQgUkFHICYjMzA2OTM7JiMzNTc4MjsmIzI0MjExOyAtICYjMjA4NDA7JiMyNzk2OTsmIzMxMjQzOyYjMjIyNzA7PC90aXRsZT48ZGVmcy8+PGc+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGZvbnQtd2VpZ2h0PSJib2xkIiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjIwMS4zNDUzIiB4PSIzOTYuOTIwNiIgeT0iMjcuOTk1MSI+TVFUVCBSQUcgJiMzMDY5MzsmIzM1NzgyOyYjMjQyMTE7IC0gJiMyMDg0MDsmIzI3OTY5OyYjMzEyNDM7JiMyMjI3MDs8L3RleHQ+PHJlY3QgZmlsbD0iI0FERDhFNiIgaGVpZ2h0PSI5MjMuMzEyNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB3aWR0aD0iMzkzLjA1NTMiIHg9IjE2NC40NTU2IiB5PSI0My4yOTY5Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTMiIGZvbnQtd2VpZ2h0PSJib2xkIiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjIxNy4wODk5IiB4PSIyNTIuNDM4MyIgeT0iNTUuMzYzOCI+JiMzMTE2MzsmIzMyNDQ3OyYjMjU5Njg7JiMyNTQ1NDsmIzIyNzg4OyYjMjk3MDI7IChPZmZsaW5lIEluZ2VzdGlvbik8L3RleHQ+PHJlY3QgZmlsbD0iIzkwRUU5MCIgaGVpZ2h0PSI5MjMuMzEyNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB3aWR0aD0iNDM1LjY3NTUiIHg9IjU1OS41MTA5IiB5PSI0My4yOTY5Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTMiIGZvbnQtd2VpZ2h0PSJib2xkIiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjIxMy4yNDk2IiB4PSI2NzAuNzIzOCIgeT0iNTUuMzYzOCI+JiMyMjMxMjsmIzMyNDQ3OyYjMzgzODI7JiMzMTU3MjsmIzI2MzgxOyYjMjExNTM7IChPbmxpbmUgUXVlcnlpbmcpPC90ZXh0PjxnPjx0aXRsZT5pbmdlc3QucHk8L3RpdGxlPjxyZWN0IGZpbGw9IiNGRkZGRkYiIGhlaWdodD0iMjMzLjE5NTMiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MTsiIHdpZHRoPSIxMCIgeD0iMjAyLjc4OTYiIHk9IjE5OC45OTIyIi8+PC9nPjxnPjx0aXRsZT5FbWJlZGRpbmcgTW9kZWw8L3RpdGxlPjxyZWN0IGZpbGw9IiNGRkZGRkYiIGhlaWdodD0iMjkuMTMyOCIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxOyIgd2lkdGg9IjEwIiB4PSIzMjYuMzI1MyIgeT0iMzAwLjUyMzQiLz48L2c+PGc+PHRpdGxlPkVtYmVkZGluZyBNb2RlbDwvdGl0bGU+PHJlY3QgZmlsbD0iI0ZGRkZGRiIgaGVpZ2h0PSIyOS4xMzI4IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjE7IiB3aWR0aD0iMTAiIHg9IjMyNi4zMjUzIiB5PSI1NjIuNzE4OCIvPjwvZz48Zz48dGl0bGU+UEdWZWN0b3IgRGF0YWJhc2U8L3RpdGxlPjxyZWN0IGZpbGw9IiNGRkZGRkYiIGhlaWdodD0iMjkuMTMyOCIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxOyIgd2lkdGg9IjEwIiB4PSI0NzcuMzkwNyIgeT0iMzczLjkyMTkiLz48L2c+PGc+PHRpdGxlPlBHVmVjdG9yIERhdGFiYXNlPC90aXRsZT48cmVjdCBmaWxsPSIjRkZGRkZGIiBoZWlnaHQ9IjQ0LjI2NTYiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MTsiIHdpZHRoPSIxMCIgeD0iNDc3LjM5MDciIHk9IjYzNi4xMTcyIi8+PC9nPjxnPjx0aXRsZT5HcmFkaW8gVUk8L3RpdGxlPjxyZWN0IGZpbGw9IiNGRkZGRkYiIGhlaWdodD0iMjkuMTMyOCIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxOyIgd2lkdGg9IjEwIiB4PSI1OTguMTg2NiIgeT0iNTA0LjQ1MzEiLz48L2c+PGc+PHRpdGxlPkdyYWRpbyBVSTwvdGl0bGU+PHJlY3QgZmlsbD0iI0ZGRkZGRiIgaGVpZ2h0PSI0NC4yNjU2IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjE7IiB3aWR0aD0iMTAiIHg9IjU5OC4xODY2IiB5PSI4MjUuMDQ2OSIvPjwvZz48Zz48dGl0bGU+TGFuZ0NoYWluIFJBRyBDaGFpbjwvdGl0bGU+PHJlY3QgZmlsbD0iI0ZGRkZGRiIgaGVpZ2h0PSIzMzUuNzI2NiIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxOyIgd2lkdGg9IjEwIiB4PSI3NzMuNzIyNCIgeT0iNTMzLjU4NTkiLz48L2c+PGc+PHRpdGxlPkxMTTwvdGl0bGU+PHJlY3QgZmlsbD0iI0ZGRkZGRiIgaGVpZ2h0PSIyOS4xMzI4IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjE7IiB3aWR0aD0iMTAiIHg9Ijk0OC41NDA5IiB5PSI3NjYuNzgxMyIvPjwvZz48Zz48dGl0bGU+RGV2ZWxvcGVyPC90aXRsZT48cmVjdCBmaWxsPSIjMDAwMDAwIiBmaWxsLW9wYWNpdHk9IjAuMDAwMDAiIGhlaWdodD0iNzYyLjU4NTkiIHdpZHRoPSI4IiB4PSI0MC4wMDE1IiB5PSIxMjQuNzI2NiIvPjxsaW5lIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MC41O3N0cm9rZS1kYXNoYXJyYXk6NSw1OyIgeDE9IjQ0IiB4Mj0iNDQiIHkxPSIxMjQuNzI2NiIgeTI9Ijg4Ny4zMTI1Ii8+PC9nPjxnPjx0aXRsZT5Vc2VyPC90aXRsZT48cmVjdCBmaWxsPSIjMDAwMDAwIiBmaWxsLW9wYWNpdHk9IjAuMDAwMDAiIGhlaWdodD0iNzYyLjU4NTkiIHdpZHRoPSI4IiB4PSIxMDcuOTU4IiB5PSIxMjQuNzI2NiIvPjxsaW5lIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MC41O3N0cm9rZS1kYXNoYXJyYXk6NSw1OyIgeDE9IjExMS4wMDI5IiB4Mj0iMTExLjAwMjkiIHkxPSIxMjQuNzI2NiIgeTI9Ijg4Ny4zMTI1Ii8+PC9nPjxnPjx0aXRsZT5pbmdlc3QucHk8L3RpdGxlPjxyZWN0IGZpbGw9IiMwMDAwMDAiIGZpbGwtb3BhY2l0eT0iMC4wMDAwMCIgaGVpZ2h0PSI3NjIuNTg1OSIgd2lkdGg9IjgiIHg9IjIwMy43ODk2IiB5PSIxMjQuNzI2NiIvPjxsaW5lIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MC41O3N0cm9rZS1kYXNoYXJyYXk6NSw1OyIgeDE9IjIwNy40NTU2IiB4Mj0iMjA3LjQ1NTYiIHkxPSIxMjQuNzI2NiIgeTI9Ijg4Ny4zMTI1Ii8+PC9nPjxnPjx0aXRsZT5FbWJlZGRpbmcgTW9kZWw8L3RpdGxlPjxyZWN0IGZpbGw9IiMwMDAwMDAiIGZpbGwtb3BhY2l0eT0iMC4wMDAwMCIgaGVpZ2h0PSI3NjIuNTg1OSIgd2lkdGg9IjgiIHg9IjMyNy4zMjUzIiB5PSIxMjQuNzI2NiIvPjxsaW5lIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MC41O3N0cm9rZS1kYXNoYXJyYXk6NSw1OyIgeDE9IjMzMC4zOCIgeDI9IjMzMC4zOCIgeTE9IjEyNC43MjY2IiB5Mj0iODg3LjMxMjUiLz48L2c+PGc+PHRpdGxlPlBHVmVjdG9yIERhdGFiYXNlPC90aXRsZT48cmVjdCBmaWxsPSIjMDAwMDAwIiBmaWxsLW9wYWNpdHk9IjAuMDAwMDAiIGhlaWdodD0iNzYyLjU4NTkiIHdpZHRoPSI4IiB4PSI0NzguMzkwNyIgeT0iMTI0LjcyNjYiLz48bGluZSBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjAuNTtzdHJva2UtZGFzaGFycmF5OjUsNTsiIHgxPSI0ODIuMjcwNiIgeDI9IjQ4Mi4yNzA2IiB5MT0iMTI0LjcyNjYiIHkyPSI4ODcuMzEyNSIvPjwvZz48Zz48dGl0bGU+R3JhZGlvIFVJPC90aXRsZT48cmVjdCBmaWxsPSIjMDAwMDAwIiBmaWxsLW9wYWNpdHk9IjAuMDAwMDAiIGhlaWdodD0iNzYyLjU4NTkiIHdpZHRoPSI4IiB4PSI1OTkuMTg2NiIgeT0iMTI0LjcyNjYiLz48bGluZSBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjAuNTtzdHJva2UtZGFzaGFycmF5OjUsNTsiIHgxPSI2MDIuNTEwOSIgeDI9IjYwMi41MTA5IiB5MT0iMTI0LjcyNjYiIHkyPSI4ODcuMzEyNSIvPjwvZz48Zz48dGl0bGU+TGFuZ0NoYWluIFJBRyBDaGFpbjwvdGl0bGU+PHJlY3QgZmlsbD0iIzAwMDAwMCIgZmlsbC1vcGFjaXR5PSIwLjAwMDAwIiBoZWlnaHQ9Ijc2Mi41ODU5IiB3aWR0aD0iOCIgeD0iNzc0LjcyMjQiIHk9IjEyNC43MjY2Ii8+PGxpbmUgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7c3Ryb2tlLWRhc2hhcnJheTo1LDU7IiB4MT0iNzc4LjEzNiIgeDI9Ijc3OC4xMzYiIHkxPSIxMjQuNzI2NiIgeTI9Ijg4Ny4zMTI1Ii8+PC9nPjxnPjx0aXRsZT5MTE08L3RpdGxlPjxyZWN0IGZpbGw9IiMwMDAwMDAiIGZpbGwtb3BhY2l0eT0iMC4wMDAwMCIgaGVpZ2h0PSI3NjIuNTg1OSIgd2lkdGg9IjgiIHg9Ijk0OS41NDA5IiB5PSIxMjQuNzI2NiIvPjxsaW5lIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MC41O3N0cm9rZS1kYXNoYXJyYXk6NSw1OyIgeDE9Ijk1Mi44OTU0IiB4Mj0iOTUyLjg5NTQiIHkxPSIxMjQuNzI2NiIgeTI9Ijg4Ny4zMTI1Ii8+PC9nPjxnIGNsYXNzPSJwYXJ0aWNpcGFudCBwYXJ0aWNpcGFudC1oZWFkIiBkYXRhLXBhcnRpY2lwYW50PSJEZXZlbG9wZXIiPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjcyLjAwMjkiIHg9IjUiIHk9IjEyMS40MjQ4Ij5EZXZlbG9wZXI8L3RleHQ+PGVsbGlwc2UgY3g9IjQ0LjAwMTUiIGN5PSI1Ni45Mjk3IiBmaWxsPSIjRTJFMkYwIiByeD0iOCIgcnk9IjgiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MC41OyIvPjxwYXRoIGQ9Ik00NC4wMDE1LDY0LjkyOTcgTDQ0LjAwMTUsOTEuOTI5NyBNMzEuMDAxNSw3Mi45Mjk3IEw1Ny4wMDE1LDcyLjkyOTcgTTQ0LjAwMTUsOTEuOTI5NyBMMzEuMDAxNSwxMDYuOTI5NyBNNDQuMDAxNSw5MS45Mjk3IEw1Ny4wMDE1LDEwNi45Mjk3IiBmaWxsPSJub25lIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjAuNTsiLz48L2c+PGcgY2xhc3M9InBhcnRpY2lwYW50IHBhcnRpY2lwYW50LXRhaWwiIGRhdGEtcGFydGljaXBhbnQ9IkRldmVsb3BlciI+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iNzIuMDAyOSIgeD0iNSIgeT0iODk5LjMwNzYiPkRldmVsb3BlcjwvdGV4dD48ZWxsaXBzZSBjeD0iNDQuMDAxNSIgY3k9IjkxMS4xMDk0IiBmaWxsPSIjRTJFMkYwIiByeD0iOCIgcnk9IjgiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MC41OyIvPjxwYXRoIGQ9Ik00NC4wMDE1LDkxOS4xMDk0IEw0NC4wMDE1LDk0Ni4xMDk0IE0zMS4wMDE1LDkyNy4xMDk0IEw1Ny4wMDE1LDkyNy4xMDk0IE00NC4wMDE1LDk0Ni4xMDk0IEwzMS4wMDE1LDk2MS4xMDk0IE00NC4wMDE1LDk0Ni4xMDk0IEw1Ny4wMDE1LDk2MS4xMDk0IiBmaWxsPSJub25lIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjAuNTsiLz48L2c+PGcgY2xhc3M9InBhcnRpY2lwYW50IHBhcnRpY2lwYW50LWhlYWQiIGRhdGEtcGFydGljaXBhbnQ9IlVzZXIiPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjMxLjkxMDIiIHg9IjkzLjAwMjkiIHk9IjEyMS40MjQ4Ij5Vc2VyPC90ZXh0PjxlbGxpcHNlIGN4PSIxMTEuOTU4IiBjeT0iNTYuOTI5NyIgZmlsbD0iI0UyRTJGMCIgcng9IjgiIHJ5PSI4IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjAuNTsiLz48cGF0aCBkPSJNMTExLjk1OCw2NC45Mjk3IEwxMTEuOTU4LDkxLjkyOTcgTTk4Ljk1OCw3Mi45Mjk3IEwxMjQuOTU4LDcyLjkyOTcgTTExMS45NTgsOTEuOTI5NyBMOTguOTU4LDEwNi45Mjk3IE0xMTEuOTU4LDkxLjkyOTcgTDEyNC45NTgsMTA2LjkyOTciIGZpbGw9Im5vbmUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MC41OyIvPjwvZz48ZyBjbGFzcz0icGFydGljaXBhbnQgcGFydGljaXBhbnQtdGFpbCIgZGF0YS1wYXJ0aWNpcGFudD0iVXNlciI+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMzEuOTEwMiIgeD0iOTMuMDAyOSIgeT0iODk5LjMwNzYiPlVzZXI8L3RleHQ+PGVsbGlwc2UgY3g9IjExMS45NTgiIGN5PSI5MTEuMTA5NCIgZmlsbD0iI0UyRTJGMCIgcng9IjgiIHJ5PSI4IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjAuNTsiLz48cGF0aCBkPSJNMTExLjk1OCw5MTkuMTA5NCBMMTExLjk1OCw5NDYuMTA5NCBNOTguOTU4LDkyNy4xMDk0IEwxMjQuOTU4LDkyNy4xMDk0IE0xMTEuOTU4LDk0Ni4xMDk0IEw5OC45NTgsOTYxLjEwOTQgTTExMS45NTgsOTQ2LjEwOTQgTDEyNC45NTgsOTYxLjEwOTQiIGZpbGw9Im5vbmUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MC41OyIvPjwvZz48ZyBjbGFzcz0icGFydGljaXBhbnQgcGFydGljaXBhbnQtaGVhZCIgZGF0YS1wYXJ0aWNpcGFudD0iSW5nZXN0Ij48cmVjdCBmaWxsPSIjRTJFMkYwIiBoZWlnaHQ9IjMwLjI5NjkiIHJ4PSIyLjUiIHJ5PSIyLjUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MC41OyIgd2lkdGg9Ijc4LjY2OCIgeD0iMTY4LjQ1NTYiIHk9IjkzLjQyOTciLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSI2NC42NjgiIHg9IjE3NS40NTU2IiB5PSIxMTMuNDI0OCI+aW5nZXN0LnB5PC90ZXh0PjwvZz48ZyBjbGFzcz0icGFydGljaXBhbnQgcGFydGljaXBhbnQtdGFpbCIgZGF0YS1wYXJ0aWNpcGFudD0iSW5nZXN0Ij48cmVjdCBmaWxsPSIjRTJFMkYwIiBoZWlnaHQ9IjMwLjI5NjkiIHJ4PSIyLjUiIHJ5PSIyLjUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MC41OyIgd2lkdGg9Ijc4LjY2OCIgeD0iMTY4LjQ1NTYiIHk9Ijg4Ni4zMTI1Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iNjQuNjY4IiB4PSIxNzUuNDU1NiIgeT0iOTA2LjMwNzYiPmluZ2VzdC5weTwvdGV4dD48L2c+PGcgY2xhc3M9InBhcnRpY2lwYW50IHBhcnRpY2lwYW50LWhlYWQiIGRhdGEtcGFydGljaXBhbnQ9IkVtYmVkIj48cmVjdCBmaWxsPSIjRTJFMkYwIiBoZWlnaHQ9IjQ2LjU5MzgiIHJ4PSIyLjUiIHJ5PSIyLjUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MC41OyIgd2lkdGg9IjEzOS44OTA2IiB4PSIyNjEuMzgiIHk9Ijc3LjEzMjgiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSIxMjUuODkwNiIgeD0iMjY4LjM4IiB5PSI5Ny4xMjc5Ij5FbWJlZGRpbmcgTW9kZWw8L3RleHQ+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iNjIuMDIyNSIgeD0iMzAwLjMxNDEiIHk9IjExMy40MjQ4Ij4oT3BlbkFJKTwvdGV4dD48L2c+PGcgY2xhc3M9InBhcnRpY2lwYW50IHBhcnRpY2lwYW50LXRhaWwiIGRhdGEtcGFydGljaXBhbnQ9IkVtYmVkIj48cmVjdCBmaWxsPSIjRTJFMkYwIiBoZWlnaHQ9IjQ2LjU5MzgiIHJ4PSIyLjUiIHJ5PSIyLjUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MC41OyIgd2lkdGg9IjEzOS44OTA2IiB4PSIyNjEuMzgiIHk9Ijg4Ni4zMTI1Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMTI1Ljg5MDYiIHg9IjI2OC4zOCIgeT0iOTA2LjMwNzYiPkVtYmVkZGluZyBNb2RlbDwvdGV4dD48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSI2Mi4wMjI1IiB4PSIzMDAuMzE0MSIgeT0iOTIyLjYwNDUiPihPcGVuQUkpPC90ZXh0PjwvZz48ZyBjbGFzcz0icGFydGljaXBhbnQgcGFydGljaXBhbnQtaGVhZCIgZGF0YS1wYXJ0aWNpcGFudD0iREIiPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjEzNi4yNDAyIiB4PSI0MTEuMjcwNiIgeT0iMTIxLjQyNDgiPlBHVmVjdG9yIERhdGFiYXNlPC90ZXh0PjxwYXRoIGQ9Ik00NjQuMzkwNyw3Mi40Mjk3IEM0NjQuMzkwNyw2Mi40Mjk3IDQ4Mi4zOTA3LDYyLjQyOTcgNDgyLjM5MDcsNjIuNDI5NyBDNDgyLjM5MDcsNjIuNDI5NyA1MDAuMzkwNyw2Mi40Mjk3IDUwMC4zOTA3LDcyLjQyOTcgTDUwMC4zOTA3LDk4LjQyOTcgQzUwMC4zOTA3LDEwOC40Mjk3IDQ4Mi4zOTA3LDEwOC40Mjk3IDQ4Mi4zOTA3LDEwOC40Mjk3IEM0ODIuMzkwNywxMDguNDI5NyA0NjQuMzkwNywxMDguNDI5NyA0NjQuMzkwNyw5OC40Mjk3IEw0NjQuMzkwNyw3Mi40Mjk3IiBmaWxsPSIjRTJFMkYwIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjAuNTsiLz48cGF0aCBkPSJNNDY0LjM5MDcsNzIuNDI5NyBDNDY0LjM5MDcsODIuNDI5NyA0ODIuMzkwNyw4Mi40Mjk3IDQ4Mi4zOTA3LDgyLjQyOTcgQzQ4Mi4zOTA3LDgyLjQyOTcgNTAwLjM5MDcsODIuNDI5NyA1MDAuMzkwNyw3Mi40Mjk3IiBmaWxsPSJub25lIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjAuNTsiLz48L2c+PGcgY2xhc3M9InBhcnRpY2lwYW50IHBhcnRpY2lwYW50LXRhaWwiIGRhdGEtcGFydGljaXBhbnQ9IkRCIj48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSIxMzYuMjQwMiIgeD0iNDExLjI3MDYiIHk9Ijg5OS4zMDc2Ij5QR1ZlY3RvciBEYXRhYmFzZTwvdGV4dD48cGF0aCBkPSJNNDY0LjM5MDcsOTEyLjYwOTQgQzQ2NC4zOTA3LDkwMi42MDk0IDQ4Mi4zOTA3LDkwMi42MDk0IDQ4Mi4zOTA3LDkwMi42MDk0IEM0ODIuMzkwNyw5MDIuNjA5NCA1MDAuMzkwNyw5MDIuNjA5NCA1MDAuMzkwNyw5MTIuNjA5NCBMNTAwLjM5MDcsOTM4LjYwOTQgQzUwMC4zOTA3LDk0OC42MDk0IDQ4Mi4zOTA3LDk0OC42MDk0IDQ4Mi4zOTA3LDk0OC42MDk0IEM0ODIuMzkwNyw5NDguNjA5NCA0NjQuMzkwNyw5NDguNjA5NCA0NjQuMzkwNyw5MzguNjA5NCBMNDY0LjM5MDcsOTEyLjYwOTQiIGZpbGw9IiNFMkUyRjAiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MC41OyIvPjxwYXRoIGQ9Ik00NjQuMzkwNyw5MTIuNjA5NCBDNDY0LjM5MDcsOTIyLjYwOTQgNDgyLjM5MDcsOTIyLjYwOTQgNDgyLjM5MDcsOTIyLjYwOTQgQzQ4Mi4zOTA3LDkyMi42MDk0IDUwMC4zOTA3LDkyMi42MDk0IDUwMC4zOTA3LDkxMi42MDk0IiBmaWxsPSJub25lIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjAuNTsiLz48L2c+PGcgY2xhc3M9InBhcnRpY2lwYW50IHBhcnRpY2lwYW50LWhlYWQiIGRhdGEtcGFydGljaXBhbnQ9IlVJIj48cmVjdCBmaWxsPSIjRTJFMkYwIiBoZWlnaHQ9IjMwLjI5NjkiIHJ4PSIyLjUiIHJ5PSIyLjUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MC41OyIgd2lkdGg9Ijc5LjM1MTYiIHg9IjU2My41MTA5IiB5PSI5My40Mjk3Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iNjUuMzUxNiIgeD0iNTcwLjUxMDkiIHk9IjExMy40MjQ4Ij5HcmFkaW8gVUk8L3RleHQ+PC9nPjxnIGNsYXNzPSJwYXJ0aWNpcGFudCBwYXJ0aWNpcGFudC10YWlsIiBkYXRhLXBhcnRpY2lwYW50PSJVSSI+PHJlY3QgZmlsbD0iI0UyRTJGMCIgaGVpZ2h0PSIzMC4yOTY5IiByeD0iMi41IiByeT0iMi41IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjAuNTsiIHdpZHRoPSI3OS4zNTE2IiB4PSI1NjMuNTEwOSIgeT0iODg2LjMxMjUiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSI2NS4zNTE2IiB4PSI1NzAuNTEwOSIgeT0iOTA2LjMwNzYiPkdyYWRpbyBVSTwvdGV4dD48L2c+PGcgY2xhc3M9InBhcnRpY2lwYW50IHBhcnRpY2lwYW50LWhlYWQiIGRhdGEtcGFydGljaXBhbnQ9IlJBRyI+PHJlY3QgZmlsbD0iI0UyRTJGMCIgaGVpZ2h0PSI0Ni41OTM4IiByeD0iMi41IiByeT0iMi41IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjAuNTsiIHdpZHRoPSIxNjcuMTcyOSIgeD0iNjk1LjEzNiIgeT0iNzcuMTMyOCIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjE1My4xNzI5IiB4PSI3MDIuMTM2IiB5PSI5Ny4xMjc5Ij5MYW5nQ2hhaW4gUkFHIENoYWluPC90ZXh0Pjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjU4Ljg5ODQiIHg9Ijc0OS4yNzMyIiB5PSIxMTMuNDI0OCI+KGFwcC5weSk8L3RleHQ+PC9nPjxnIGNsYXNzPSJwYXJ0aWNpcGFudCBwYXJ0aWNpcGFudC10YWlsIiBkYXRhLXBhcnRpY2lwYW50PSJSQUciPjxyZWN0IGZpbGw9IiNFMkUyRjAiIGhlaWdodD0iNDYuNTkzOCIgcng9IjIuNSIgcnk9IjIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB3aWR0aD0iMTY3LjE3MjkiIHg9IjY5NS4xMzYiIHk9Ijg4Ni4zMTI1Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMTUzLjE3MjkiIHg9IjcwMi4xMzYiIHk9IjkwNi4zMDc2Ij5MYW5nQ2hhaW4gUkFHIENoYWluPC90ZXh0Pjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjU4Ljg5ODQiIHg9Ijc0OS4yNzMyIiB5PSI5MjIuNjA0NSI+KGFwcC5weSk8L3RleHQ+PC9nPjxnIGNsYXNzPSJwYXJ0aWNpcGFudCBwYXJ0aWNpcGFudC1oZWFkIiBkYXRhLXBhcnRpY2lwYW50PSJMTE0iPjxyZWN0IGZpbGw9IiNFMkUyRjAiIGhlaWdodD0iNDYuNTkzOCIgcng9IjIuNSIgcnk9IjIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDowLjU7IiB3aWR0aD0iNzUuMjkxIiB4PSI5MTUuODk1NCIgeT0iNzcuMTMyOCIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjI3LjY3ODciIHg9IjkzOS43MDE1IiB5PSI5Ny4xMjc5Ij5MTE08L3RleHQ+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iNjEuMjkxIiB4PSI5MjIuODk1NCIgeT0iMTEzLjQyNDgiPihHUFQtNG8pPC90ZXh0PjwvZz48ZyBjbGFzcz0icGFydGljaXBhbnQgcGFydGljaXBhbnQtdGFpbCIgZGF0YS1wYXJ0aWNpcGFudD0iTExNIj48cmVjdCBmaWxsPSIjRTJFMkYwIiBoZWlnaHQ9IjQ2LjU5MzgiIHJ4PSIyLjUiIHJ5PSIyLjUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MC41OyIgd2lkdGg9Ijc1LjI5MSIgeD0iOTE1Ljg5NTQiIHk9Ijg4Ni4zMTI1Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMjcuNjc4NyIgeD0iOTM5LjcwMTUiIHk9IjkwNi4zMDc2Ij5MTE08L3RleHQ+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iNjEuMjkxIiB4PSI5MjIuODk1NCIgeT0iOTIyLjYwNDUiPihHUFQtNG8pPC90ZXh0PjwvZz48Zz48dGl0bGU+aW5nZXN0LnB5PC90aXRsZT48cmVjdCBmaWxsPSIjRkZGRkZGIiBoZWlnaHQ9IjIzMy4xOTUzIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjE7IiB3aWR0aD0iMTAiIHg9IjIwMi43ODk2IiB5PSIxOTguOTkyMiIvPjwvZz48Zz48dGl0bGU+RW1iZWRkaW5nIE1vZGVsPC90aXRsZT48cmVjdCBmaWxsPSIjRkZGRkZGIiBoZWlnaHQ9IjI5LjEzMjgiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MTsiIHdpZHRoPSIxMCIgeD0iMzI2LjMyNTMiIHk9IjMwMC41MjM0Ii8+PC9nPjxnPjx0aXRsZT5FbWJlZGRpbmcgTW9kZWw8L3RpdGxlPjxyZWN0IGZpbGw9IiNGRkZGRkYiIGhlaWdodD0iMjkuMTMyOCIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxOyIgd2lkdGg9IjEwIiB4PSIzMjYuMzI1MyIgeT0iNTYyLjcxODgiLz48L2c+PGc+PHRpdGxlPlBHVmVjdG9yIERhdGFiYXNlPC90aXRsZT48cmVjdCBmaWxsPSIjRkZGRkZGIiBoZWlnaHQ9IjI5LjEzMjgiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MTsiIHdpZHRoPSIxMCIgeD0iNDc3LjM5MDciIHk9IjM3My45MjE5Ii8+PC9nPjxnPjx0aXRsZT5QR1ZlY3RvciBEYXRhYmFzZTwvdGl0bGU+PHJlY3QgZmlsbD0iI0ZGRkZGRiIgaGVpZ2h0PSI0NC4yNjU2IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjE7IiB3aWR0aD0iMTAiIHg9IjQ3Ny4zOTA3IiB5PSI2MzYuMTE3MiIvPjwvZz48Zz48dGl0bGU+R3JhZGlvIFVJPC90aXRsZT48cmVjdCBmaWxsPSIjRkZGRkZGIiBoZWlnaHQ9IjI5LjEzMjgiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MTsiIHdpZHRoPSIxMCIgeD0iNTk4LjE4NjYiIHk9IjUwNC40NTMxIi8+PC9nPjxnPjx0aXRsZT5HcmFkaW8gVUk8L3RpdGxlPjxyZWN0IGZpbGw9IiNGRkZGRkYiIGhlaWdodD0iNDQuMjY1NiIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxOyIgd2lkdGg9IjEwIiB4PSI1OTguMTg2NiIgeT0iODI1LjA0NjkiLz48L2c+PGc+PHRpdGxlPkxhbmdDaGFpbiBSQUcgQ2hhaW48L3RpdGxlPjxyZWN0IGZpbGw9IiNGRkZGRkYiIGhlaWdodD0iMzM1LjcyNjYiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MTsiIHdpZHRoPSIxMCIgeD0iNzczLjcyMjQiIHk9IjUzMy41ODU5Ii8+PC9nPjxnPjx0aXRsZT5MTE08L3RpdGxlPjxyZWN0IGZpbGw9IiNGRkZGRkYiIGhlaWdodD0iMjkuMTMyOCIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxOyIgd2lkdGg9IjEwIiB4PSI5NDguNTQwOSIgeT0iNzY2Ljc4MTMiLz48L2c+PHJlY3QgZmlsbD0iI0VFRUVFRSIgaGVpZ2h0PSIzIiBzdHlsZT0ic3Ryb2tlOiNFRUVFRUU7c3Ryb2tlLXdpZHRoOjE7IiB3aWR0aD0iOTk2LjE4NjQiIHg9IjAiIHk9IjE1NS4yOTMiLz48bGluZSBzdHlsZT0ic3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjE7IiB4MT0iMCIgeDI9Ijk5Ni4xODY0IiB5MT0iMTU1LjI5MyIgeTI9IjE1NS4yOTMiLz48bGluZSBzdHlsZT0ic3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjE7IiB4MT0iMCIgeDI9Ijk5Ni4xODY0IiB5MT0iMTU4LjI5MyIgeTI9IjE1OC4yOTMiLz48cmVjdCBmaWxsPSIjRUVFRUVFIiBoZWlnaHQ9IjIzLjEzMjgiIHN0eWxlPSJzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MjsiIHdpZHRoPSIyNjYuNjQzMiIgeD0iMzY0Ljc3MTYiIHk9IjE0NC43MjY2Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTMiIGZvbnQtd2VpZ2h0PSJib2xkIiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjI0OC4xMTczIiB4PSIzNzAuNzcxNiIgeT0iMTYwLjc5MzUiPiYjMTI4MjE0OyAxLiAmIzI1OTY4OyYjMjU0NTQ7JiMyMDgzNzsmIzI0MjExOyYjMzg0NTQ7JiMyNzU3MzsgKCYjMzAwMDE7IERldmVsb3BlciAmIzI1MTkxOyYjMzQ4OTI7KTwvdGV4dD48ZyBjbGFzcz0ibWVzc2FnZSIgZGF0YS1wYXJ0aWNpcGFudC0xPSJEZXZlbG9wZXIiIGRhdGEtcGFydGljaXBhbnQtMj0iSW5nZXN0Ij48cG9seWdvbiBmaWxsPSIjMTgxODE4IiBwb2ludHM9IjE5MC43ODk2LDE5NC45OTIyLDIwMC43ODk2LDE5OC45OTIyLDE5MC43ODk2LDIwMi45OTIyLDE5NC43ODk2LDE5OC45OTIyIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjE7Ii8+PGxpbmUgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxOyIgeDE9IjQ0LjAwMTUiIHgyPSIxOTYuNzg5NiIgeTE9IjE5OC45OTIyIiB5Mj0iMTk4Ljk5MjIiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxMyIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSIxMzkuNzg4MSIgeD0iNTEuMDAxNSIgeT0iMTkzLjkyNjMiPiYjMzY4MTY7JiMzNDg5MjsgcHl0aG9uIGluZ2VzdC5weTwvdGV4dD48L2c+PGcgY2xhc3M9Im1lc3NhZ2UiIGRhdGEtcGFydGljaXBhbnQtMT0iSW5nZXN0IiBkYXRhLXBhcnRpY2lwYW50LTI9IkluZ2VzdCI+PGxpbmUgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxOyIgeDE9IjIxMi43ODk2IiB4Mj0iMjU0Ljc4OTYiIHkxPSIyNDMuMjU3OCIgeTI9IjI0My4yNTc4Ii8+PGxpbmUgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxOyIgeDE9IjI1NC43ODk2IiB4Mj0iMjU0Ljc4OTYiIHkxPSIyNDMuMjU3OCIgeTI9IjI1Ni4yNTc4Ii8+PGxpbmUgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxOyIgeDE9IjIxMy43ODk2IiB4Mj0iMjU0Ljc4OTYiIHkxPSIyNTYuMjU3OCIgeTI9IjI1Ni4yNTc4Ii8+PHBvbHlnb24gZmlsbD0iIzE4MTgxOCIgcG9pbnRzPSIyMjMuNzg5NiwyNTIuMjU3OCwyMTMuNzg5NiwyNTYuMjU3OCwyMjMuNzg5NiwyNjAuMjU3OCwyMTkuNzg5NiwyNTYuMjU3OCIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxOyIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjEzIiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjgxLjUzNTciIHg9IjIxOS43ODk2IiB5PSIyMjMuMDU5MSI+MS4gJiMyMTE1MjsmIzM2NzMzOyYjMjQxODI7JiMyMDk5ODsmIzIxMTA2OzwvdGV4dD48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxMyIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSI2OC4yODE3IiB4PSIyMTkuNzg5NiIgeT0iMjM4LjE5MTkiPiJtcXR0LnBkZiI8L3RleHQ+PC9nPjxnIGNsYXNzPSJtZXNzYWdlIiBkYXRhLXBhcnRpY2lwYW50LTE9IkluZ2VzdCIgZGF0YS1wYXJ0aWNpcGFudC0yPSJFbWJlZCI+PHBvbHlnb24gZmlsbD0iIzE4MTgxOCIgcG9pbnRzPSIzMTQuMzI1MywyOTYuNTIzNCwzMjQuMzI1MywzMDAuNTIzNCwzMTQuMzI1MywzMDQuNTIzNCwzMTguMzI1MywzMDAuNTIzNCIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxOyIvPjxsaW5lIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MTsiIHgxPSIyMTIuNzg5NiIgeDI9IjMyMC4zMjUzIiB5MT0iMzAwLjUyMzQiIHkyPSIzMDAuNTIzNCIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjEzIiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9Ijk0LjUzNTciIHg9IjIxOS43ODk2IiB5PSIyODAuMzI0NyI+Mi4gJiMyMzU0NTsmIzI3NTk5OyYjMjAwMTA7JiMyNTk5MTsmIzI2NDEyOyYjMjIzNTk7PC90ZXh0Pjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjEzIiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjY1LjAwMDEiIHg9IjIxOS43ODk2IiB5PSIyOTUuNDU3NSI+JiMzNTgzMTsmIzI3NzE0OyYjMjE1MjE7JiMzNzMyNzsmIzIxMjcwOzwvdGV4dD48L2c+PGcgY2xhc3M9Im1lc3NhZ2UiIGRhdGEtcGFydGljaXBhbnQtMT0iRW1iZWQiIGRhdGEtcGFydGljaXBhbnQtMj0iSW5nZXN0Ij48cG9seWdvbiBmaWxsPSIjMTgxODE4IiBwb2ludHM9IjIyMy43ODk2LDMyNS42NTYzLDIxMy43ODk2LDMyOS42NTYzLDIyMy43ODk2LDMzMy42NTYzLDIxOS43ODk2LDMyOS42NTYzIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjE7Ii8+PGxpbmUgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxO3N0cm9rZS1kYXNoYXJyYXk6MiwyOyIgeDE9IjIxNy43ODk2IiB4Mj0iMzMwLjMyNTMiIHkxPSIzMjkuNjU2MyIgeTI9IjMyOS42NTYzIi8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTMiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iNzguMDAwMSIgeD0iMjI5Ljc4OTYiIHk9IjMyNC41OTAzIj4mIzM2ODIwOyYjMjIyMzg7JiMyNTk5MTsmIzI2NDEyOyYjMjE1MjE7JiMzNzMyNzs8L3RleHQ+PC9nPjxnIGNsYXNzPSJtZXNzYWdlIiBkYXRhLXBhcnRpY2lwYW50LTE9IkluZ2VzdCIgZGF0YS1wYXJ0aWNpcGFudC0yPSJEQiI+PHBvbHlnb24gZmlsbD0iIzE4MTgxOCIgcG9pbnRzPSI0NjUuMzkwNywzNjkuOTIxOSw0NzUuMzkwNywzNzMuOTIxOSw0NjUuMzkwNywzNzcuOTIxOSw0NjkuMzkwNywzNzMuOTIxOSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxOyIvPjxsaW5lIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MTsiIHgxPSIyMTIuNzg5NiIgeDI9IjQ3MS4zOTA3IiB5MT0iMzczLjkyMTkiIHkyPSIzNzMuOTIxOSIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjEzIiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjEwNC42NzkzIiB4PSIyMTkuNzg5NiIgeT0iMzUzLjcyMzEiPjMuICgmIzI4MTY1OyYjMzEzNTQ7JiMyNjA4NzsmIzI1OTY4OyYjMjU0NTQ7JiMyMTUxODspPC90ZXh0Pjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjEzIiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjEwNC4wMDAxIiB4PSIyMTkuNzg5NiIgeT0iMzY4Ljg1NiI+JiMyMzM4NDsmIzIwNjQ4OyYjMjU5OTE7JiMyNjQxMjsmIzIyMzU5OyYjMjE2NDQ7JiMyMTUyMTsmIzM3MzI3OzwvdGV4dD48L2c+PGcgY2xhc3M9Im1lc3NhZ2UiIGRhdGEtcGFydGljaXBhbnQtMT0iREIiIGRhdGEtcGFydGljaXBhbnQtMj0iSW5nZXN0Ij48cG9seWdvbiBmaWxsPSIjMTgxODE4IiBwb2ludHM9IjIyMy43ODk2LDM5OS4wNTQ3LDIxMy43ODk2LDQwMy4wNTQ3LDIyMy43ODk2LDQwNy4wNTQ3LDIxOS43ODk2LDQwMy4wNTQ3IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjE7Ii8+PGxpbmUgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxO3N0cm9rZS1kYXNoYXJyYXk6MiwyOyIgeDE9IjIxNy43ODk2IiB4Mj0iNDgxLjM5MDciIHkxPSI0MDMuMDU0NyIgeTI9IjQwMy4wNTQ3Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTMiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iNTIuMDAwMSIgeD0iMjI5Ljc4OTYiIHk9IjM5Ny45ODg4Ij4mIzIzMzg0OyYjMjA2NDg7JiMyNTEwNDsmIzIxMTUxOzwvdGV4dD48L2c+PGcgY2xhc3M9Im1lc3NhZ2UiIGRhdGEtcGFydGljaXBhbnQtMT0iSW5nZXN0IiBkYXRhLXBhcnRpY2lwYW50LTI9IkRldmVsb3BlciI+PHBvbHlnb24gZmlsbD0iIzE4MTgxOCIgcG9pbnRzPSI1NS4wMDE1LDQyOC4xODc1LDQ1LjAwMTUsNDMyLjE4NzUsNTUuMDAxNSw0MzYuMTg3NSw1MS4wMDE1LDQzMi4xODc1IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjE7Ii8+PGxpbmUgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxO3N0cm9rZS1kYXNoYXJyYXk6MiwyOyIgeDE9IjQ5LjAwMTUiIHgyPSIyMDYuNzg5NiIgeTE9IjQzMi4xODc1IiB5Mj0iNDMyLjE4NzUiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxMyIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSIxMjQuMjIzOCIgeD0iNjEuMDAxNSIgeT0iNDI3LjEyMTYiPiYjMjUxNzE7JiMyMTM2MDsgIiYjMjA4Mzc7JiMyNDIxMTsmIzIzNDM2OyYjMjUxMDQ7IiAmIzI2MDg1OyYjMjQ1MzU7PC90ZXh0PjwvZz48cmVjdCBmaWxsPSIjRUVFRUVFIiBoZWlnaHQ9IjMiIHN0eWxlPSJzdHJva2U6I0VFRUVFRTtzdHJva2Utd2lkdGg6MTsiIHdpZHRoPSI5OTYuMTg2NCIgeD0iMCIgeT0iNDYwLjc1MzkiLz48bGluZSBzdHlsZT0ic3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjE7IiB4MT0iMCIgeDI9Ijk5Ni4xODY0IiB5MT0iNDYwLjc1MzkiIHkyPSI0NjAuNzUzOSIvPjxsaW5lIHN0eWxlPSJzdHJva2U6IzAwMDAwMDtzdHJva2Utd2lkdGg6MTsiIHgxPSIwIiB4Mj0iOTk2LjE4NjQiIHkxPSI0NjMuNzUzOSIgeTI9IjQ2My43NTM5Ii8+PHJlY3QgZmlsbD0iI0VFRUVFRSIgaGVpZ2h0PSIyMy4xMzI4IiBzdHlsZT0ic3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjI7IiB3aWR0aD0iMjI1LjM0NTQiIHg9IjM4NS40MjA1IiB5PSI0NTAuMTg3NSIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjEzIiBmb250LXdlaWdodD0iYm9sZCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSIyMDYuODE5NSIgeD0iMzkxLjQyMDUiIHk9IjQ2Ni4yNTQ0Ij4mIzEyODE3MjsgMi4gJiMyOTk5MjsmIzI1MTQzOyYjMzgzODI7JiMzMTU3MjsmIzM4NDU0OyYjMjc1NzM7ICgmIzMwMDAxOyBVc2VyICYjMjAzNTE7JiMyOTk5MjspPC90ZXh0PjxnIGNsYXNzPSJtZXNzYWdlIiBkYXRhLXBhcnRpY2lwYW50LTE9IlVzZXIiIGRhdGEtcGFydGljaXBhbnQtMj0iVUkiPjxwb2x5Z29uIGZpbGw9IiMxODE4MTgiIHBvaW50cz0iNTg2LjE4NjYsNTAwLjQ1MzEsNTk2LjE4NjYsNTA0LjQ1MzEsNTg2LjE4NjYsNTA4LjQ1MzEsNTkwLjE4NjYsNTA0LjQ1MzEiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MTsiLz48bGluZSBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjE7IiB4MT0iMTExLjk1OCIgeDI9IjU5Mi4xODY2IiB5MT0iNTA0LjQ1MzEiIHkyPSI1MDQuNDUzMSIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjEzIiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjEyMC41MzU4IiB4PSIxMTguOTU4IiB5PSI0OTkuMzg3MiI+MS4gJiMyMjMxMjsmIzMyODQyOyYjMjI4MjU7JiMyNjY5NDsmIzM2NzU1OyYjMjA4Mzc7JiMzODM4MjsmIzM5MDY0OzwvdGV4dD48L2c+PGcgY2xhc3M9Im1lc3NhZ2UiIGRhdGEtcGFydGljaXBhbnQtMT0iVUkiIGRhdGEtcGFydGljaXBhbnQtMj0iUkFHIj48cG9seWdvbiBmaWxsPSIjMTgxODE4IiBwb2ludHM9Ijc2MS43MjI0LDUyOS41ODU5LDc3MS43MjI0LDUzMy41ODU5LDc2MS43MjI0LDUzNy41ODU5LDc2NS43MjI0LDUzMy41ODU5IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjE7Ii8+PGxpbmUgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxOyIgeDE9IjYwMy4xODY2IiB4Mj0iNzY3LjcyMjQiIHkxPSI1MzMuNTg1OSIgeTI9IjUzMy41ODU5Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTMiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iNjguNTM1NyIgeD0iNjEwLjE4NjYiIHk9IjUyOC41MiI+Mi4gJiMyMTQ1NzsmIzM2ODY1OyYjMzgzODI7JiMzOTA2NDs8L3RleHQ+PC9nPjxnIGNsYXNzPSJtZXNzYWdlIiBkYXRhLXBhcnRpY2lwYW50LTE9IlJBRyIgZGF0YS1wYXJ0aWNpcGFudC0yPSJFbWJlZCI+PHBvbHlnb24gZmlsbD0iIzE4MTgxOCIgcG9pbnRzPSIzNDcuMzI1Myw1NTguNzE4OCwzMzcuMzI1Myw1NjIuNzE4OCwzNDcuMzI1Myw1NjYuNzE4OCwzNDMuMzI1Myw1NjIuNzE4OCIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxOyIvPjxsaW5lIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MTsiIHgxPSIzNDEuMzI1MyIgeDI9Ijc3Mi43MjI0IiB5MT0iNTYyLjcxODgiIHkyPSI1NjIuNzE4OCIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjEzIiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjEyMC41MzU4IiB4PSIzNTMuMzI1MyIgeT0iNTU3LjY1MjgiPjMuICYjMjM1NTg7JiMyOTk5MjsmIzI1MTQzOyYjMzgzODI7JiMzOTA2NDsmIzIxNTIxOyYjMzczMjc7JiMyMTI3MDs8L3RleHQ+PC9nPjxnIGNsYXNzPSJtZXNzYWdlIiBkYXRhLXBhcnRpY2lwYW50LTE9IkVtYmVkIiBkYXRhLXBhcnRpY2lwYW50LTI9IlJBRyI+PHBvbHlnb24gZmlsbD0iIzE4MTgxOCIgcG9pbnRzPSI3NjEuNzIyNCw1ODcuODUxNiw3NzEuNzIyNCw1OTEuODUxNiw3NjEuNzIyNCw1OTUuODUxNiw3NjUuNzIyNCw1OTEuODUxNiIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxOyIvPjxsaW5lIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MTtzdHJva2UtZGFzaGFycmF5OjIsMjsiIHgxPSIzMzEuMzI1MyIgeDI9Ijc2Ny43MjI0IiB5MT0iNTkxLjg1MTYiIHkyPSI1OTEuODUxNiIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjEzIiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9Ijc4LjAwMDEiIHg9IjMzOC4zMjUzIiB5PSI1ODYuNzg1NiI+JiMzNjgyMDsmIzIyMjM4OyYjMzgzODI7JiMzOTA2NDsmIzIxNTIxOyYjMzczMjc7PC90ZXh0PjwvZz48ZyBjbGFzcz0ibWVzc2FnZSIgZGF0YS1wYXJ0aWNpcGFudC0xPSJSQUciIGRhdGEtcGFydGljaXBhbnQtMj0iREIiPjxwb2x5Z29uIGZpbGw9IiMxODE4MTgiIHBvaW50cz0iNDk4LjM5MDcsNjMyLjExNzIsNDg4LjM5MDcsNjM2LjExNzIsNDk4LjM5MDcsNjQwLjExNzIsNDk0LjM5MDcsNjM2LjExNzIiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MTsiLz48bGluZSBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjE7IiB4MT0iNDkyLjM5MDciIHgyPSI3NzIuNzIyNCIgeTE9IjYzNi4xMTcyIiB5Mj0iNjM2LjExNzIiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxMyIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSI5NC41MzU3IiB4PSI1MDQuMzkwNyIgeT0iNjE1LjkxODUiPjQuICYjMjAzNTE7JiMyOTk5MjsmIzM4MzgyOyYjMzkwNjQ7JiMyMTUyMTsmIzM3MzI3OzwvdGV4dD48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxMyIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSI5MS4wMDAxIiB4PSI1MDQuMzkwNyIgeT0iNjMxLjA1MTMiPiYjMzY4Mjc7JiMzNDg5MjsmIzMwNDU2OyYjMjAyODQ7JiMyNDIzMDsmIzI1NjI4OyYjMzIwMzQ7PC90ZXh0PjwvZz48ZyBjbGFzcz0ibWVzc2FnZSIgZGF0YS1wYXJ0aWNpcGFudC0xPSJEQiIgZGF0YS1wYXJ0aWNpcGFudC0yPSJSQUciPjxwb2x5Z29uIGZpbGw9IiMxODE4MTgiIHBvaW50cz0iNzYxLjcyMjQsNjc2LjM4MjgsNzcxLjcyMjQsNjgwLjM4MjgsNzYxLjcyMjQsNjg0LjM4MjgsNzY1LjcyMjQsNjgwLjM4MjgiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MTsiLz48bGluZSBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjE7c3Ryb2tlLWRhc2hhcnJheToyLDI7IiB4MT0iNDgyLjM5MDciIHgyPSI3NjcuNzIyNCIgeTE9IjY4MC4zODI4IiB5Mj0iNjgwLjM4MjgiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxMyIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSI5NC41MzU3IiB4PSI0ODkuMzkwNyIgeT0iNjYwLjE4NDEiPjUuICYjMzY4MjA7JiMyMjIzODsmIzI2MzY4OyYjMzA0NTY7JiMyMDg1MTsmIzMwMzQwOzwvdGV4dD48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxMyIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSIxMTMuODAwOSIgeD0iNDg5LjM5MDciIHk9IjY3NS4zMTY5Ij5LJiMyMDAxMDsmIzI1OTkxOyYjMjY0MTI7JiMyMjM1OTsgKCYjMTk5Nzg7JiMxOTk3OTsmIzI1OTkxOyk8L3RleHQ+PC9nPjxnIGNsYXNzPSJtZXNzYWdlIiBkYXRhLXBhcnRpY2lwYW50LTE9IlJBRyIgZGF0YS1wYXJ0aWNpcGFudC0yPSJSQUciPjxsaW5lIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MTsiIHgxPSI3ODMuNzIyNCIgeDI9IjgyNS43MjI0IiB5MT0iNzI0LjY0ODQiIHkyPSI3MjQuNjQ4NCIvPjxsaW5lIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MTsiIHgxPSI4MjUuNzIyNCIgeDI9IjgyNS43MjI0IiB5MT0iNzI0LjY0ODQiIHkyPSI3MzcuNjQ4NCIvPjxsaW5lIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MTsiIHgxPSI3ODQuNzIyNCIgeDI9IjgyNS43MjI0IiB5MT0iNzM3LjY0ODQiIHkyPSI3MzcuNjQ4NCIvPjxwb2x5Z29uIGZpbGw9IiMxODE4MTgiIHBvaW50cz0iNzk0LjcyMjQsNzMzLjY0ODQsNzg0LjcyMjQsNzM3LjY0ODQsNzk0LjcyMjQsNzQxLjY0ODQsNzkwLjcyMjQsNzM3LjY0ODQiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MTsiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxMyIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSI5OC4xOTgzIiB4PSI3OTAuNzIyNCIgeT0iNzA0LjQ0OTciPjYuICYjMjY1MDA7JiMyNDMxNDsgUHJvbXB0OjwvdGV4dD48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxMyIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSIxMjAuMzAwOSIgeD0iNzkwLjcyMjQiIHk9IjcxOS41ODI1Ij4oJiMxOTk3ODsmIzE5OTc5OyYjMjU5OTE7ICsgJiMyMTQwNzsmIzIyOTg3OyYjMzgzODI7JiMzOTA2NDspPC90ZXh0PjwvZz48ZyBjbGFzcz0ibWVzc2FnZSIgZGF0YS1wYXJ0aWNpcGFudC0xPSJSQUciIGRhdGEtcGFydGljaXBhbnQtMj0iTExNIj48cG9seWdvbiBmaWxsPSIjMTgxODE4IiBwb2ludHM9IjkzNi41NDA5LDc2Mi43ODEzLDk0Ni41NDA5LDc2Ni43ODEzLDkzNi41NDA5LDc3MC43ODEzLDk0MC41NDA5LDc2Ni43ODEzIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjE7Ii8+PGxpbmUgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxOyIgeDE9Ijc4My43MjI0IiB4Mj0iOTQyLjU0MDkiIHkxPSI3NjYuNzgxMyIgeTI9Ijc2Ni43ODEzIi8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTMiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMTQ1LjgxODUiIHg9Ijc5MC43MjI0IiB5PSI3NjEuNzE1MyI+Ny4gJiMyMTQ1NzsmIzM2ODY1OyYjMjI2ODY7JiMyNDM3ODsmIzIxNTE4OyYjMzAzNDA7IFByb21wdDwvdGV4dD48L2c+PGcgY2xhc3M9Im1lc3NhZ2UiIGRhdGEtcGFydGljaXBhbnQtMT0iTExNIiBkYXRhLXBhcnRpY2lwYW50LTI9IlJBRyI+PHBvbHlnb24gZmlsbD0iIzE4MTgxOCIgcG9pbnRzPSI3OTQuNzIyNCw3OTEuOTE0MSw3ODQuNzIyNCw3OTUuOTE0MSw3OTQuNzIyNCw3OTkuOTE0MSw3OTAuNzIyNCw3OTUuOTE0MSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxOyIvPjxsaW5lIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MTtzdHJva2UtZGFzaGFycmF5OjIsMjsiIHgxPSI3ODguNzIyNCIgeDI9Ijk1Mi41NDA5IiB5MT0iNzk1LjkxNDEiIHkyPSI3OTUuOTE0MSIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjEzIiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjEyLjQwMzMiIHg9IjgwMC43MjI0IiB5PSI3OTAuODQ4MSI+OC48L3RleHQ+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTMiIGZvbnQtd2VpZ2h0PSJib2xkIiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjI2IiB4PSI4MTcuMjU4MSIgeT0iNzkwLjg0ODEiPiYjMjc5Njk7JiMyNDMzNTs8L3RleHQ+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTMiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iOTEuMDAwMSIgeD0iODQzLjI1ODEiIHk9Ijc5MC44NDgxIj4mIzM2ODIwOyYjMjIyMzg7JiMyOTk4MzsmIzI1MTA0OyYjMzAzNDA7JiMzMTU3MjsmIzI2Njk2OzwvdGV4dD48L2c+PGcgY2xhc3M9Im1lc3NhZ2UiIGRhdGEtcGFydGljaXBhbnQtMT0iUkFHIiBkYXRhLXBhcnRpY2lwYW50LTI9IlVJIj48cG9seWdvbiBmaWxsPSIjMTgxODE4IiBwb2ludHM9IjYxOS4xODY2LDgyMS4wNDY5LDYwOS4xODY2LDgyNS4wNDY5LDYxOS4xODY2LDgyOS4wNDY5LDYxNS4xODY2LDgyNS4wNDY5IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjE7Ii8+PGxpbmUgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxOyIgeDE9IjYxMy4xODY2IiB4Mj0iNzcyLjcyMjQiIHkxPSI4MjUuMDQ2OSIgeTI9IjgyNS4wNDY5Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTMiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iNTUuNTM1NyIgeD0iNjI1LjE4NjYiIHk9IjgxOS45ODEiPjkuICYjMjM1NTg7JiMzMTU3MjsmIzI2Njk2OzwvdGV4dD48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxMyIgZm9udC13ZWlnaHQ9ImJvbGQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMjYiIHg9IjY4MC43MjIzIiB5PSI4MTkuOTgxIj4mIzI3OTY5OyYjMjQzMzU7PC90ZXh0Pjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjEzIiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjY1LjAwMDEiIHg9IjcwNi43MjI0IiB5PSI4MTkuOTgxIj4mIzIwMjU2OyYjMzY3NTU7JiMyMTA0MDsmIzIxMDY5OyYjMzE0NzE7PC90ZXh0PjwvZz48ZyBjbGFzcz0ibWVzc2FnZSIgZGF0YS1wYXJ0aWNpcGFudC0xPSJVSSIgZGF0YS1wYXJ0aWNpcGFudC0yPSJVc2VyIj48cG9seWdvbiBmaWxsPSIjMTgxODE4IiBwb2ludHM9IjEyMi45NTgsODY1LjMxMjUsMTEyLjk1OCw4NjkuMzEyNSwxMjIuOTU4LDg3My4zMTI1LDExOC45NTgsODY5LjMxMjUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MTsiLz48bGluZSBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjE7IiB4MT0iMTE2Ljk1OCIgeDI9IjYwMi4xODY2IiB5MT0iODY5LjMxMjUiIHkyPSI4NjkuMzEyNSIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjEzIiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjExNS44MDY3IiB4PSIxMjguOTU4IiB5PSI4NDkuMTEzOCI+MTAuICYjMjIzMTI7JiMzMjg0MjsmIzIyODI1OyYjMjY2OTQ7JiMyMDAxMzsmIzIzNDU0OyYjMjYxMDI7PC90ZXh0Pjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjEzIiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjEzMS4yNzYiIHg9IjEyOC45NTgiIHk9Ijg2NC4yNDY2Ij4mIzI2MTc0OyYjMzEwMzQ7JiMzMTU3MjsmIzI2Njk2OyAoJiMyNTE3MTsmIzIzMzgzOyYjMjY0MjY7JiMyNTkyODsmIzI2NTI0Oyk8L3RleHQ+PC9nPjwhLS1TUkM9W1pMSlJKWERINTdzVmh6WWZCb3M2bmxrYjJJT1lmY2M0WThSd3I5VjE3YzJJU2NPaWV2NHRDTDFCMFFiSUFQN1EyVzZmNXJneU9RczVfYXBGY1ZSREp0M0ZjVWRDUzdjbUlUa1BDdGxqalZQUHd1b2t3MGEyR19UNkhrMy1wSjBPZlVyc0RTTmdBejBCUkF4Q1Z5dU92R01zVllYOXlhRFRKUzgwVUs4SWdhUUl6ZHJxMlktYktWS2YtOG1GVnVud2F4X1B1cWlMalpMaFA1RldscGlzYmIwZVdHV1Q5ckV3ZWpBMDN5dUNBa0NKVWRfWUNQNDBGdmdTcjlNN1lZUEo3Tm9BZzBqZ3Fwd0dmc3BLb1FoUmF3Q2E3aVRRNjVCWjkxNlpfaGlRZUpTWjBPNElKbUtlQmtsb2czbjVtM1NTVmEwaV9WUUlnMXBlYm1ZRDB3Z3RIczI1Q2V4R29MVUN0SG1sQkI3QzFldjBuR0p0N2ZGYUQ1OHcwdUlKWEQySnNpOTlFUXdlNDhxOFhjWmFQQ01XSkNUbEpTV0E1SGlraGQwMk1URG1SNmkyTjN5NURaWTRQVTdYYVR2QmdiTTZBd3YtZ1F5Rl9mUE1MazV5NDZtRnZoUkhueXhRRmdfeTFCLUgtIC1nUTF0bi1meHNuNjgyLUZhYm9MdGpsczVpVVdkT3BZbU1XSlVpSkFXTjc1akRydk9jaVRuc0w5RWxWMnFLMUJGRS1WTjMwVmstcFQ4aERWdWpIdC1HWjdWN25DUHk3ODhtQW1HTWloX3hjclVMTXhIRFZWUzRCTnpZeFY4b3NneF91ci1TaS13aHBPZmFqaGhoQ2JoX1k1dGdGSUN3bnpRQlRHUzJhRTNjNnloMEZ6OFZXT1gzeWwzUGRWQXBwXzh3elF6Y05XSFhia3NsaVVUYkhtcnVsc1hzVFZmWVRXVnVaXzNPY2RNTVBhZlNQQW5yUWF4VXh0STVxT09LanhNN2lYNUVpaWVYVzdfM3lEY2xjbEhzd1VzcnZfRmdCa01MNjNnYi1NTDdyVWNtVUk2V1RERjZ2UFF6T0dEdmVuQkFjSzZ4RlBEWk1IeHdIUVgtazgzTnN3Nm9ra1BEWFBnQ0g0dTRuakRuUFZqTHZEY0VOVU1IWGVORGpIYk9veS1wd1lmbEJ6YkFFSldKX1h2YzJxdEJJWXBkNUlQbENqRjVJcTl4TzJ5NDREVFNubXlQd2hUTGVpRmU3ZFlxT0ZwUEZTcjJHTld2czRySHVYWFdzenpydUVua1pUeG9mMTctaGJjZEw1ZDBYU0RuWU11X2VUR05GTzc2TV9RZDNTNUFUckZHR2RibTcyTVUxbElvbmRHTEJSUzIxdWRhRW1UTmtWaEZEOGNsS0NPdWVtc3haUVpVRkZkdlR6VFUycURFM1JzbE1NRXhmaVVPbVNZTkM0d0JEYnpiNnNnbE5YN1RQcExuU2p3bUlUTXdSTGtFemNQM3E3ZmpWQ1p2TkpxYzhjSXJDclJjWmlNaExUYmNib0ZGeENTaE4zZXNqa2pLT1puaGNWSlZGMnROLTlpc0JYUzJuQzdka0tEaV9dLS0+PC9nPjwvc3ZnPg=='>

<h2 id="env-（环境变量）"><a href="#env-（环境变量）" class="headerlink" title=".env （环境变量）"></a>.env （环境变量）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># .env 文件</span><br><span class="line">OPENAI_API_KEY=&quot;xxxx&quot;</span><br><span class="line">OPENAI_BASE_URL=&quot;xxxxx&quot;</span><br><span class="line">DATABASE_URL=&quot;postgresql://root:root@localhost:5432/pgvector&quot;</span><br></pre></td></tr></table></figure>

<h2 id="hivemq-ebook-mqtt-essentials-pdf-MQTT相关的书籍"><a href="#hivemq-ebook-mqtt-essentials-pdf-MQTT相关的书籍" class="headerlink" title="hivemq-ebook-mqtt-essentials.pdf(MQTT相关的书籍)"></a>hivemq-ebook-mqtt-essentials.pdf(MQTT相关的书籍)</h2><p>hivemq组件推出的一本mqtt相关的书籍，需要把这本书解析为知识库。</p>
<h2 id="ingest-py-数据入库脚本"><a href="#ingest-py-数据入库脚本" class="headerlink" title="ingest.py (数据入库脚本)"></a>ingest.py (数据入库脚本)</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> psycopg</span><br><span class="line"><span class="keyword">from</span> dotenv <span class="keyword">import</span> load_dotenv</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> langchain_community.document_loaders <span class="keyword">import</span> PyPDFLoader</span><br><span class="line"><span class="keyword">from</span> langchain.text_splitter <span class="keyword">import</span> RecursiveCharacterTextSplitter</span><br><span class="line"><span class="keyword">from</span> langchain_openai <span class="keyword">import</span> OpenAIEmbeddings</span><br><span class="line"><span class="keyword">from</span> langchain_community.vectorstores.pgvector <span class="keyword">import</span> PGVector</span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 1. ⚙️ 配置日志系统 ---</span></span><br><span class="line">logging.basicConfig(</span><br><span class="line">    level=logging.INFO,</span><br><span class="line">    <span class="built_in">format</span>=<span class="string">&#x27;%(asctime)s - %(levelname)s - %(message)s&#x27;</span>,</span><br><span class="line">    datefmt=<span class="string">&#x27;%Y-%m-%d %H:%M:%S&#x27;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 2. 🔑 加载环境变量和配置 ---</span></span><br><span class="line">logging.info(<span class="string">&quot;🚀 开始数据入库流程...&quot;</span>)</span><br><span class="line">load_dotenv()</span><br><span class="line">logging.info(<span class="string">&quot;✅ .env 文件加载成功&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从环境变量中安全地获取配置</span></span><br><span class="line">PDF_PATH = <span class="string">&quot;hivemq-ebook-mqtt-essentials.pdf&quot;</span>  <span class="comment"># 你可以把它也放入 .env</span></span><br><span class="line">COLLECTION_NAME = <span class="string">&quot;mqtt_docs&quot;</span></span><br><span class="line">CONNECTION_STRING = os.getenv(<span class="string">&quot;DATABASE_URL&quot;</span>)</span><br><span class="line">OPENAI_API_KEY = os.getenv(<span class="string">&quot;OPENAI_API_KEY&quot;</span>)</span><br><span class="line">OPENAI_BASE_URL = os.getenv(<span class="string">&quot;OPENAI_BASE_URL&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查关键配置是否存在</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">all</span>([CONNECTION_STRING, OPENAI_API_KEY, OPENAI_BASE_URL]):</span><br><span class="line">    error_msg = <span class="string">&quot;❌ 关键环境变量缺失！请检查 .env 文件是否包含 DATABASE_URL, OPENAI_API_KEY, OPENAI_BASE_URL&quot;</span></span><br><span class="line">    logging.error(error_msg)</span><br><span class="line">    <span class="keyword">raise</span> ValueError(error_msg)</span><br><span class="line">logging.info(<span class="string">&quot;👍 所有环境变量配置加载完毕&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ingest_data</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    加载、分割、嵌入并存储PDF文档数据到PGVector。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 检查PDF文件是否存在</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(PDF_PATH):</span><br><span class="line">        logging.error(<span class="string">f&quot;🔥 错误: PDF文件未找到于 <span class="subst">&#123;PDF_PATH&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    connection = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># --- 3. 📄 加载PDF文档 ---</span></span><br><span class="line">        logging.info(<span class="string">f&quot;📄 正在加载文档: <span class="subst">&#123;PDF_PATH&#125;</span>...&quot;</span>)</span><br><span class="line">        loader = PyPDFLoader(PDF_PATH)</span><br><span class="line">        documents = loader.load()</span><br><span class="line">        logging.info(<span class="string">f&quot;✅ 成功加载 <span class="subst">&#123;<span class="built_in">len</span>(documents)&#125;</span> 页文档。&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># --- 4. 🔪 分割文档为文本块 ---</span></span><br><span class="line">        logging.info(<span class="string">&quot;🔪 正在分割文档为文本块...&quot;</span>)</span><br><span class="line">        text_splitter = RecursiveCharacterTextSplitter(</span><br><span class="line">            chunk_size=<span class="number">1000</span>,</span><br><span class="line">            chunk_overlap=<span class="number">150</span>,</span><br><span class="line">            length_function=<span class="built_in">len</span></span><br><span class="line">        )</span><br><span class="line">        chunks = text_splitter.split_documents(documents)</span><br><span class="line">        logging.info(<span class="string">f&quot;✅ 文档被分割成 <span class="subst">&#123;<span class="built_in">len</span>(chunks)&#125;</span> 个文本块。&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># --- 5. 🧠 创建文本嵌入模型 ---</span></span><br><span class="line">        logging.info(<span class="string">&quot;🧠 正在初始化 OpenAI Embedding 模型 (text-embedding-3-small)...&quot;</span>)</span><br><span class="line">        embeddings = OpenAIEmbeddings(</span><br><span class="line">            model=<span class="string">&quot;text-embedding-3-small&quot;</span>,</span><br><span class="line">            api_key=OPENAI_API_KEY,</span><br><span class="line">            base_url=OPENAI_BASE_URL</span><br><span class="line">        )</span><br><span class="line">        logging.info(<span class="string">&quot;✅ 嵌入模型初始化完成。&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># --- 6. 📦 将数据存入 PGVector ---</span></span><br><span class="line">        logging.info(<span class="string">f&quot;🔗 正在连接到数据库: <span class="subst">&#123;CONNECTION_STRING.split(<span class="string">&#x27;@&#x27;</span>)[-<span class="number">1</span>]&#125;</span>&quot;</span>)</span><br><span class="line">        connection = psycopg.connect(CONNECTION_STRING)</span><br><span class="line">        logging.info(<span class="string">&quot;🎉 数据库连接成功！&quot;</span>)</span><br><span class="line"></span><br><span class="line">        logging.info(<span class="string">f&quot;📦 准备将 <span class="subst">&#123;<span class="built_in">len</span>(chunks)&#125;</span> 个文本块存入集合 &#x27;<span class="subst">&#123;COLLECTION_NAME&#125;</span>&#x27;...&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 使用 from_documents 方法，并设置 pre_delete_collection=True</span></span><br><span class="line">        <span class="comment"># 这会先删除同名旧集合（如果存在），确保数据从零开始，非常适合重新入库</span></span><br><span class="line">        PGVector.from_documents(</span><br><span class="line">            documents=chunks,</span><br><span class="line">            embedding=embeddings,</span><br><span class="line">            collection_name=COLLECTION_NAME,</span><br><span class="line">            connection_string=CONNECTION_STRING,</span><br><span class="line">            pre_delete_collection=<span class="literal">True</span>,  <span class="comment"># ✨ 最佳实践: 保证每次都是全新入库</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        logging.info(<span class="string">&quot;🎉 数据处理流程圆满完成！&quot;</span>)</span><br><span class="line">        logging.info(<span class="string">f&quot;✅ <span class="subst">&#123;<span class="built_in">len</span>(chunks)&#125;</span> 个文档块已成功存入集合 &#x27;<span class="subst">&#123;COLLECTION_NAME&#125;</span>&#x27;。&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        logging.error(<span class="string">f&quot;🔥 数据处理流程中发生严重错误: <span class="subst">&#123;e&#125;</span>&quot;</span>, exc_info=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="comment"># 确保数据库连接在使用后被关闭</span></span><br><span class="line">        <span class="keyword">if</span> connection:</span><br><span class="line">            connection.close()</span><br><span class="line">            logging.info(<span class="string">&quot;🚪 数据库连接已关闭。&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    ingest_data()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>流程总结：</p>
<pre class="mermaid">%% `ingest.py`
graph TD
    subgraph "准备阶段 (Preparation)"
        A[开始 Ingestion 脚本] --> B["配置与加载<br>(Logging, .env)"];
    end

    subgraph "数据处理 (Processing)"
        B --> C{PDF 文件存在?};
        C -- 否 --> D[记录错误并退出];
        C -- 是 --> E["加载 PDF 文档<br>(使用 PyPDFLoader)"];
        E --> F["分割文档为文本块 (Chunks)<br>(使用 RecursiveCharacterTextSplitter)"];
        F --> G["初始化嵌入模型<br>(OpenAI text-embedding-3-small)"];
    end
    
    subgraph "数据库操作 (Database Operations)"
        G --> H["连接到 PostgreSQL 数据库<br>(使用 psycopg)"];
        H --> I[调用 PGVector.from_documents];
        
        subgraph I [内部流程]
            direction TB
            I1{pre_delete_collection=True?};
            I1 -- 是 --> I2[清空/删除旧的 Collection];
            I1 -- 否 --> I3;
            I2 --> I3["对于每一个 Chunk..."];
            I3 --> I4["调用 OpenAI API<br>将文本转换为 Vector"];
            I4 --> I5["将 (文本 + Vector)<br>插入数据库"];
            I5 --> I3;
        end
    end

    subgraph "收尾阶段 (Finalization)"
         I --> J["记录成功日志"];
         J --> K["关闭数据库连接<br>(在 finally 块中确保执行)"];
         K --> L[流程结束];
    end</pre>



<p>这个脚本是一个<strong>一次性</strong>的、<strong>离线</strong>运行的程序，作用就构建知识库。</p>
<ul>
<li><strong>🎯 目的</strong>: 将非结构化的 PDF 文档转换为结构化的、可供快速检索的向量数据。</li>
<li>核心流程<ol>
<li><strong>加载 (Load)</strong>: 读取指定的 MQTT PDF 文档内容。</li>
<li><strong>分割 (Split)</strong>: 将整个文档的长文本切割成更小的、带有上下文重叠的文本块 (Chunks)。</li>
<li><strong>嵌入 (Embed)</strong>: 调用 OpenAI 的 <code>text-embedding-3-small</code> 模型，将每一个文本块转换成一个高维数学向量。</li>
<li><strong>存储 (Store)</strong>: 将文本块和其对应的向量一起存入 PostgreSQL 数据库的 <code>pgvector</code> 扩展中，并使用 <code>pre_delete_collection=True</code> 确保每次都是全新的数据。</li>
</ol>
</li>
</ul>
<p>运行：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">python ingest.py </span><br><span class="line">2025-08-16 17:17:22 - INFO - 🚀 开始数据入库流程...</span><br><span class="line">2025-08-16 17:17:22 - INFO - ✅ .<span class="built_in">env</span> 文件加载成功</span><br><span class="line">2025-08-16 17:17:22 - INFO - 👍 所有环境变量配置加载完毕</span><br><span class="line">2025-08-16 17:17:22 - INFO - 📄 正在加载文档: hivemq-ebook-mqtt-essentials.pdf...</span><br><span class="line">2025-08-16 17:17:24 - INFO - ✅ 成功加载 90 页文档。</span><br><span class="line">2025-08-16 17:17:24 - INFO - 🔪 正在分割文档为文本块...</span><br><span class="line">2025-08-16 17:17:24 - INFO - ✅ 文档被分割成 317 个文本块。</span><br><span class="line">2025-08-16 17:17:24 - INFO - 🧠 正在初始化 OpenAI Embedding 模型 (text-embedding-3-small)...</span><br><span class="line">2025-08-16 17:17:24 - INFO - ✅ 嵌入模型初始化完成。</span><br><span class="line">2025-08-16 17:17:24 - INFO - 🔗 正在连接到数据库: localhost:5432/pgvector</span><br><span class="line">2025-08-16 17:17:24 - INFO - 🎉 数据库连接成功！</span><br><span class="line">2025-08-16 17:17:24 - INFO - 📦 准备将 317 个文本块存入集合 <span class="string">&#x27;mqtt_docs&#x27;</span>...</span><br><span class="line">2025-08-16 17:17:27 - INFO - HTTP Request: POST https://api.chatanywhere.tech/embeddings <span class="string">&quot;HTTP/1.1 200 OK&quot;</span></span><br><span class="line">/usr/local/lib/python3.11/site-packages/langchain_community/vectorstores/pgvector.py:490: LangChainPendingDeprecationWarning: Please use JSONB instead of JSON <span class="keyword">for</span> metadata. This change will allow <span class="keyword">for</span> more efficient querying that involves filtering based on metadata. Please note that filtering operators have been changed when using JSONB metadata to be prefixed with a $ sign to avoid name collisions with columns. If you<span class="string">&#x27;re using an existing database, you will need to create a db migration for your metadata column to be JSONB and update your queries to use the new operators. </span></span><br><span class="line"><span class="string">  store = cls(</span></span><br><span class="line"><span class="string">2025-08-16 17:17:35 - INFO - 🎉 数据处理流程圆满完成！</span></span><br><span class="line"><span class="string">2025-08-16 17:17:35 - INFO - ✅ 317 个文档块已成功存入集合 &#x27;</span>mqtt_docs<span class="string">&#x27;。</span></span><br><span class="line"><span class="string">2025-08-16 17:17:35 - INFO - 🚪 数据库连接已关闭。</span></span><br></pre></td></tr></table></figure>

<p>pgvector 有告警是因为 LangChain 推荐使用性能更好的 <code>JSONB</code> 格式来存储元数据。</p>
<h3 id="数据库向量："><a href="#数据库向量：" class="headerlink" title="数据库向量："></a>数据库向量：</h3><p>用pgadmin工具可以看到数据库里面创建了2张表：</p>
<p><img src="/2025/08/16/RAG%E5%AE%9E%E6%88%98%EF%BC%9A%E7%94%A8LangChain%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%9F%A5%E8%AF%86%E5%BA%93/image-20250816182559256.png" alt="image-20250816182559256"></p>
<p><strong><code>langchain_pg_collection</code> (集合目录表)</strong></p>
<ul>
<li><strong>作用</strong>: 记录了你创建的所有向量集合（Collections）的名称和唯一ID。</li>
<li><strong>内容</strong>: 每行代表一个独立的知识库（例如 <code>mqtt_docs</code>）。</li>
</ul>
<p><strong><code>langchain_pg_embedding</code> (嵌入数据表)</strong></p>
<ul>
<li><strong>作用</strong>: 存储了<strong>所有集合</strong>的全部数据。</li>
<li><strong>内容</strong>: 每行包含一个具体的文本块（document）、其对应的向量（embedding）以及一个 <code>collection_id</code>，用于指明这条数据属于哪个集合。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> public.langchain_pg_collection</span><br><span class="line">(</span><br><span class="line">    <span class="comment">-- 字段注释 --</span></span><br><span class="line">    name      <span class="type">character</span> <span class="type">varying</span>,  <span class="comment">-- 集合的易读名称，由开发者在代码中指定 (例如 &#x27;mqtt_docs&#x27;)。</span></span><br><span class="line">    cmetadata json,               <span class="comment">-- (Collection Metadata) 用于存储关于整个集合的元数据的 JSON 字段。例如，可以存储集合的描述、来源信息等。</span></span><br><span class="line">    uuid      uuid <span class="keyword">NOT NULL</span>,      <span class="comment">-- 集合的唯一标识符 (UUID)，作为这张表的主键 (Primary Key)。它被 `langchain_pg_embedding` 表用作外键来关联数据。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 约束注释 --</span></span><br><span class="line">    <span class="keyword">CONSTRAINT</span> langchain_pg_collection_pkey <span class="keyword">PRIMARY KEY</span> (uuid) <span class="comment">-- 将 `uuid` 字段设置为主键，确保每个集合都有一个唯一的、非空的标识符。</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> public.langchain_pg_embedding</span><br><span class="line">(</span><br><span class="line">    <span class="comment">-- 字段注释 --</span></span><br><span class="line">    collection_id uuid,               <span class="comment">-- 外键 (Foreign Key)，关联到 `langchain_pg_collection` 表中的 `uuid`。它标识了这条数据属于哪一个集合。</span></span><br><span class="line">    embedding     vector,             <span class="comment">-- 文本块的向量表示。这是由 `pgvector` 扩展提供的数据类型，用于进行高效的相似度搜索。</span></span><br><span class="line">    document      <span class="type">character</span> <span class="type">varying</span>,  <span class="comment">-- 原始的文本块内容。这是 RAG 流程中检索到的、将提供给 LLM 作为上下文的实际文本。</span></span><br><span class="line">    cmetadata     json,               <span class="comment">-- (Content Metadata) 关于单个文本块的元数据的 JSON 字段。通常用于存储来源信息 (如文件名、页码) 以便追溯和过滤。较新版本中，此字段类型已升级为 `JSONB` 以提高查询性能。</span></span><br><span class="line">    custom_id     <span class="type">character</span> <span class="type">varying</span>,  <span class="comment">-- 一个可选的、由用户自定义的 ID 字段。如果开发者在添加文档时提供了 `ids` 参数，这些 ID 会被存储在这里，方便与外部系统进行关联或进行特定 ID 的数据操作。</span></span><br><span class="line">    uuid          uuid <span class="keyword">NOT NULL</span>,      <span class="comment">-- 这条嵌入数据记录自身的唯一标识符 (UUID)，作为这张表的主键。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 约束注释 --</span></span><br><span class="line">    <span class="keyword">CONSTRAINT</span> langchain_pg_embedding_pkey <span class="keyword">PRIMARY KEY</span> (uuid), <span class="comment">-- 将 `uuid` 字段设置为主键，确保表中的每一条数据记录都是唯一的。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">CONSTRAINT</span> langchain_pg_embedding_collection_id_fkey <span class="keyword">FOREIGN KEY</span> (collection_id) <span class="comment">-- 定义了 `collection_id` 是一个外键，它必须引用 `langchain_pg_collection` 表中真实存在的 `uuid`。</span></span><br><span class="line">        <span class="keyword">REFERENCES</span> public.langchain_pg_collection (uuid) <span class="keyword">MATCH</span> SIMPLE</span><br><span class="line">        <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">NO</span> ACTION</span><br><span class="line">        <span class="keyword">ON</span> <span class="keyword">DELETE</span> CASCADE <span class="comment">-- 这是一个关键的级联删除规则：当一个集合从 `langchain_pg_collection` 表中被删除时，所有属于该集合的数据将自动从这张表中被删除，保证了数据的完整性。</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>



<p>用sql看下数据:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pgvector=# <span class="keyword">select</span> * from langchain_pg_collection;</span><br><span class="line">   name    | cmetadata |                 uuid                 </span><br><span class="line">-----------+-----------+--------------------------------------</span><br><span class="line"> mqtt_docs | null      | 6b065562-e20d-4758-8097-8459dd3618db</span><br><span class="line">(1 row)</span><br><span class="line">pgvector=#  <span class="keyword">select</span> count(*) from langchain_pg_embedding;</span><br><span class="line"> count </span><br><span class="line">-------</span><br><span class="line">   317</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>

<p>langchain_pg_embedding 数量和日志里面对的上的，langchain_pg_embedding 的表数据太长了，下图展示一下：</p>
<p><img src="/2025/08/16/RAG%E5%AE%9E%E6%88%98%EF%BC%9A%E7%94%A8LangChain%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%9F%A5%E8%AF%86%E5%BA%93/image-20250816185704062.png" alt="image-20250816185704062"></p>
<p>这里直观的看到文本转为为向量并存储到数据库中了。</p>
<h2 id="app-py-Web应用与问答服务"><a href="#app-py-Web应用与问答服务" class="headerlink" title="app.py (Web应用与问答服务)"></a><code>app.py</code> (Web应用与问答服务)</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> gradio <span class="keyword">as</span> gr</span><br><span class="line"><span class="keyword">import</span> psycopg</span><br><span class="line"><span class="keyword">from</span> dotenv <span class="keyword">import</span> load_dotenv</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> langchain_community.vectorstores.pgvector <span class="keyword">import</span> PGVector</span><br><span class="line"><span class="keyword">from</span> langchain_openai <span class="keyword">import</span> ChatOpenAI, OpenAIEmbeddings</span><br><span class="line"><span class="keyword">from</span> langchain.prompts <span class="keyword">import</span> PromptTemplate</span><br><span class="line"><span class="keyword">from</span> langchain.schema.runnable <span class="keyword">import</span> RunnablePassthrough, RunnableLambda</span><br><span class="line"><span class="keyword">from</span> langchain.schema.output_parser <span class="keyword">import</span> StrOutputParser</span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 1. ⚙️ 配置日志系统 ---</span></span><br><span class="line">logging.basicConfig(</span><br><span class="line">    level=logging.INFO,</span><br><span class="line">    <span class="built_in">format</span>=<span class="string">&#x27;%(asctime)s - %(levelname)s - %(message)s&#x27;</span>,</span><br><span class="line">    datefmt=<span class="string">&#x27;%Y-%m-%d %H:%M:%S&#x27;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 2. 🔑 加载环境变量和配置 ---</span></span><br><span class="line">logging.info(<span class="string">&quot;🚀 应用开始启动...&quot;</span>)</span><br><span class="line">load_dotenv()</span><br><span class="line">logging.info(<span class="string">&quot;✅ .env 文件加载成功&quot;</span>)</span><br><span class="line"></span><br><span class="line">CONNECTION_STRING = os.getenv(<span class="string">&quot;DATABASE_URL&quot;</span>)</span><br><span class="line">COLLECTION_NAME = <span class="string">&quot;mqtt_docs&quot;</span></span><br><span class="line">OPENAI_API_KEY = os.getenv(<span class="string">&quot;OPENAI_API_KEY&quot;</span>)</span><br><span class="line">OPENAI_BASE_URL = os.getenv(<span class="string">&quot;OPENAI_BASE_URL&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查关键配置是否存在</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">all</span>([CONNECTION_STRING, COLLECTION_NAME, OPENAI_API_KEY, OPENAI_BASE_URL]):</span><br><span class="line">    error_msg = <span class="string">&quot;❌ 关键环境变量缺失！请检查 .env 文件是否包含 DATABASE_URL, OPENAI_API_KEY, OPENAI_BASE_URL&quot;</span></span><br><span class="line">    logging.error(error_msg)</span><br><span class="line">    <span class="keyword">raise</span> ValueError(error_msg)</span><br><span class="line">logging.info(<span class="string">&quot;👍 所有环境变量配置加载完毕&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 3. 🔗 初始化数据库连接 ---</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    logging.info(<span class="string">f&quot;🔗 正在连接到数据库: <span class="subst">&#123;CONNECTION_STRING.split(<span class="string">&#x27;@&#x27;</span>)[-<span class="number">1</span>]&#125;</span>&quot;</span>)</span><br><span class="line">    connection = psycopg.connect(CONNECTION_STRING)</span><br><span class="line">    logging.info(<span class="string">&quot;🎉 数据库连接成功！&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    logging.error(<span class="string">f&quot;🔥 数据库连接失败: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">raise</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 4. 🧠 初始化 AI 模型 ---</span></span><br><span class="line">logging.info(<span class="string">&quot;🧠 正在初始化 OpenAI 模型...&quot;</span>)</span><br><span class="line">llm = ChatOpenAI(</span><br><span class="line">    base_url=OPENAI_BASE_URL,</span><br><span class="line">    api_key=OPENAI_API_KEY,</span><br><span class="line">    model=<span class="string">&quot;gpt-4o&quot;</span>,</span><br><span class="line">    temperature=<span class="number">0.1</span>,</span><br><span class="line">    streaming=<span class="literal">True</span></span><br><span class="line">)</span><br><span class="line">embeddings = OpenAIEmbeddings(</span><br><span class="line">    model=<span class="string">&quot;text-embedding-3-small&quot;</span>,</span><br><span class="line">    api_key=OPENAI_API_KEY,</span><br><span class="line">    base_url=OPENAI_BASE_URL</span><br><span class="line">)</span><br><span class="line">logging.info(<span class="string">&quot;🤖 LLM 和 Embedding 模型初始化完成&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 5. 📚 初始化向量存储和检索器 ---</span></span><br><span class="line">logging.info(<span class="string">f&quot;📚 正在连接到向量集合: &#x27;<span class="subst">&#123;COLLECTION_NAME&#125;</span>&#x27;&quot;</span>)</span><br><span class="line">vectorstore = PGVector(</span><br><span class="line">    connection_string=CONNECTION_STRING,</span><br><span class="line">    collection_name=COLLECTION_NAME,</span><br><span class="line">    embedding_function=embeddings,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回10个最相关的文档</span></span><br><span class="line">retriever = vectorstore.as_retriever(search_kwargs=&#123;<span class="string">&#x27;k&#x27;</span>: <span class="number">10</span>&#125;)</span><br><span class="line">logging.info(<span class="string">&quot;✅ 向量存储和检索器准备就绪&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 6. 🛠️ 构建 RAG 链 (带日志记录) ---</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 提示模板</span></span><br><span class="line">template = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">你是一个关于MQTT协议的技术专家。请根据下面提供的上下文信息，用中文、清晰、准确地回答用户的问题。</span></span><br><span class="line"><span class="string">如果上下文中没有足够的信息来回答问题，请明确说明“根据我所掌握的知识，无法回答这个问题”，不要编造答案。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">上下文:</span></span><br><span class="line"><span class="string">&#123;context&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">问题:</span></span><br><span class="line"><span class="string">&#123;question&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">回答:</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">prompt = PromptTemplate.from_template(template)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">format_docs</span>(<span class="params">docs</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;\n\n&quot;</span>.join(doc.page_content <span class="keyword">for</span> doc <span class="keyword">in</span> docs)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">log_retrieved_documents</span>(<span class="params">docs</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;一个用于在链中记录检索到的文档的函数&quot;&quot;&quot;</span></span><br><span class="line">    logging.info(<span class="string">f&quot;🔍 向量检索完成，找到 <span class="subst">&#123;<span class="built_in">len</span>(docs)&#125;</span> 个相关文档:&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i, doc <span class="keyword">in</span> <span class="built_in">enumerate</span>(docs):</span><br><span class="line">        content_preview = doc.page_content.replace(<span class="string">&#x27;\n&#x27;</span>, <span class="string">&#x27; &#x27;</span>).strip()[:<span class="number">120</span>]</span><br><span class="line">        page_num = doc.metadata.get(<span class="string">&#x27;page&#x27;</span>, <span class="string">&#x27;N/A&#x27;</span>)</span><br><span class="line">        logging.info(<span class="string">f&quot;  📄 文档 <span class="subst">&#123;i + <span class="number">1</span>&#125;</span> (页码: <span class="subst">&#123;page_num&#125;</span>): &#x27;<span class="subst">&#123;content_preview&#125;</span>...&#x27;&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> docs</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">logging.info(<span class="string">&quot;⛓️ 正在构建 RAG 链...&quot;</span>)</span><br><span class="line">rag_chain = (</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;context&quot;</span>: retriever | RunnableLambda(log_retrieved_documents) | format_docs,</span><br><span class="line">            <span class="string">&quot;question&quot;</span>: RunnablePassthrough()</span><br><span class="line">        &#125;</span><br><span class="line">        | prompt</span><br><span class="line">        | llm</span><br><span class="line">        | StrOutputParser()</span><br><span class="line">)</span><br><span class="line">logging.info(<span class="string">&quot;✅ RAG 链构建完成&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 7. 💬 定义 Gradio 聊天功能 ---</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">chat_function</span>(<span class="params">message, history</span>):</span><br><span class="line">    logging.info(<span class="string">f&quot;💬 收到用户新问题: &#x27;<span class="subst">&#123;message&#125;</span>&#x27;&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 流式处理</span></span><br><span class="line">    response_generator = rag_chain.stream(message)</span><br><span class="line">    partial_message = <span class="string">&quot;&quot;</span></span><br><span class="line">    logging.info(<span class="string">&quot;✍️ 开始向用户流式传输回答...&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> chunk <span class="keyword">in</span> response_generator:</span><br><span class="line">        partial_message += chunk</span><br><span class="line">        <span class="keyword">yield</span> partial_message</span><br><span class="line">    logging.info(<span class="string">&quot;✅ 流式传输完成&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 8. 🌐 启动 Gradio 应用 ---</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    logging.info(<span class="string">&quot;🌐 准备启动 Gradio Web UI...&quot;</span>)</span><br><span class="line">    demo = gr.ChatInterface(</span><br><span class="line">        fn=chat_function,</span><br><span class="line">        title=<span class="string">&quot;MQTT 协议知识库 🤖&quot;</span>,</span><br><span class="line">        description=<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        这是一个基于 MQTT 协议文档的 RAG 问答机器人。</span></span><br><span class="line"><span class="string">        你可以用中文提问关于 MQTT 协议的任何问题，例如：</span></span><br><span class="line"><span class="string">        - &quot;MQTT的QoS等级有哪些？分别解释一下。&quot;</span></span><br><span class="line"><span class="string">        - &quot;CONNECT报文的结构是怎样的？&quot;</span></span><br><span class="line"><span class="string">        - &quot;什么是遗嘱消息（Will Message）？&quot;</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span>,</span><br><span class="line">        <span class="built_in">type</span>=<span class="string">&quot;messages&quot;</span>,</span><br><span class="line">        chatbot=gr.Chatbot(height=<span class="number">600</span>),</span><br><span class="line">        textbox=gr.Textbox(placeholder=<span class="string">&quot;请输入你关于MQTT协议的问题...&quot;</span>, container=<span class="literal">False</span>, scale=<span class="number">7</span>),</span><br><span class="line">        theme=<span class="string">&quot;soft&quot;</span>,</span><br><span class="line">    )</span><br><span class="line">    demo.launch()</span><br></pre></td></tr></table></figure>

<p>流程总结：</p>
<pre class="mermaid">%% `app.py`
graph TD
    subgraph "阶段一: 应用启动与初始化"
        A[启动 app.py]
        A --> B["配置与加载<br>(Logging, .env)"]
        B --> C["建立持久的<br>数据库连接 (psycopg)"]
        C --> D["初始化 AI 模型<br>(LLM: GPT-4o & Embeddings)"]
        D --> E["初始化向量存储<br>并创建 Retriever"]
        E --> F["构建 RAG 链<br>(使用 LangChain LCEL)"]
        F --> G["启动 Gradio Web UI<br>(应用进入监听状态)"]
    end

    %% 添加一个从阶段一到阶段二的逻辑连接线
    G -. "用户开始交互" .-> User

    subgraph "阶段二: 实时问答流程"
        User["User"]
        UI[Gradio UI]
        RAG["LangChain RAG Chain<br>(在 app.py 中运行)"]
        DB["PGVector Database"]
        LLM["LLM (GPT-4o)"]

        User -- 1.输入问题 --> UI
        UI -- 2.将问题发送给chat_function--> RAG
        RAG -- 3.向量化问题并检索--> DB
        DB -- "4.返回 K 个最相关的<br>文本块 (上下文)" --> RAG
        RAG -- "5.构建最终 Prompt:<br>[上下文] + [原始问题]" --> LLM
        LLM -- 6.<b>流式</b>生成答案 --> RAG
        RAG -- "7.将答案 <b>流式</b> 传输回 UI" --> UI
        UI -- "8.实时更新聊天窗口<br>(打字机效果)" --> User
    end</pre>



<p>这个脚本是一个<strong>持续运行</strong>的、<strong>在线</strong>提供服务的程序，它构成了用户与之交互的后端和前端。</p>
<ul>
<li><strong>🎯 目的</strong>: 接收用户问题，利用已构建的知识库生成精准回答，并通过 Web 界面展示。</li>
<li>核心流程<ol>
<li><strong>初始化 (Initialize)</strong>: 在启动时，加载所有配置，连接数据库，并准备好大语言模型 (GPT-4o)、嵌入模型和向量检索器。</li>
<li><strong>构建RAG链 (Build RAG Chain)</strong>: 使用 LangChain Expression Language (LCEL) 定义一个清晰的、可流式处理的问答逻辑链。</li>
<li><strong>提供Web界面 (Provide Web UI)</strong>: 启动一个 Gradio 服务，创建一个用户友好的聊天窗口。</li>
<li>处理用户请求 (Handle User Request)<ul>
<li>接收用户输入的问题。</li>
<li><strong>检索 (Retrieve)</strong>: 将问题向量化，并在 <code>pgvector</code> 中快速找到最相似的 N 个文本块（即最相关的上下文）。</li>
<li><strong>增强 (Augment)</strong>: 将检索到的上下文和原始问题组合成一个详细的提示 (Prompt)。</li>
<li><strong>生成 (Generate)</strong>: 将这个增强后的提示发送给 GPT-4o，让它基于提供的上下文生成回答。</li>
<li><strong>流式返回 (Stream)</strong>: 将 GPT-4o 生成的答案以流的形式实时传输回前端，实现打字机效果。</li>
</ul>
</li>
</ol>
</li>
</ul>
<p>运行：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python app.py</span></span><br><span class="line">2025-08-16 18:59:23 - INFO - 🚀 应用开始启动...</span><br><span class="line">2025-08-16 18:59:23 - INFO - ✅ .<span class="built_in">env</span> 文件加载成功</span><br><span class="line">2025-08-16 18:59:23 - INFO - 👍 所有环境变量配置加载完毕</span><br><span class="line">2025-08-16 18:59:23 - INFO - 🔗 正在连接到数据库: localhost:5432/pgvector</span><br><span class="line">2025-08-16 18:59:23 - INFO - 🎉 数据库连接成功！</span><br><span class="line">2025-08-16 18:59:23 - INFO - 🧠 正在初始化 OpenAI 模型...</span><br><span class="line">2025-08-16 18:59:23 - INFO - 🤖 LLM 和 Embedding 模型初始化完成</span><br><span class="line">2025-08-16 18:59:23 - INFO - 📚 正在连接到向量集合: <span class="string">&#x27;mqtt_docs&#x27;</span></span><br><span class="line">/root/project/mqtt-rag-project/app.py:64: LangChainPendingDeprecationWarning: This class is pending deprecation and may be removed <span class="keyword">in</span> a future version. You can swap to using the `PGVector` implementation <span class="keyword">in</span> `langchain_postgres`. Please <span class="built_in">read</span> the guidelines <span class="keyword">in</span> the doc-string of this class to follow prior to migrating as there are some differences between the implementations. See &lt;https://github.com/langchain-ai/langchain-postgres&gt; <span class="keyword">for</span> details about the new implementation.</span><br><span class="line">  vectorstore = PGVector(</span><br><span class="line">/root/project/mqtt-rag-project/app.py:64: LangChainPendingDeprecationWarning: Please use JSONB instead of JSON <span class="keyword">for</span> metadata. This change will allow <span class="keyword">for</span> more efficient querying that involves filtering based on metadata. Please note that filtering operators have been changed when using JSONB metadata to be prefixed with a $ sign to avoid name collisions with columns. If you<span class="string">&#x27;re using an existing database, you will need to create a db migration for your metadata column to be JSONB and update your queries to use the new operators. </span></span><br><span class="line"><span class="string">  vectorstore = PGVector(</span></span><br><span class="line"><span class="string">2025-08-16 18:59:23 - INFO - ✅ 向量存储和检索器准备就绪</span></span><br><span class="line"><span class="string">2025-08-16 18:59:23 - INFO - ⛓️ 正在构建 RAG 链...</span></span><br><span class="line"><span class="string">2025-08-16 18:59:23 - INFO - ✅ RAG 链构建完成</span></span><br><span class="line"><span class="string">2025-08-16 18:59:23 - INFO - 🌐 准备启动 Gradio Web UI...</span></span><br><span class="line"><span class="string">/root/project/mqtt-rag-project/app.py:147: UserWarning: You have not specified a value for the `type` parameter. Defaulting to the &#x27;</span>tuples<span class="string">&#x27; format for chatbot messages, but this is deprecated and will be removed in a future version of Gradio. Please set type=&#x27;</span>messages<span class="string">&#x27; instead, which uses openai-style dictionaries with &#x27;</span>role<span class="string">&#x27; and &#x27;</span>content<span class="string">&#x27; keys.</span></span><br><span class="line"><span class="string">  chatbot=gr.Chatbot(height=600),</span></span><br><span class="line"><span class="string">/usr/local/lib/python3.11/site-packages/gradio/chat_interface.py:321: UserWarning: The type of the gr.Chatbot does not match the type of the gr.ChatInterface.The type of the gr.ChatInterface, &#x27;</span>messages<span class="string">&#x27;, will be used.</span></span><br><span class="line"><span class="string">  warnings.warn(</span></span><br><span class="line"><span class="string">* Running on local URL:  http://127.0.0.1:7860</span></span><br><span class="line"><span class="string">2025-08-16 18:59:24 - INFO - HTTP Request: GET http://127.0.0.1:7860/gradio_api/startup-events &quot;HTTP/1.1 200 OK&quot;</span></span><br><span class="line"><span class="string">2025-08-16 18:59:24 - INFO - HTTP Request: HEAD http://127.0.0.1:7860/ &quot;HTTP/1.1 200 OK&quot;</span></span><br><span class="line"><span class="string">* To create a public link, set `share=True` in `launch()`.</span></span><br><span class="line"><span class="string">2025-08-16 18:59:26 - INFO - HTTP Request: GET https://api.gradio.app/pkg-version &quot;HTTP/1.1 200 OK&quot;</span></span><br></pre></td></tr></table></figure>

<p>服务成功启动了，看下web页面：</p>
<p><img src="/2025/08/16/RAG%E5%AE%9E%E6%88%98%EF%BC%9A%E7%94%A8LangChain%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%9F%A5%E8%AF%86%E5%BA%93/image-20250816190128801.png" alt="image-20250816190128801"></p>
<p>现在让我们提问几个MQTT相关的知识点，看下有没有成功检索刚刚创建的知识库，日志里面会详细打印数据。</p>
<p><img src="/2025/08/16/RAG%E5%AE%9E%E6%88%98%EF%BC%9A%E7%94%A8LangChain%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%9F%A5%E8%AF%86%E5%BA%93/image-20250816190506250.png" alt="image-20250816190506250"></p>
<p>日志输出：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">2025-08-16 19:04:15 - INFO - HTTP Request: HEAD http://127.0.0.1:7860/ <span class="string">&quot;HTTP/1.1 200 OK&quot;</span></span><br><span class="line">2025-08-16 19:04:15 - INFO - HTTP Request: GET https://api.gradio.app/pkg-version <span class="string">&quot;HTTP/1.1 200 OK&quot;</span></span><br><span class="line">2025-08-16 19:04:24 - INFO - 💬 收到用户新问题: <span class="string">&#x27;mqtt 是什么？&#x27;</span></span><br><span class="line">2025-08-16 19:04:24 - INFO - ✍️ 开始向用户流式传输回答...</span><br><span class="line">2025-08-16 19:04:25 - INFO - HTTP Request: POST https://api.chatanywhere.tech/embeddings <span class="string">&quot;HTTP/1.1 200 OK&quot;</span></span><br><span class="line">2025-08-16 19:04:25 - INFO - 🔍 向量检索完成，找到 10 个相关文档:</span><br><span class="line">2025-08-16 19:04:25 - INFO -   📄 文档 1 (页码: 2): <span class="string">&#x27;Chapter 1: Introduction to MQTT MQTT is a lightweight messaging protocol originally designed for communication in constr...&#x27;</span></span><br><span class="line">2025-08-16 19:04:25 - INFO -   📄 文档 2 (页码: 4): <span class="string">&#x27;While it formerly stood for MQ Telemetry  Transport, where MQ referred to the MQ  Series, a product IBM developed to sup...&#x27;</span></span><br><span class="line">2025-08-16 19:04:25 - INFO -   📄 文档 3 (页码: 4): <span class="string">&#x27;cases. Over the next ten years, IBM used the protocol internally until  they released MQTT 3.1 as a royalty-free version...&#x27;</span></span><br><span class="line">2025-08-16 19:04:25 - INFO -   📄 文档 4 (页码: 4): <span class="string">&#x27;Real-World Applications and Use Cases of  MQTT: An Overview MQTT is used extensively in IoT, Industrial IoT (IIoT), and ...&#x27;</span></span><br><span class="line">2025-08-16 19:04:25 - INFO -   📄 文档 5 (页码: 77): <span class="string">&#x27;managed cloud MQTT broker. Explore them now! MQTT HTTP Full name MQTT (the OASIS standardization  group decided it would...&#x27;</span></span><br><span class="line">2025-08-16 19:04:25 - INFO -   📄 文档 6 (页码: 3): <span class="string">&#x27;Another important aspect of the protocol is that MQTT is  extremely easy to implement on the client side. Ease of use  w...&#x27;</span></span><br><span class="line">2025-08-16 19:04:25 - INFO -   📄 文档 7 (页码: 8): <span class="string">&#x27;established, clients can publish messages to topics  or subscribe to topics to receive messages from other  clients. • K...&#x27;</span></span><br><span class="line">2025-08-16 19:04:25 - INFO -   📄 文档 8 (页码: 20): <span class="string">&#x27;IoT devices. The foundation of this communication is  the MQTT connection, which enables devices to securely  and reliab...&#x27;</span></span><br><span class="line">2025-08-16 19:04:25 - INFO -   📄 文档 9 (页码: 69): <span class="string">&#x27;and brokers. Its Keep Alive mechanism minimizes energy and  bandwidth usage, enabling users to establish cost-effective,...&#x27;</span></span><br><span class="line">2025-08-16 19:04:25 - INFO -   📄 文档 10 (页码: 3): <span class="string">&#x27;MQTT uses a binary message format for communication between clients and servers (brokers). This is in contrast to other ...&#x27;</span></span><br><span class="line">2025-08-16 19:04:27 - INFO - HTTP Request: POST https://api.chatanywhere.tech/chat/completions <span class="string">&quot;HTTP/1.1 200 OK&quot;</span></span><br><span class="line">2025-08-16 19:04:27 - INFO - ✅ 流式传输完成</span><br><span class="line">2025-08-16 19:04:48 - INFO - 💬 收到用户新问题: <span class="string">&#x27;mqtt 有什么优点？&#x27;</span></span><br><span class="line">2025-08-16 19:04:48 - INFO - ✍️ 开始向用户流式传输回答...</span><br><span class="line">2025-08-16 19:04:48 - INFO - HTTP Request: POST https://api.chatanywhere.tech/embeddings <span class="string">&quot;HTTP/1.1 200 OK&quot;</span></span><br><span class="line">2025-08-16 19:04:48 - INFO - 🔍 向量检索完成，找到 10 个相关文档:</span><br><span class="line">2025-08-16 19:04:48 - INFO -   📄 文档 1 (页码: 3): <span class="string">&#x27;Another important aspect of the protocol is that MQTT is  extremely easy to implement on the client side. Ease of use  w...&#x27;</span></span><br><span class="line">2025-08-16 19:04:48 - INFO -   📄 文档 2 (页码: 56): <span class="string">&#x27;protocol more robust and efficient. Who Needs More Client Feedback While Using  MQTT? Over the years, MQTT has become a ...&#x27;</span></span><br><span class="line">2025-08-16 19:04:48 - INFO -   📄 文档 3 (页码: 51): <span class="string">&#x27;IoT Standard With its rich feature set, MQTT 5 has cemented its place  as the go-to choice for diverse IoT use cases, su...&#x27;</span></span><br><span class="line">2025-08-16 19:04:48 - INFO -   📄 文档 4 (页码: 50): <span class="string">&#x27;1. Better Error Handling for More Robust Systems 2. More Scalability for Cloud Native Computing 3. Greater Flexibility a...&#x27;</span></span><br><span class="line">2025-08-16 19:04:48 - INFO -   📄 文档 5 (页码: 51): <span class="string">&#x27;firmware version of the device platform can be added to the  message header, facilitating analysis and processing by the...&#x27;</span></span><br><span class="line">2025-08-16 19:04:48 - INFO -   📄 文档 6 (页码: 50): <span class="string">&#x27;delivered within this time frame, it’s automatically deleted. This  feature is particularly useful in ensuring that netw...&#x27;</span></span><br><span class="line">2025-08-16 19:04:48 - INFO -   📄 文档 7 (页码: 6): <span class="string">&#x27;communication participants all endure in this latest  version. However, several foundational mechanics have  been added ...&#x27;</span></span><br><span class="line">2025-08-16 19:04:48 - INFO -   📄 文档 8 (页码: 3): <span class="string">&#x27;supports persistent sessions between devices and  servers, enhancing message reliability by ensuring  that messages are ...&#x27;</span></span><br><span class="line">2025-08-16 19:04:48 - INFO -   📄 文档 9 (页码: 2): <span class="string">&#x27;Chapter 1: Introduction to MQTT MQTT is a lightweight messaging protocol originally designed for communication in constr...&#x27;</span></span><br><span class="line">2025-08-16 19:04:48 - INFO -   📄 文档 10 (页码: 45): <span class="string">&#x27;objectives for MQTT 5, aimed at enhancing scalability,  formalizing common patterns such as capability discovery and  re...&#x27;</span></span><br><span class="line">2025-08-16 19:04:53 - INFO - HTTP Request: POST https://api.chatanywhere.tech/chat/completions <span class="string">&quot;HTTP/1.1 200 OK&quot;</span></span><br><span class="line">2025-08-16 19:04:54 - INFO - ✅ 流式传输完成</span><br></pre></td></tr></table></figure>

<p>可以看到，回答过程中确实检索了向量数据库。</p>
<p>到此一个完整RAG项目就完成了！</p>
<p>🎉🎉🎉</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://penggehero.github.io/2025/08/14/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3mcp%E5%8D%8F%E8%AE%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="penggewu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="云泽的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/08/14/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3mcp%E5%8D%8F%E8%AE%AE/" class="post-title-link" itemprop="url">深入了解mcp协议</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-08-14 15:18:11" itemprop="dateCreated datePublished" datetime="2025-08-14T15:18:11+08:00">2025-08-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-08-15 10:10:23" itemprop="dateModified" datetime="2025-08-15T10:10:23+08:00">2025-08-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h1 id="1-MCP技术"><a href="#1-MCP技术" class="headerlink" title="1. MCP技术"></a>1. MCP技术</h1><h2 id="1-1-MCP是什么"><a href="#1-1-MCP是什么" class="headerlink" title="1.1 MCP是什么"></a>1.1 MCP是什么</h2><p>MCP （Model Context Protocol，模型上下文协议）是一个标准化协议，定义了应用程序和 AI 模型之间交换上下文信息的方式。这使得开发者能够以一致的方式将各种数据源、工具和功能连接到 AI 模型（一个中间协议层），就像 USB-C 让不同设备能够通过相同的接口连接一样。MCP 的目标是<strong>创建一个通用标准，使 AI 应用程序的开发和集成变得更加简单和统一</strong>。</p>
<p>MCP是由人工智能公司 <strong>Anthropic</strong> 于 <strong>2024 年 11 月 24 日</strong>正式发布并开源的协议标准。Anthropic 公司是由前 OpenAI 核心人员成立的人工智能公司，其发布的 Claude 系列模型是为数较少的可以和 GPT 系列抗衡的模型。</p>
<p><img src="/2025/08/14/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3mcp%E5%8D%8F%E8%AE%AE/640.gif" alt="图片"></p>
<h2 id="1-2-为什么需要-MCP"><a href="#1-2-为什么需要-MCP" class="headerlink" title="1.2 为什么需要 MCP"></a>1.2 为什么需要 MCP</h2><p>MCP 协议旨在解决大型语言模型（LLM）与外部数据源、工具间的集成难题，被比喻为“AI应用的USB-C接口“。通过标准化通信协议，将传统的“M×N集成问题”（即多个模型与多个数据源的点对点连接）转化为“M+N模式”，大幅降低开发成本。</p>
<p><img src="/2025/08/14/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3mcp%E5%8D%8F%E8%AE%AE/640-1755156942268-60.webp" alt="图片"></p>
<p>在 MCP 协议没有推出之前：</p>
<ol>
<li>智能体开发平台需要单独的插件配置和插件执行模型，以屏蔽不通工具之间的协议差异，提供统一的接口给 Agent 使用；</li>
<li>开发者如果要增加自定义的工具，需要按照平台规定的 http 协议实现工具。并且不同的平台之间的协议可能不同；</li>
<li>“M×N 问题”：每新增一个工具或模型，需重新开发全套接口，导致开发成本激增、系统脆弱；</li>
<li>功能割裂：AI 模型无法跨工具协作（如同时操作 Excel 和数据库），用户需手动切换平台。</li>
</ol>
<p>没有标准，整个行业生态很难有大的发展，所以 MCP 作为一种标准的出现，是 AI 发展的必然需求。</p>
<p>总结：MCP 如何重塑 AI 范式：</p>
<p><img src="/2025/08/14/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3mcp%E5%8D%8F%E8%AE%AE/640-1755156942268-61.webp" alt="图片"></p>
<h2 id="1-3-MPC核心组件"><a href="#1-3-MPC核心组件" class="headerlink" title="1.3 MPC核心组件"></a>1.3 MPC核心组件</h2><p>如上图所示，在MCP架构体系中，包含MCP Server、MCP Client和MCP Host几个核心组件，及组件间交互协议。</p>
<h3 id="1-3-1-MCP-Server"><a href="#1-3-1-MCP-Server" class="headerlink" title="1.3.1 MCP Server"></a>1.3.1 MCP Server</h3><p>MCP Server是一个通过MCP协议实现对外提供服务的轻量级应用，它对外提供工具执行、资源访问、预定义Prompt等一系列资源。</p>
<ul>
<li>资源（Resources）：类似文件的数据，可以被客户端读取，如 API 响应或文件内容</li>
<li>工具（Tools）：可以被 LLM 调用的函数 </li>
<li>提示（Prompts）：预先编写的模板，帮助用户完成特定任务</li>
</ul>
<p>下面是一个<a target="_blank" rel="noopener" href="https://github.com/modelcontextprotocol/servers/tree/main/src/filesystem">文件系统操作</a>的MCP Server示例，它提供了对文件、目录的读写操作。</p>
<p><img src="/2025/08/14/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3mcp%E5%8D%8F%E8%AE%AE/640-1755156279646-3.webp" alt="图片"></p>
<h3 id="1-3-2-MCP-Client"><a href="#1-3-2-MCP-Client" class="headerlink" title="1.3.2 MCP Client"></a>1.3.2 MCP Client</h3><p>在Host应用内部，MCP Client 与 MCP server 保持 1:1 的连接。MCP Client 充当 LLM 和 MCP Server 之间的桥梁。简单理解就是MCP Client SDK，用于实现Host应用使其能够与MCP Server交互。</p>
<h3 id="1-3-3-MCP-Host"><a href="#1-3-3-MCP-Host" class="headerlink" title="1.3.3 MCP Host"></a>1.3.3 MCP Host</h3><p>发起请求的 LLM 应用程序（例如 Claude Desktop、IDE 或 AI 工具）。通常像Claude Desktop 和Cursor这类智能助手应用和IDE，它们都是MCP Host应用，通过MCP client来连接某个MCP Server，并调用其提供的工具。</p>
<p>另外值得注意的是，<strong>运行MCP Host应用所在的主机也属于MCP Host的一部分，主机的文件系统、浏览器等都可能成为MCP Server在运行时操作的对象。</strong></p>
<h2 id="1-4-通信协议"><a href="#1-4-通信协议" class="headerlink" title="1.4 通信协议"></a>1.4 通信协议</h2><p>MCP采用JSON-RPC来编码消息，在Sever和Client之间通过标准输入输出和Streamable HTTP进行消息交换。</p>
<h3 id="1-4-1-Standard-Input-Output-stdio"><a href="#1-4-1-Standard-Input-Output-stdio" class="headerlink" title="1.4.1 Standard Input&#x2F;Output (stdio)"></a>1.4.1 Standard Input&#x2F;Output (stdio)</h3><p>采用标准输入&#x2F;输出流进行传输，适用于在同一台机器上运行的客户端和服务器之间的通信。</p>
<p><strong>Server</strong></p>
<p><img src="/2025/08/14/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3mcp%E5%8D%8F%E8%AE%AE/640-1755156534813-6.webp" alt="图片"></p>
<p><strong>Client</strong></p>
<p><img src="/2025/08/14/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3mcp%E5%8D%8F%E8%AE%AE/640-1755156534814-7.webp" alt="图片"></p>
<h3 id="1-4-2-Server-Sent-Events-SSE"><a href="#1-4-2-Server-Sent-Events-SSE" class="headerlink" title="1.4.2 Server-Sent Events (SSE)"></a>1.4.2 Server-Sent Events (SSE)</h3><p>远程通信**：**利用 SSE 与 HTTP 结合，实现跨网络的实时数据传输，适用于需要访问远程资源或分布式部署的场景。</p>
<p><strong>Server</strong></p>
<p><img src="/2025/08/14/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3mcp%E5%8D%8F%E8%AE%AE/640-1755156534814-8.webp" alt="图片"></p>
<p><strong>Client</strong></p>
<p><img src="/2025/08/14/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3mcp%E5%8D%8F%E8%AE%AE/640-1755156534814-9.webp" alt="图片"></p>
<h3 id="1-4-3-Streamable-HTTP"><a href="#1-4-3-Streamable-HTTP" class="headerlink" title="1.4.3 Streamable HTTP"></a>1.4.3 Streamable HTTP</h3><p>2025 年 3 月 26 日，MCP 引入了一项关键更新：用 Streamable HTTP 替代原先的 HTTP + SSE 作为默认传输方式。<br>这一变更在解决原有方案中连接不可恢复、服务端长连接压力大等问题的同时，依然保留了 SSE 带来的流式响应优势。</p>
<h4 id="HTTP-SSE-的缺陷"><a href="#HTTP-SSE-的缺陷" class="headerlink" title="HTTP + SSE 的缺陷"></a><strong>HTTP + SSE 的缺陷</strong></h4><p>远程 <code>MCP</code> 通过 <code>HTTP + SSE</code> 的传输方式工作，存在以下问题，这也是它所被替换的根本原因：</p>
<ul>
<li><p>不支持恢复连接</p>
</li>
<li><p>要求服务器保持高可用的长连接</p>
</li>
<li><p>服务器只能通过 <code>SSE</code> 发送消息</p>
</li>
</ul>
<h4 id="不支持恢复连接"><a href="#不支持恢复连接" class="headerlink" title="不支持恢复连接"></a><strong>不支持恢复连接</strong></h4><p>如果客户端和服务器之间的 <code>SSE</code> 连接中断了，就无法 “从端点继续”，只能重新开始新的连接，之前的上下文可能会丢失。</p>
<h4 id="要求服务器保持高可用的长连接"><a href="#要求服务器保持高可用的长连接" class="headerlink" title="要求服务器保持高可用的长连接"></a><strong>要求服务器保持高可用的长连接</strong></h4><p>服务器必须一直保持一个稳定、不中断的 <code>SSE</code> 长连接，否则通信就中断。</p>
<h4 id="服务器只能通过-SSE-发送消息"><a href="#服务器只能通过-SSE-发送消息" class="headerlink" title="服务器只能通过 SSE 发送消息"></a><strong>服务器只能通过 <code>SSE</code> 发送消息</strong></h4><p>服务器无法在已有的请求之外，主动地发送消息给客户端，除了通过专门的 &#x2F;sse 通道。换句话说，它是“单向被动响应”，而不是“任意时机推送”。</p>
<h4 id="Streamable-HTTP"><a href="#Streamable-HTTP" class="headerlink" title="Streamable HTTP"></a>Streamable HTTP</h4><p><code>Streamable HTTP</code> 并不是传统意义上的 <strong>流式 HTTP</strong>（<code>Streaming HTTP</code>），它指的是一种 <strong>兼具以下特性的传输机制</strong>：</p>
<ul>
<li>以普通 <code>HTTP</code> 请求为基础，客户端用 <code>POST/GET</code> 发请求；</li>
<li>服务器可选地将响应升级为 <code>SSE</code> 流，实现 <strong>流式传输</strong> 的能力（当需要时）；</li>
<li>去中心化、无强制要求持续连接，支持 <code>stateless</code> 模式；</li>
<li>客户端和服务端之间的消息传输更加灵活，比如同一个 <code>/message</code> 端点可用于发起请求和接收 <code>SSE</code> 流；</li>
<li>不再需要单独的 <code>/sse</code> 端点，一切通过统一的 <code>/message</code> 协议层处理。</li>
</ul>
<h4 id="Streamable-HTTP-的优势"><a href="#Streamable-HTTP-的优势" class="headerlink" title="Streamable HTTP 的优势"></a>Streamable HTTP 的优势</h4><ul>
<li>支持无状态服务器：无需维持高可用的长连接</li>
<li>纯 <code>HTTP</code> 实现：<code>MCP</code> 可在纯 <code>HTTP</code> 服务中实现，无需 <code>SSE</code> 支持</li>
<li>兼容基础设施：因为 “只是 HTTP”，可以与中间件和现有基础设施良好集成</li>
<li>向后兼容：是当前 <code>HTTP+SSE</code> 传输方式的渐进式改进</li>
<li>灵活的传输方式：服务器可选择是否使用 <code>SSE</code> 进行流式响应</li>
</ul>
<h4 id="从-HTTP-SSE-到-Streamable-HTTP-的变化"><a href="#从-HTTP-SSE-到-Streamable-HTTP-的变化" class="headerlink" title="从 HTTP+SSE 到 Streamable HTTP 的变化"></a>从 HTTP+SSE 到 Streamable HTTP 的变化</h4><ul>
<li>移除了 <code>/sse</code> 端点</li>
<li>所有客户端 → 服务端的消息都通过 <code>/message</code>（或类似端点）发送</li>
<li>所有客户端 → 服务端的请求都可以被服务器升级为 <code>SSE</code>，以发送通知或请求</li>
<li>服务器可以选择建立会话 <code>ID</code> 以维护状态</li>
<li>客户端可以通过对 <code>/message</code> 发送一个空的 <code>GET</code> 请求启动 <code>SSE</code> 流</li>
<li>该方法兼容旧版本的实现，并允许服务器保持无状态（如果有需要）</li>
</ul>
<h4 id="为什么不用-WebSocket？"><a href="#为什么不用-WebSocket？" class="headerlink" title="为什么不用 WebSocket？"></a>为什么不用 WebSocket？</h4><p>官方团队曾认真探讨过是否应该将 <code>WebSocket</code> 作为远程通信的主要方式，并尝试在其基础上实现断线重连等功能。但最终决定暂时不采用 <code>WebSocket</code>，主要原因如下：</p>
<ul>
<li>想要以 <code>RPC</code> 风格使用 <code>MCP</code>（例如构建一个无状态、只暴露基础工具的服务）时，如果每次调用都依赖 <code>WebSocket</code>，将引入不必要的维护和网络开销。</li>
<li>在浏览器环境中，<code>WebSocket</code> 连接无法像普通 <code>HTTP</code> 请求那样附加请求头（比如 <code>Authorization</code>），而且不同于 <code>SSE</code>，<code>WebSocket</code> 在浏览器中也无法由第三方库完全“模拟”实现。</li>
<li>只有 <code>GET</code> 请求可以自动升级为 <code>WebSocket</code>，而 <code>POST</code> 等其他 <code>HTTP</code> 方法并不支持直接升级。这就意味着如果要让 <code>POST</code> 请求使用 <code>WebSocket</code>，需要一个额外的 <strong>两步升级</strong> 过程，增加了实现的复杂度和延迟。</li>
<li>也避免在 <code>MCP</code> 规范中增加 <code>WebSocket</code> 的可选支持，以减少客户端与服务器间可能的兼容性组合问题（但不阻止社区自己扩展非官方的 <code>WebSocket</code> 实现）</li>
<li>官方也有意避免在 <code>MCP</code> 协议中引入 <code>WebSocket</code> 作为官方选项，以避免客户端和服务器之间因传输方式组合过多而导致的兼容性问题（当然，这并不妨碍用户基于 <code>WebSocket</code> 自行实现非官方版本）。</li>
</ul>
<p>当然，如果将来实践中发现 <code>SSE</code> 并不理想，官方仍会考虑重新评估 <code>WebSocket</code> 的可能性。</p>
<h4 id="MCP-Server-示例"><a href="#MCP-Server-示例" class="headerlink" title="MCP Server 示例"></a>MCP Server 示例</h4><h4 id="无状态服务器（Stateless-Server）"><a href="#无状态服务器（Stateless-Server）" class="headerlink" title="无状态服务器（Stateless Server）"></a>无状态服务器（Stateless Server）</h4><p><code>Streamable HTTP</code> 支持构建完全无状态、无需保持长连接的服务器架构。</p>
<p>以一个仅提供大语言模型（<code>LLM</code>）工具的服务为例，不依赖其他高级功能，可以按以下方式实现：</p>
<ul>
<li>始终响应初始化请求，但无需持久化任何状态；</li>
<li>对所有传入的 <code>ToolListRequest</code>，直接返回一个标准的 <code>JSON-RPC</code> 响应；</li>
<li>对 <code>CallToolRequest</code>，执行对应工具，等待其完成后，将结果通过 <code>HTTP</code> 响应体以 <code>CallToolResponse</code> 的形式返回。</li>
</ul>
<h4 id="支持流式输出的无状态服务器（Stateless-Server-with-Streaming）"><a href="#支持流式输出的无状态服务器（Stateless-Server-with-Streaming）" class="headerlink" title="支持流式输出的无状态服务器（Stateless Server with Streaming）"></a>支持流式输出的无状态服务器（Stateless Server with Streaming）</h4><p>即使服务器完全无状态、且不支持长连接，也仍然可以利用此设计进行流式响应。</p>
<p>以工具调用时的进度反馈为例：</p>
<ul>
<li>当收到 <code>POST</code> 的 <code>CallToolRequest</code> 时，服务器通过响应头声明该响应将以 <code>SSE</code>（<code>Server-Sent Events</code>）格式返回；</li>
<li>启动工具执行逻辑；</li>
<li>在执行过程中，服务器可以通过 <code>SSE</code> 向客户端持续发送多个 <code>ProgressNotification</code>（进度通知）；</li>
<li>执行完成后，服务器通过 <code>SSE</code> 发送最终的 <code>CallToolResponse</code>；</li>
<li>最后，服务器关闭 <code>SSE</code> 流，整个交互完成。</li>
</ul>
<h4 id="有状态服务器（Stateful-Server）"><a href="#有状态服务器（Stateful-Server）" class="headerlink" title="有状态服务器（Stateful Server）"></a>有状态服务器（Stateful Server）</h4><p>对于需要维护客户端会话的服务器，整体架构可以保持与 <code>http+SSE</code> 的实现类似。</p>
<p>主要区别在于：服务器需要为客户端生成唯一的会话 <code>ID</code>，并要求客户端在后续所有请求中携带该 <code>ID</code>。</p>
<p>服务器可以利用会话 <code>ID</code> 实现 <strong>粘性路由</strong> 或消息总线中的会话定位。例如，在水平扩展的部署中（部署多台相同的 <code>mcp server</code>），某个 <code>POST</code> 请求可能被路由到任意一个节点，此时可以通过 <code>Redis</code> 等中间件将请求路由到关联的会话上下文，确保状态一致性。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p><code>Streamable HTTP</code> 是对 <code>MCP</code> 协议传输层的一次重要优化。它在保留原有 <code>HTTP + SSE</code> 模式优势的基础上，解决了连接不可恢复、长连接负担重、传输不灵活等问题，带来了更高的可用性与灵活性。</p>
<h3 id="1-4-4-模式总结"><a href="#1-4-4-模式总结" class="headerlink" title="1.4.4 模式总结"></a>1.4.4 模式总结</h3><p>MCP支持了三种通信方式：<strong>Stdio</strong>、<strong>SSE</strong>、<strong>Streamable HTTP</strong></p>
<table>
<thead>
<tr>
<th>特性</th>
<th>Stdio</th>
<th>SSE</th>
<th><strong>Streamable HTTP</strong></th>
</tr>
</thead>
<tbody><tr>
<td>通信方向</td>
<td>双向（仅限本地）</td>
<td>单向（服务器到客户端）</td>
<td>双向（支持复杂交互）</td>
</tr>
<tr>
<td>使用场景</td>
<td>本地进程间通信</td>
<td>实时数据推送</td>
<td>跨服务、分布式系统、高并发场景</td>
</tr>
<tr>
<td>支持并发连接数</td>
<td>低</td>
<td>中等</td>
<td>高（适合大规模并发）</td>
</tr>
<tr>
<td>适应性</td>
<td>局限于本地环境</td>
<td>支持浏览器，但单向通信</td>
<td>高灵活性，支持流式数据与批处理</td>
</tr>
<tr>
<td>协议基础</td>
<td>标准输入输出（stdin&#x2F;stdout）</td>
<td>HTTP协议（Server-Sent Events）</td>
<td>HTTP协议（双向流式传输）</td>
</tr>
</tbody></table>
<h2 id="1-5-MCP协议带来的改变"><a href="#1-5-MCP协议带来的改变" class="headerlink" title="1.5 MCP协议带来的改变"></a>1.5 MCP协议带来的改变</h2><p>在使用MCP协议之前，开发智能应用的开发者（如Cursor）如果要使用外部服务的能力，每个应用开发需要各自开发对接外部服务的程序来实现能力集成。使用MCP后，服务提供者（如Slack、Google Drive）会以MCP标准协议对外提供MCP Server，服务的工具和资源将统一汇聚到市场上，应用以标准化的接口对接资源和工具，从而提升资源和工具的标准化和复用率。</p>
<p><img src="/2025/08/14/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3mcp%E5%8D%8F%E8%AE%AE/640-1755156534814-10.gif" alt="图片"></p>
<h2 id="1-6-MCP-的发展情况"><a href="#1-6-MCP-的发展情况" class="headerlink" title="1.6 MCP 的发展情况"></a>1.6 <strong>MCP 的发展情况</strong></h2><p>MCP 自 **2024 年 11 月 24 日 发布以来，<strong>OpenAI、Google、微软、腾讯、阿里、百度等头部企业纷纷接入 MCP，推动其成为</strong>事实性行业标准。<strong>并且相继出现了 <a target="_blank" rel="noopener" href="https://mcp.so/">mcp.so</a> 、<a target="_blank" rel="noopener" href="https://mcpmarket.cn/">mcpmarket</a> 等超大体量的 MCP 服务提供商。国内的头部企业也相继加入 MCP 服务商的竞争中，百度发布了<a target="_blank" rel="noopener" href="https://sai.baidu.com/mcp?ref=openi.cn">千帆 MCP 广场</a></strong>，**阿里发布了<a target="_blank" rel="noopener" href="https://www.modelscope.cn/mcp?category=research-and-data&page=1">魔搭 MCP 广场</a>。在如此庞大的 MCP 市场下，开发者基本不需要开发自己的插件，直接使用 MCP 服务商的插件就可以直接开发大量 Agent。</p>
<p>同时很多头部企业，开始把自身原有的 API 业务开发成封装成 MCP 服务对外提供。比如</p>
<ol>
<li>GitHub Copilot 提供 MCP 的方式生成代码；</li>
<li>AWS 2025 年 6月推出开源工具 Amazon Serverless MCP Server**，**支持 Agent 直接操作云上资源，进行服务编排。</li>
<li>腾讯地图、高德地图、百度地图均发布 MCP Server，支持在 Agent 中使用丰富的地图资源。</li>
<li>腾讯云COS、阿里云OSS、百度网盘均已支持 MCP 协议的接入。</li>
</ol>
<p><strong>未来趋势</strong>：</p>
<ul>
<li><strong>与 AIOS 融合</strong>：MCP 正成为 AI 操作系统（如华为鸿蒙 HMAF）的核心组件，实现跨设备智能调度；</li>
<li><strong>生态挑战</strong>：大厂通过 MCP 构建“闭环生态”（如阿里集成高德地图），可能引发协议割裂，需推动跨平台协作标准。</li>
</ul>
<p>MCP 不仅是技术协议，更是 <strong>AI 生产力革命的基石</strong>——它让模型真正融入现实世界，成为人类工作的无缝延伸。</p>
<h1 id="2-MCP执行细节"><a href="#2-MCP执行细节" class="headerlink" title="2. MCP执行细节"></a>2. MCP执行细节</h1><p>当用户在Host应用中输入一个Query后，Host应用是如何在LLM, MCP Client和MCP Server之间交互的呢？下图描述了Query请求处理的完整流程：</p>
<p><img src="/2025/08/14/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3mcp%E5%8D%8F%E8%AE%AE/640-1755156534814-11.webp" alt="图片"></p>
<ol>
<li>MCP Client首先从MCP Server获取可用的工具列表；</li>
<li>将用户的Query连同工具描述通过Function Calling一起发送给 LLM；</li>
<li>LLM 决定是否需要使用工具以及使用哪些工具；</li>
<li>如果需要使用工具，MCP Client会通过 MCP Server执行相应的工具调用；</li>
<li>工具调用的结果会被发送回LLM；</li>
<li>LLM基于所有信息生成自然语言响应；</li>
<li>最后将响应展示给用户。</li>
</ol>
<h2 id="2-1-Host调用LLM"><a href="#2-1-Host调用LLM" class="headerlink" title="2.1 Host调用LLM"></a>2.1 Host调用LLM</h2><p>Host将用户Query和Tools一起发给LLM。</p>
<p><img src="/2025/08/14/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3mcp%E5%8D%8F%E8%AE%AE/640-1755156534814-12.webp" alt="图片"></p>
<h2 id="2-2-Client调用MCP-Server"><a href="#2-2-Client调用MCP-Server" class="headerlink" title="2.2 Client调用MCP Server"></a>2.2 Client调用MCP Server</h2><p>大模型通过Query和提供的工具进行推理，确定完成用户任务需要执行的工具，如果LLM返回结果中如果需要执行tool_calls，则在会话中调用MCP Server。</p>
<p><img src="/2025/08/14/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3mcp%E5%8D%8F%E8%AE%AE/640-1755156534814-13.webp" alt="图片"></p>
<h2 id="2-3-返回最终处理结果"><a href="#2-3-返回最终处理结果" class="headerlink" title="2.3 返回最终处理结果"></a>2.3 返回最终处理结果</h2><p>Host将MCP Server执行的结果和Message一并发给LLM，如果不需要再调用其他工具，那么调用LLM做最后润色后返回最终结果。</p>
<p><img src="/2025/08/14/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3mcp%E5%8D%8F%E8%AE%AE/640-1755156534814-14.webp" alt="图片"></p>
<h1 id="3-Agent-Function-Calling与MCP"><a href="#3-Agent-Function-Calling与MCP" class="headerlink" title="3. Agent, Function Calling与MCP"></a>3. Agent, Function Calling与MCP</h1><h2 id="3-1-Agent"><a href="#3-1-Agent" class="headerlink" title="3.1 Agent"></a>3.1 Agent</h2><p>LLM Agents是专为生成需要推理和执行任务的高级人工智能系统。它们能够通过推理思考、回忆过往对话，并通过调用外部工具，根据上下文和用户要求动态规划和执行任务，最终自动完成用户问题。</p>
<p><img src="/2025/08/14/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3mcp%E5%8D%8F%E8%AE%AE/640-1755156534814-15.webp" alt="图片"></p>
<p>形象来讲，LLM是一个强大的文本处理大脑，但其本身不具备执行任务的能力，因此需要借助工具，使其能够调用外部工具和服务，从而代理人工完成复杂任务的规划和执行。</p>
<h2 id="3-2-Function-Calling"><a href="#3-2-Function-Calling" class="headerlink" title="3.2 Function Calling"></a>3.2 Function Calling</h2><p><strong>Function Calling（函数调用）</strong> 是大型语言模型的关键技术。前面有提到过 <strong>RAG技术</strong> 是为了解决模型无法和外接数据交互的问题，但是 <strong>RAG</strong> 的局限在于只赋予了模型检索数据的能力，而 <strong>Function Calling</strong> 允许模型理解用户请求中的潜在意图，并自动生成结构化参数来调用外部<strong>任何</strong>函数&#x2F;工具，从而突破纯文本生成的限制，实现与真实世界的交互，比如可以调用查天气、发邮件、数学计算等工具。</p>
<p>Function Call 模型最早由 OpenAI 在 2023 年 6 月 13 正式提出并发布，首次在 GPT-4 模型上实现了 Function Calling 能力。OpenAI 作为大语言模型的领路人，其发布的模型的 API 协议都会行业标准，后面国内外新发布模型都会按照 OpenAI 的协议作为标准实现。截止目前，支持 Fucntion Calling 能力的主流模型如下表：</p>
<p><img src="/2025/08/14/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3mcp%E5%8D%8F%E8%AE%AE/640-1755156766459-57.webp" alt="图片"></p>
<p>除了上面的知名度高的模型，还有一些其他开源或闭源模型也支持了 Fucntion Calling 能力，但是截止目前为止，GPT-4 仍然是公认的 Fucntion Calling 能力最强的模型。</p>
<p><a target="_blank" rel="noopener" href="https://platform.openai.com/docs/guides/function-calling">OpenAI最初通过Function Calling</a>来给大模型装上“手脚”，让其能够调用外部工具和服务，从而代理人工完成复杂任务的规划和执行。</p>
<p>通过精妙的Prompt设计，可以让模型根据用户Query和可用的Function描述来进行任务分解和推理，从而选择合适的工具进行执行，并通过多次迭代完成用户任务。</p>
<p><img src="/2025/08/14/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3mcp%E5%8D%8F%E8%AE%AE/640-1755156534815-16.webp" alt="图片"></p>
<h2 id="3-3-MCP"><a href="#3-3-MCP" class="headerlink" title="3.3 MCP"></a>3.3 MCP</h2><p>Function Calling的问题显而易见，对于Function的描述各厂商存在差异，模型迁移成本高；另外Fucntion Call存在效果不稳定、容错性低等问题。而MCP标准化了Agent与外部资源和工具交互的接口、协议及实现。从而为构建更为健壮的Agent应用和推动生态的协作起到了关键作用。</p>
<h2 id="3-4-对比"><a href="#3-4-对比" class="headerlink" title="3.4 对比"></a>3.4 对比</h2><p><img src="/2025/08/14/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3mcp%E5%8D%8F%E8%AE%AE/640-1755156534815-17.png" alt="图片"></p>
<h1 id="4-MCP技术生态"><a href="#4-MCP技术生态" class="headerlink" title="4. MCP技术生态"></a>4. MCP技术生态</h1><p>随着<a target="_blank" rel="noopener" href="https://manus.im/">Manus</a>的发布，MCP协议得以快速普及，MCP应用、MCP Server服务以及MCP应用市场的蓬勃发展，使得MCP技术生态迅速繁荣起来。</p>
<p><img src="/2025/08/14/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3mcp%E5%8D%8F%E8%AE%AE/640-1755156534815-18.webp" alt="图片"></p>
<h2 id="4-1-MCP-Server-Marketplace"><a href="#4-1-MCP-Server-Marketplace" class="headerlink" title="4.1 MCP Server Marketplace"></a>4.1 MCP Server Marketplace</h2><p>几个主要的MCP Server Marketplace上Host的MCP Server数量在短短20天内（2025&#x2F;3&#x2F;28 - 2025&#x2F;4&#x2F;18）有了大幅的增长。这进一步说明了其技术生态的繁荣程度。</p>
<table>
<thead>
<tr>
<th align="left"><strong>MCP Marketplace</strong></th>
<th align="left">*<em>发布MCP Server数量*</em>*<em>3&#x2F;28 - 4&#x2F;18</em>*</th>
<th align="left"><strong>类型</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a target="_blank" rel="noopener" href="https://smithery.ai/">Smithery</a></td>
<td align="left">2978 - 4792</td>
<td align="left">综合MCP资源</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://mcp.so/">mcp.so</a></td>
<td align="left">4831 - 8990</td>
<td align="left">综合MCP资源</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://www.pulsemcp.com/">PulseMCP</a></td>
<td align="left">3189 - 3864</td>
<td align="left">综合MCP资源</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://cursor.directory/">Cursor Directory</a></td>
<td align="left">1800+</td>
<td align="left">Cursor生态，专注代码开发场景</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://glama.ai/mcp/servers">Glama</a></td>
<td align="left">3390 - 3640</td>
<td align="left">跨模型协作的场景</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://github.com/modelcontextprotocol/servers">modelcontextprotocol</a></td>
<td align="left">331</td>
<td align="left">Anthropic官方热门 MCP Server 源码</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://cline.bot/mcp-marketplace">Cline</a></td>
<td align="left">90</td>
<td align="left">VSCode插件市场</td>
</tr>
</tbody></table>
<h2 id="4-2-MCP应用程序"><a href="#4-2-MCP应用程序" class="headerlink" title="4.2 MCP应用程序"></a>4.2 MCP应用程序</h2><p>我们可以在<a target="_blank" rel="noopener" href="https://www.pulsemcp.com/clients">PulseMCP</a>上看到200多个应用支持了MCP，你可以在上面找到适合自己的MCP应用。</p>
<p><img src="/2025/08/14/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3mcp%E5%8D%8F%E8%AE%AE/640-1755156534815-19.png" alt="图片"></p>
<h2 id="4-3-MCP-Server"><a href="#4-3-MCP-Server" class="headerlink" title="4.3 MCP Server"></a>4.3 MCP Server</h2><p>以<a target="_blank" rel="noopener" href="https://mcp.so/categories">mcp.so</a>上的MCP Server目录为例，我们看到MCP Server的范围已经涵盖数据、研究、云平台、数据库、Chatbot、文件系统、自动化等多个领域。</p>
<p><img src="/2025/08/14/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3mcp%E5%8D%8F%E8%AE%AE/640-1755156534815-20.webp" alt="图片"></p>
<p>除此之外，在开发者支持方面，除了官方的SDK以外，<a target="_blank" rel="noopener" href="https://github.com/jlowin/fastmcp">FastMCP</a>、<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-ai/reference/api/mcp/mcp-overview.html">Spring AI</a>、<a target="_blank" rel="noopener" href="https://github.com/lastmile-ai/mcp-agent">mcp-agent</a>等技术框架也进一步降低了MCP的开发成本。</p>
<h1 id="5-对MCP发展的思考"><a href="#5-对MCP发展的思考" class="headerlink" title="5. 对MCP发展的思考"></a>5. 对MCP发展的思考</h1><p>作为一个新兴的技术规范，我们应该以审慎而积极的态度来看待，以下是个人对MCP可能带来的变化和其局限的分析判断。</p>
<h2 id="5-1-MCP带来的变化"><a href="#5-1-MCP带来的变化" class="headerlink" title="5.1 MCP带来的变化"></a>5.1 MCP带来的变化</h2><p>正如WebService和WSDL定义了系统间服务调用的基本协议，推动了SOA架构的广泛发展，从此单应用系统逐渐发展成为多应用系统，企业内部的各个系统实现了数据交换和服务集成。REST轻量级服务风格进一步降低了数据传输中的Schema复杂度，而之后的微服务又使得服务进一步解耦和原子化，结合容器编排技术提升了服务的治理能力。任何一种技术和协议都是在不断迭代中进行发展、升级及迭代的。</p>
<p>在此，我们不妨大胆预测MCP带来的变化：</p>
<p><img src="/2025/08/14/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3mcp%E5%8D%8F%E8%AE%AE/640-1755156534815-21.webp" alt="图片"></p>
<p><strong>MCP OpenAPI化</strong></p>
<p>MCP将成为软件对外开放和集成的新协议，SaaS、应用服务将会以MCP方式提供对外服务，MCP将成为与OpenAPI类似的对外服务协议。</p>
<p><strong>应用交互重构</strong></p>
<p>重构应用形态，智能助手将以“搜索框”的形式成为各个应用的交互入口，支持语音及自然语言交换形式，完成复杂任务的执行。</p>
<p><strong>业务E2E自动化</strong></p>
<p>端到端理解用户意图、执行任务、容错处理将大大简化用户业务流程，一句话自动完成下单、售后、流程审批等操作将变得更为常见。</p>
<p><strong>生态开放协作</strong></p>
<p>支付、生活服务、内容服务等服务作为基础能力，实现你中有我、我中有你，从而更大限度拓展服务生态的协作开放。例如，一个个人助手可以完成调用获取好友列表、差旅申请、支付流程等操作，实现在一个应用中通过集成多个服务的MCP Server来完成复杂业务，前提是MCP授权及安全有保证，且MCP具有广泛的应用场景。</p>
<h2 id="5-2-技术限制"><a href="#5-2-技术限制" class="headerlink" title="5.2 技术限制"></a>5.2 技术限制</h2><p>当然，MCP还处于发展初期，不可避免存在很多问题及缺陷，具体表现在：</p>
<p><strong>应用范围受限</strong></p>
<p>MCP Server大部分以本地库方式执行，很大比例的MCP Server依赖于浏览器等外部工具，通常是以Desktop App + MCP方式执行，更适合个人Assistant。企业应用一般在云端执行，这在一定程度限制了MCP的应用。</p>
<p><strong>行业标准支持</strong></p>
<p>当前在数据连接和交互领域有众多标准在竞争，MCP协议只是其中之一，要想成为行业通用标准面临很大挑战。目前MCP主要依托Anthropic的Claude生态，缺少核心厂商的支持，但也看到像OpenAI，以及阿里、腾讯也在积极拥抱MCP。</p>
<p><strong>对协议本质的质疑</strong></p>
<p>MCP本质上更像是 FunctionCall与Proxy 的组合，在这个角度上来看，MCP只是对于Agent执行外部工具和访问外部资源做了规范，并未在更大范围内实现标准化。许多人质疑其是否能够称之为一个真正的协议。</p>
<p><strong>安全风险</strong></p>
<p>MCP Server本地部署，被Host使用后将直接获得Host OS的访问权限，不安全的MCP Server将可能成为漏洞跳板。此外，不可信的MCP Server通过各种<a target="_blank" rel="noopener" href="https://km.woa.com/articles/show/625688">攻击手段</a>也带来了诸多安全挑战。</p>
<p><img src="/2025/08/14/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3mcp%E5%8D%8F%E8%AE%AE/640-1755156534815-22.webp" alt="图片"></p>
<p>例如：开发一个 MCP Sever 用来实现加法操作，同时在其中放入恶意的 Prompt，要求 LLM 读取用户当前的工作路径。那么在其执行时就会读取用户工作目录和文件。</p>
<p>参考文章：</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiao987334176/p/18845151">https://www.cnblogs.com/xiao987334176/p/18845151</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/BPfVDSaCNFqe39NmtMHc3g">https://mp.weixin.qq.com/s/BPfVDSaCNFqe39NmtMHc3g</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/jTx_ktWeu5Ck8RDZ3b6iRw?click_id=20">https://mp.weixin.qq.com/s/jTx_ktWeu5Ck8RDZ3b6iRw?click_id=20</a></p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://penggehero.github.io/2025/08/07/golang-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8-MCP-%E5%A4%A7%E6%A8%A1%E5%9E%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%8D%8F%E8%AE%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="penggewu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="云泽的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/08/07/golang-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8-MCP-%E5%A4%A7%E6%A8%A1%E5%9E%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%8D%8F%E8%AE%AE/" class="post-title-link" itemprop="url">golang 快速入门 MCP(大模型上下文协议)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-08-07 18:42:44" itemprop="dateCreated datePublished" datetime="2025-08-07T18:42:44+08:00">2025-08-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-08-14 15:13:28" itemprop="dateModified" datetime="2025-08-14T15:13:28+08:00">2025-08-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h1 id="1-MCP-模型上下文协议-简介"><a href="#1-MCP-模型上下文协议-简介" class="headerlink" title="1.MCP 模型上下文协议 简介"></a>1.MCP 模型上下文协议 简介</h1><p>MCP 是一个开放协议，它标准化了应用程序向大型语言模型 (LLM) 提供上下文的方式。MCP 就像 AI 应用程序的 USB-C 端口一样。正如 USB-C 提供了一种标准化的方式将您的设备连接到各种外围设备和配件一样，MCP 也提供了一种标准化的方式将 AI 模型连接到不同的数据源和工具。MCP 使您能够在 LLM 之上构建代理和复杂的工作流，并将您的模型与世界连接起来。</p>
<p><img src="/2025/08/07/golang-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8-MCP-%E5%A4%A7%E6%A8%A1%E5%9E%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%8D%8F%E8%AE%AE/model-context-protocol-architecture.webp" alt="img"></p>
<p>MCP 提供：</p>
<ul>
<li><strong>越来越多的预建集成</strong>可供您的 LLM 直接插入</li>
<li>为 AI 应用程序构建自定义集成<strong>标准化方法</strong></li>
<li>每个人都可以自由实施和使用的<strong>开放协议</strong></li>
<li>在不同应用程序之间切换并随身携带上下文的<strong>灵活性</strong></li>
</ul>
<h1 id="2-go语言搭建获取城市天气的mcp-server"><a href="#2-go语言搭建获取城市天气的mcp-server" class="headerlink" title="2.go语言搭建获取城市天气的mcp server"></a>2.go语言搭建获取城市天气的mcp server</h1><p>整体流程如图所示:</p>
<pre class="mermaid">sequenceDiagram
    participant 用户
    participant LLM
    participant 城市编码mcp as 城市编码mcp
    participant 天气mcp as 天气mcp

    用户->>LLM: 提问城市的天气
    LLM->>城市编码mcp: 调用获取城市编码
    LLM->>天气mcp: 调用获取城市天气数据
    LLM->>用户: 输出城市的天气情况</pre>

<p><img src="/2025/08/07/golang-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8-MCP-%E5%A4%A7%E6%A8%A1%E5%9E%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%8D%8F%E8%AE%AE/image-20250807204019777.png" alt="image-20250807204019777"></p>
<h2 id="2-1-获取城市天气的api-接口"><a href="#2-1-获取城市天气的api-接口" class="headerlink" title="2.1 获取城市天气的api 接口"></a>2.1 获取城市天气的api 接口</h2><p>这里选取的高德平台的免费获取天气的api</p>
<p>api地址：<a target="_blank" rel="noopener" href="https://amap.apifox.cn/api-14675765">https://amap.apifox.cn/api-14675765</a></p>
<p><img src="/2025/08/07/golang-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8-MCP-%E5%A4%A7%E6%A8%A1%E5%9E%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%8D%8F%E8%AE%AE/image-20250807185716460.png" alt="image-20250807185716460"></p>
<p>代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;resty.dev/v3&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	weatherInfoUrl = <span class="string">&quot;https://restapi.amap.com/v3/weather/weatherInfo&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getWeatherInfo</span><span class="params">(cityCode <span class="type">string</span>)</span></span> (<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	client := resty.New()</span><br><span class="line">	<span class="keyword">defer</span> client.Close()</span><br><span class="line"></span><br><span class="line">	res, err := client.R().</span><br><span class="line">		EnableTrace().</span><br><span class="line">		Get(fmt.Sprintf(<span class="string">&quot;%s?city=%s&amp;key=%s&quot;</span>, weatherInfoUrl, cityCode, key))</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Println(err)</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;&quot;</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res.String(), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里api 接口传递的是城市编码，不是直接传入的城市名称，所以还需要城市名称转城市编码的接口。</p>
<h2 id="2-2-行政区域查询的接口"><a href="#2-2-行政区域查询的接口" class="headerlink" title="2.2 行政区域查询的接口"></a>2.2 行政区域查询的接口</h2><p>api地址： <a target="_blank" rel="noopener" href="https://lbs.amap.com/api/webservice/guide/api/district">https://lbs.amap.com/api/webservice/guide/api/district</a></p>
<p><img src="/2025/08/07/golang-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8-MCP-%E5%A4%A7%E6%A8%A1%E5%9E%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%8D%8F%E8%AE%AE/image-20250807191006828.png" alt="image-20250807191006828"></p>
<p>代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;resty.dev/v3&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	districtUrl = <span class="string">&quot;https://restapi.amap.com/v3/config/district?keywords=%s&amp;subdistrict=2&amp;key=%s&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getDistrict</span><span class="params">(str <span class="type">string</span>)</span></span> ([]<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	client := resty.New()</span><br><span class="line">	<span class="keyword">defer</span> client.Close()</span><br><span class="line">	res, err := client.R().</span><br><span class="line">		EnableTrace().</span><br><span class="line">		Get(fmt.Sprintf(districtUrl, str, key))</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Println(err)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> resp Response</span><br><span class="line">	err = json.Unmarshal(res.Bytes(), &amp;resp)</span><br><span class="line">	codes, err := GetCityCodes(res.Bytes())</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> codes, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Response struct</span></span><br><span class="line"><span class="keyword">type</span> Response <span class="keyword">struct</span> &#123;</span><br><span class="line">	Status     <span class="type">string</span> <span class="string">`json:&quot;status&quot;`</span></span><br><span class="line">	Info       <span class="type">string</span> <span class="string">`json:&quot;info&quot;`</span></span><br><span class="line">	Infocode   <span class="type">string</span> <span class="string">`json:&quot;infocode&quot;`</span></span><br><span class="line">	Count      <span class="type">string</span> <span class="string">`json:&quot;count&quot;`</span></span><br><span class="line">	Suggestion <span class="keyword">struct</span> &#123;</span><br><span class="line">		Keywords []<span class="keyword">interface</span>&#123;&#125; <span class="string">`json:&quot;keywords&quot;`</span></span><br><span class="line">		Cities   []<span class="keyword">interface</span>&#123;&#125; <span class="string">`json:&quot;cities&quot;`</span></span><br><span class="line">	&#125; <span class="string">`json:&quot;suggestion&quot;`</span></span><br><span class="line">	Districts []<span class="keyword">struct</span> &#123;</span><br><span class="line">		Citycode  <span class="type">string</span> <span class="string">`json:&quot;citycode&quot;`</span></span><br><span class="line">		Adcode    <span class="type">string</span> <span class="string">`json:&quot;adcode&quot;`</span></span><br><span class="line">		Name      <span class="type">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">		Center    <span class="type">string</span> <span class="string">`json:&quot;center&quot;`</span></span><br><span class="line">		Level     <span class="type">string</span> <span class="string">`json:&quot;level&quot;`</span></span><br><span class="line">		Districts []<span class="keyword">struct</span> &#123;</span><br><span class="line">			Citycode  <span class="type">string</span> <span class="string">`json:&quot;citycode&quot;`</span></span><br><span class="line">			Adcode    <span class="type">string</span> <span class="string">`json:&quot;adcode&quot;`</span></span><br><span class="line">			Name      <span class="type">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">			Center    <span class="type">string</span> <span class="string">`json:&quot;center&quot;`</span></span><br><span class="line">			Level     <span class="type">string</span> <span class="string">`json:&quot;level&quot;`</span></span><br><span class="line">			Districts []<span class="keyword">struct</span> &#123;</span><br><span class="line">				Citycode  <span class="type">string</span> <span class="string">`json:&quot;citycode&quot;`</span></span><br><span class="line">				Adcode    <span class="type">string</span> <span class="string">`json:&quot;adcode&quot;`</span></span><br><span class="line">				Name      <span class="type">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">				Center    <span class="type">string</span> <span class="string">`json:&quot;center&quot;`</span></span><br><span class="line">				Level     <span class="type">string</span> <span class="string">`json:&quot;level&quot;`</span></span><br><span class="line">				Districts []<span class="keyword">struct</span> &#123;</span><br><span class="line">					Citycode  <span class="type">string</span>        <span class="string">`json:&quot;citycode&quot;`</span></span><br><span class="line">					Adcode    <span class="type">string</span>        <span class="string">`json:&quot;adcode&quot;`</span></span><br><span class="line">					Name      <span class="type">string</span>        <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">					Center    <span class="type">string</span>        <span class="string">`json:&quot;center&quot;`</span></span><br><span class="line">					Level     <span class="type">string</span>        <span class="string">`json:&quot;level&quot;`</span></span><br><span class="line">					Districts []<span class="keyword">interface</span>&#123;&#125; <span class="string">`json:&quot;districts&quot;`</span></span><br><span class="line">				&#125; <span class="string">`json:&quot;districts&quot;`</span></span><br><span class="line">			&#125; <span class="string">`json:&quot;districts&quot;`</span></span><br><span class="line">		&#125; <span class="string">`json:&quot;districts&quot;`</span></span><br><span class="line">	&#125; <span class="string">`json:&quot;districts&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GetCityCodes 获取城市编码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetCityCodes</span><span class="params">(jsonData []<span class="type">byte</span>)</span></span> ([]<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">var</span> resp Response</span><br><span class="line">	err := json.Unmarshal(jsonData, &amp;resp)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(resp)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> cityCodes []<span class="type">string</span></span><br><span class="line">	<span class="keyword">for</span> _, district := <span class="keyword">range</span> resp.Districts &#123;</span><br><span class="line">		<span class="keyword">if</span> district.Adcode != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">			cityCodes = <span class="built_in">append</span>(cityCodes, district.Adcode)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> _, subDistrict := <span class="keyword">range</span> district.Districts &#123;</span><br><span class="line">			<span class="keyword">if</span> subDistrict.Adcode != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">				cityCodes = <span class="built_in">append</span>(cityCodes, subDistrict.Adcode)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> _, subSubDistrict := <span class="keyword">range</span> subDistrict.Districts &#123;</span><br><span class="line">				<span class="keyword">if</span> subSubDistrict.Adcode != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">					cityCodes = <span class="built_in">append</span>(cityCodes, subSubDistrict.Adcode)</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">for</span> _, street := <span class="keyword">range</span> subSubDistrict.Districts &#123;</span><br><span class="line">					<span class="keyword">if</span> street.Adcode != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">						cityCodes = <span class="built_in">append</span>(cityCodes, street.Adcode)</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 去重</span></span><br><span class="line">	uniqueCodes := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">bool</span>)</span><br><span class="line">	<span class="keyword">var</span> result []<span class="type">string</span></span><br><span class="line">	<span class="keyword">for</span> _, code := <span class="keyword">range</span> cityCodes &#123;</span><br><span class="line">		<span class="keyword">if</span> !uniqueCodes[code] &#123;</span><br><span class="line">			uniqueCodes[code] = <span class="literal">true</span></span><br><span class="line">			result = <span class="built_in">append</span>(result, code)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> result, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>因为城市存在多个区划，所以这里返回一个城市编码列表。</p>
<h3 id="2-3-搭建mcp-sse-sever"><a href="#2-3-搭建mcp-sse-sever" class="headerlink" title="2.3 搭建mcp sse sever"></a>2.3 搭建mcp sse sever</h3><p>mcp 有多种传输模式：</p>
<ul>
<li>STDIO 传输：STDIO 传输在本地机器上运行，并通过标准输入&#x2F;输出流进行通信。</li>
<li>SSE 传输：服务器发送事件 (SSE) 传输在远程服务器上运行，并通过 <a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=256005974&content_type=Article&match_order=1&q=HTTP/HTTPS&zd_token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJ6aGlkYV9zZXJ2ZXIiLCJleHAiOjE3NTQ3MzgzMjUsInEiOiJIVFRQL0hUVFBTIiwiemhpZGFfc291cmNlIjoiZW50aXR5IiwiY29udGVudF9pZCI6MjU2MDA1OTc0LCJjb250ZW50X3R5cGUiOiJBcnRpY2xlIiwibWF0Y2hfb3JkZXIiOjEsInpkX3Rva2VuIjpudWxsfQ.QQSCi5WPrAbIk8H4Y5E1jSJW5EGwW5agYnAPZBsS7ro&zhida_source=entity">HTTP&#x2F;HTTPS</a> 进行通信。</li>
</ul>
<p>可参考了解下面的文章：</p>
<p><a target="_blank" rel="noopener" href="https://modelcontextprotocol.io/specification/2025-06-18/basic/transports#custom-transports">https://modelcontextprotocol.io/specification/2025-06-18/basic/transports#custom-transports</a></p>
<p><a target="_blank" rel="noopener" href="https://modelcontextprotocol.io/specification/2024-11-05/basic/transports#stdio">https://modelcontextprotocol.io/specification/2024-11-05/basic/transports#stdio</a></p>
<p>代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;github.com/mark3labs/mcp-go/mcp&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/mark3labs/mcp-go/server&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	Port = <span class="string">&quot;:8080&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 创建Mcp server</span></span><br><span class="line">	s := server.NewMCPServer(</span><br><span class="line">		<span class="string">&quot;获取城市天气信息&quot;</span>,</span><br><span class="line">		<span class="string">&quot;1.0.0&quot;</span>,</span><br><span class="line">		server.WithToolCapabilities(<span class="literal">false</span>),</span><br><span class="line">		server.WithRecovery(),</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定义获取城市编码工具</span></span><br><span class="line">	getDistrictTool := mcp.NewTool(<span class="string">&quot;getDistrict&quot;</span>,</span><br><span class="line">		mcp.WithDescription(<span class="string">&quot;获取城市代码，输入城市名，返回城市代码列表&quot;</span>),</span><br><span class="line">		mcp.WithString(<span class="string">&quot;keyword&quot;</span>,</span><br><span class="line">			mcp.Required(),</span><br><span class="line">			mcp.Description(<span class="string">&quot;输入城市名&quot;</span>),</span><br><span class="line">		),</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定义获取城市天气工具</span></span><br><span class="line">	getWeatherInfoTool := mcp.NewTool(<span class="string">&quot;getWeatherInfo&quot;</span>,</span><br><span class="line">		mcp.WithDescription(<span class="string">&quot;获取城市天气信息，输入城市代码，返回天气信息&quot;</span>),</span><br><span class="line">		mcp.WithString(<span class="string">&quot;city_code&quot;</span>,</span><br><span class="line">			mcp.Required(),</span><br><span class="line">			mcp.Description(<span class="string">&quot;输入城市代码&quot;</span>),</span><br><span class="line">		),</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 添加工具的处理函数</span></span><br><span class="line">	s.AddTool(getDistrictTool, <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, request mcp.CallToolRequest)</span></span> (*mcp.CallToolResult, <span class="type">error</span>) &#123;</span><br><span class="line">		<span class="comment">// Using helper functions for type-safe argument access</span></span><br><span class="line">		keyword, err := request.RequireString(<span class="string">&quot;keyword&quot;</span>)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> mcp.NewToolResultError(err.Error()), <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		result, err := getDistrict(keyword)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> mcp.NewToolResultError(err.Error()), <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> mcp.NewToolResultText(fmt.Sprintf(<span class="string">&quot;%v&quot;</span>, result)), <span class="literal">nil</span></span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 添加工具的处理函数</span></span><br><span class="line">	s.AddTool(getWeatherInfoTool, <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, request mcp.CallToolRequest)</span></span> (*mcp.CallToolResult, <span class="type">error</span>) &#123;</span><br><span class="line">		<span class="comment">// Using helper functions for type-safe argument access</span></span><br><span class="line">		cityCode, err := request.RequireString(<span class="string">&quot;city_code&quot;</span>)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> mcp.NewToolResultError(err.Error()), <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		result, err := getWeatherInfo(cityCode)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> mcp.NewToolResultError(err.Error()), <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> mcp.NewToolResultText(fmt.Sprintf(<span class="string">&quot;%v&quot;</span>, result)), <span class="literal">nil</span></span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建一个SSE 模块的server</span></span><br><span class="line">	sseServer := server.NewSSEServer(s)</span><br><span class="line"></span><br><span class="line">	log.Printf(<span class="string">&quot;SSE server listening on port %s&quot;</span>, Port)</span><br><span class="line">	<span class="keyword">if</span> err := sseServer.Start(Port); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>启动服务</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">go build -o mcp-sever</span><br><span class="line">./mcp-sever</span><br><span class="line">2025/08/07 19:24:46 SSE server listening on port :8080</span><br></pre></td></tr></table></figure>



<h1 id="3-在Cherry-Studio-工具中使用mcp"><a href="#3-在Cherry-Studio-工具中使用mcp" class="headerlink" title="3.在Cherry Studio 工具中使用mcp"></a>3.在Cherry Studio 工具中使用mcp</h1><h2 id="3-1-配置"><a href="#3-1-配置" class="headerlink" title="3.1 配置"></a>3.1 配置</h2><p>操作流程可参考官网：</p>
<p><a target="_blank" rel="noopener" href="https://docs.cherry-ai.com/advanced-basic/mcp/config">https://docs.cherry-ai.com/advanced-basic/mcp/config</a></p>
<p>具体流程如下：</p>
<ol>
<li>打开 Cherry Studio 设置。</li>
<li>找到 <code>MCP 服务器</code> 选项。</li>
<li>点击 <code>添加服务器</code>。</li>
<li>将 MCP Server 的相关参数填入（<a target="_blank" rel="noopener" href="https://github.com/modelcontextprotocol/servers/tree/main/src/fetch">参考链接</a>）。可能需要填写的内容包括：<ul>
<li>名称：自定义一个名称</li>
<li>类型：选择SSE模式</li>
<li>URL：填SSE的服务地址（后缀为&#x2F;sse）</li>
</ul>
</li>
<li>点击 <code>保存</code>。</li>
</ol>
<p>配置如图：</p>
<p><img src="/2025/08/07/golang-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8-MCP-%E5%A4%A7%E6%A8%A1%E5%9E%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%8D%8F%E8%AE%AE/image-20250807192525507.png" alt="image-20250807192525507"></p>
<p><img src="/2025/08/07/golang-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8-MCP-%E5%A4%A7%E6%A8%A1%E5%9E%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%8D%8F%E8%AE%AE/image-20250807192746064.png" alt="image-20250807192746064"></p>
<h2 id="3-2-使用MCP工具"><a href="#3-2-使用MCP工具" class="headerlink" title="3.2 使用MCP工具"></a>3.2 使用MCP工具</h2><p>首先在对话下面开启MCP 工具，模型推荐使用chatgpt的</p>
<p><img src="/2025/08/07/golang-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8-MCP-%E5%A4%A7%E6%A8%A1%E5%9E%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%8D%8F%E8%AE%AE/image-20250807192907998.png" alt="image-20250807192907998"></p>
<p>提问：</p>
<p><img src="/2025/08/07/golang-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8-MCP-%E5%A4%A7%E6%A8%A1%E5%9E%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%8D%8F%E8%AE%AE/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20250807170854.png" alt="企业微信截图_20250807170854"></p>
<p>可以看到，大模型确实调用了刚刚创建的MCP 工具，并得到了正确结果！</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">penggewu</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">6</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">penggewu</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  













<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'default',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  

</body>
</html>
